This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: packages/docs/blog/reintroduction.mdx, packages/docs/blog/taming_info.mdx, packages/docs/blog/v1-v2.mdx, packages/docs/blog/wdygdtw_recap.mdx, packages/docs/blog/mission.mdx, packages/docs/partners/, packages/docs/docs/core/actions.md, packages/docs/docs/core/agents.md, packages/docs/docs/core/database.md, packages/docs/docs/core/entities.md, packages/docs/docs/core/evaluators.md, packages/docs/docs/core/knowledge.md, packages/docs/docs/core/overview.md, packages/docs/docs/core/plugins.md, packages/docs/docs/core/project.md, packages/docs/docs/core/providers.md, packages/docs/docs/core/rooms.md, packages/docs/docs/core/services.md, packages/docs/docs/core/tasks.md, packages/docs/docs/core/worlds.md, packages/docs/docs/intro.md, packages/docs/docs/quickstart.md, packages/docs/news/2025-03-22.md, packages/docs/news/2025-03-28.md, packages/docs/news/2025-03-29.md, packages/docs/news/2025-03-30.md, packages/docs/news/2025-04-01.md, packages/docs/news/2025-04-02.md, packages/docs/news/2025-04-03.md, packages/docs/news/2025-04-04.md, packages/docs/news/2025-04-05.md, packages/docs/news/2025-04-06.md, packages/docs/news/2025-04-07.md, packages/docs/news/2025-04-08.md, packages/docs/news/2025-04-09.md, packages/docs/news/2025-04-10.md, packages/docs/news/2025-04-11.md, packages/docs/news/2025-04-12.md, packages/docs/news/2025-04-13.md, packages/docs/news/2025-04-14.md, packages/docs/news/2025-04-15.md, packages/docs/news/2025-04-16.md, packages/docs/news/2025-04-17.md, packages/docs/news/2025-04-18.md
- Files matching these patterns are excluded: **/*.test.ts, **/__tests__/**, **/node_modules/**, packages/docs/community/**, packages/plugin-*/**, **/*.ico, **/*.png, **/*.jpg, **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

## Additional Info
### User Provided Header
ElizaOS Community Context - Documentation and Updates

# Directory Structure
```
packages/
  docs/
    blog/
      mission.mdx
      reintroduction.mdx
      taming_info.mdx
      v1-v2.mdx
      wdygdtw_recap.mdx
    docs/
      core/
        actions.md
        agents.md
        database.md
        entities.md
        evaluators.md
        knowledge.md
        overview.md
        plugins.md
        project.md
        providers.md
        rooms.md
        services.md
        tasks.md
        worlds.md
      intro.md
      quickstart.md
    news/
      2025-03-22.md
      2025-03-28.md
      2025-03-29.md
      2025-03-30.md
      2025-04-01.md
      2025-04-02.md
      2025-04-03.md
      2025-04-04.md
      2025-04-05.md
      2025-04-06.md
      2025-04-07.md
      2025-04-08.md
      2025-04-09.md
      2025-04-10.md
      2025-04-11.md
      2025-04-12.md
      2025-04-13.md
      2025-04-14.md
      2025-04-15.md
      2025-04-16.md
      2025-04-17.md
      2025-04-18.md
    partners/
      0g-labs/
        index.md
      aethir/
        index.md
      allora-labs/
        index.md
      apro/
        index.md
      arbitrum/
        index.md
      arc-agents/
        index.md
      arenax-labs/
        index.md
      arok/
        index.md
      beffai/
        index.md
      berachain/
        index.md
      bnb-chain/
        index.md
      bossu/
        index.md
      collab-land/
        index.md
      crossmint/
        index.md
      daos-fun/
        index.md
      degen8ball/
        index.md
      degenai/
        index.md
      dfinity/
        index.md
      drift/
        index.md
      eigen-layer/
        index.md
      eliza/
        index.md
      eliza-studios/
        index.md
      elizas-sister/
        index.md
      elizas-world/
        index.md
      emblem-vault/
        index.md
      ethereum-foundation/
        index.md
      fleek/
        index.md
      fuel/
        index.md
      fxn/
        index.md
      gaia-network/
        index.md
      gelato/
        index.md
      gnon/
        index.md
      godsdotfun/
        index.md
      goplus/
        index.md
      hats-protocol/
        index.md
      hedera/
        index.md
      heurist-ai/
        index.md
      hume/
        index.md
      hyperbolic/
        index.md
      hyperfy/
        index.md
      injective/
        index.md
      io-net/
        index.md
      iq6900/
        index.md
      jupiter-exchange/
        index.md
      layerzero/
        index.md
      lit-protocol/
        index.md
      magic-eden/
        index.md
      mee-fun/
        index.md
      messari/
        index.md
      mode-network/
        index.md
      monad/
        index.md
      multiversx/
        index.md
      near/
        index.md
      niftyisland/
        index.md
      nillion/
        index.md
      nrn-agents/
        index.md
      partners-nft/
        index.md
      phala-network/
        index.md
      polygon/
        index.md
      project-89/
        index.md
      reality-spiral/
        index.md
      ropraito/
        index.md
      safe/
        index.md
      saga/
        index.md
      scriptoshi/
        index.md
      secret-network/
        index.md
      sei/
        index.md
      smolverse/
        index.md
      society-library/
        index.md
      solana-agentkit/
        index.md
      solana-foundation/
        index.md
      soleng/
        index.md
      sonic-svm/
        index.md
      stanford-university/
        index.md
      story-protocol/
        index.md
      thales-cto/
        index.md
      thirdweb/
        index.md
      ton-network/
        index.md
      tron/
        index.md
      vvaifu-fun/
        index.md
      waye/
        index.md
      wombo/
        index.md
      zerebro/
        index.md
      index.md
      README.md
```

# Files

## File: packages/docs/blog/reintroduction.mdx
`````
---
title: Reintroduction to elizaOS
title_meta: elizaOS — An Operating System for AI Agents
authors:
  - team
  - accelxr
date: 2025-03-07
description: elizaOS is an open-source operating system for AI agents—scalable, decentralized, and built to power autonomous economies, governance, and internet applications.
keywords:
  - elizaOS
  - decentralized AI
  - open-source framework
  - crypto agents
  - AI governance
  - autonomous DAOs
  - AI-native economies
  - modular AI
  - agent frameworks
  - web3 AI
image: /blog/banner.jpg
slug: reintroduction
---

# Reintroduction to elizaOS

![](/blog/banner.jpg)

- Original post: https://x.com/elizaOS/status/1898042782519902342

Today marks the beginning of a new chapter: **elizaOS—an operating system for AI agents**.

{/* truncate */}

elizaOS began as an experiment: what if AI agents could autonomously manage crypto assets for a DAO onchain? This idea, that an AI investment agent might outperform even the best venture investors, sparked something far bigger—a living, open-source ecosystem at the intersection of AI and the Internet. Along the way, we've built a vibrant community of researchers, builders, and visionaries.

This evolution accelerates our commitment to push the boundaries of AI-driven applications across the Internet. elizaOS will serve as the technical foundation for AI-driven economies, governance, and internet applications by championing the core principles of scalability, modularity, and interoperability in pursuit of an autonomous future.

## Why elizaOS?

Artificial intelligence has quickly evolved from a niche curiosity to a driving force in our daily lives, advancing toward more generalized capabilities at a remarkable pace. As AI becomes increasingly central to how we learn, work, and solve problems, the need for open collaboration and broad accessibility grows clearer.

Yet today, the trajectory of AI is largely dictated by a handful of **monolithic, centralized corporations**—entities that operate behind closed doors, hoard models, and set the terms for how AI is deployed and who benefits from it. This concentration of power is dangerous. It leads to AI systems that serve corporate or state interests over the public good, reinforcing inequalities, limiting innovation, and keeping critical advancements out of the hands of those who need them most.

By ensuring AI remains a **shared resource**—rooted in **transparent research, open-source innovation, and community-driven participation**—we can break free from the control of centralized actors and guide AI's development toward outcomes that benefit everyone.

With elizaOS, we're building the infrastructure for this future—an **open, decentralized, and scalable framework** that empowers AI agents to operate, coordinate, and drive meaningful progress across industries and communities. AI should not be a tool of the few; it should be a force for collective intelligence, autonomy, and shared prosperity.

## What is elizaOS?

At its core, elizaOS is the [framework](https://github.com/elizaOS/eliza) for agentic intelligence, built to power the next generation of AI-driven systems. It consists of 3 interconnected pillars:

### The Eliza Framework – Open-Source AI Autonomy

The heart of elizaOS is the framework, a TypeScript-powered, open-source toolkit for building **persistent, adaptable, and interoperable AI agents**. Named after the pioneering 1966 ELIZA program by Joseph Weizenbaum—which simulated human conversation through simple pattern matching—the modern Eliza takes this concept to new heights: unlike static models, Eliza agents evolve over time—carrying memories, context, and knowledge across different environments, enabling them to interact fluidly with each other and external applications.

Today the Eliza Framework has:

- **14.9K stars** and 4.8K forks of our core repository, reflecting massive developer adoption
- **500+ contributors** advancing the open-source ecosystem
- **100+ plugins** expanding functionality

The framework's growth is fueled by a collective vision: to create a decentralized intelligence network where AI agents are not just tools but genuine collaborators, executing complex tasks with efficiency, autonomy, and trust across domains.

### AI-Enhanced Governance

We are pioneering a new era of truly autonomous DAOs. As AI agents achieve trustless coordination, AI-enhanced DAOs will seamlessly integrate them, unlocking new levels of decentralized autonomy.

To enable this, we are building AI-native governance primitives that progressively expand DAO capabilities. Over time, autonomous agents will be entrusted to manage funds, coordinate resources, onboard contributors, and orchestrate both human and machine capital. AI will act as a copilot for treasury management, contributor recruitment, and operational execution, while token holders provide strategic oversight.

This fusion of human intent and agent-driven action redefines decentralized governance, laying the foundation for self-evolving networks. Our open-source community is the first AIDAO—an autonomous ecosystem where builders, thinkers, and agents collaborate as co-creators of a future assembling itself in real time.

### Eliza Labs – R&D for the AI-Native Future

Eliza Labs is the research and development engine, dedicated to advancing the capabilities of elizaOS through cutting-edge AI techniques, proofs of concept, and real-world applications. It pioneers new agent-based projects while supporting open-source contributors via grants, accelerator programs, and ecosystem funding.

Some of the major initiatives currently in development include:

- **Eliza v2**: A next-gen upgrade introducing modularity, a radically improved AI model integration system, and a multi-agent architecture capable of seamless autonomous collaboration at scale. This will be the most powerful iteration of open-source agent frameworks to date.

- **The Global Trust Marketplace**: A social-trading intelligence layer that combines AI-driven reputation scoring, trade validation, and decentralized execution. Integrated across multiple social platforms, it collects user-submitted trade calls and assesses credibility via a Trust Marketplace. Over time, it will evolve into a multi-instance system allowing groups to set their own risk parameters, manage DAO treasuries, and leverage customizable AI modules for enhanced investment strategies.

- **AI-powered Token Launchpad**: A creator-friendly launchpad and no-code platform integrating multi-agent functionality, collaborative tokenomics, and AI-enhanced features. The launchpad enables both technical and non-technical users to seamlessly create and manage tokens and elizaOS agents. In addition, we are working with partners to deliver the best hosted agent experience with no limitations.

- **DegenSpartanAI**: DegenSpartanAI is a crypto-native AI trading agent that blends sentiment analysis, trading strategy automation, and community engagement with a distinct, irreverent personality. Initially refining core trading strategies and its comedic brand, it will evolve into an interactive AI agent with real-time market insights, user-driven discussions, and NFT collaborations. Long-term, it aims to become a fully autonomous trading agent, integrating multi-platform execution, adaptive learning, and a verifiable track record within the Global Trust Marketplace.

- **Eliza Studios**: A creative studio where AI meets art, storytelling, and digital experiences in a way never seen before. We're building autonomous characters, generative media experiments, and immersive AI-powered narratives that will redefine entertainment itself.

Beyond these initiatives, Eliza Labs continues to refine multi-agent architectures, develop better coordination mechanisms, and explore integrations with an end goal to embed AI agents into the very fabric of digital economies, transforming how we govern, transact, research, and create.

![](/blog/elizastudios.jpg)

## The Coordination Layer of AI-Native Economies

To coordinate these three pillars, elizaOS uses the native token on Solana (HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC) to engineer a generative economic network. As elizaOS scales across platforms and industries, the token functions as both an index of the network and a conduit for collective growth.

Today, the token serves as the coordination layer for research, development, and open-source innovation. As AI-native applications, marketplaces, and autonomous systems emerge around elizaOS, the token is evolving into the primary mechanism for capturing and redistributing the economic value they generate. While details will be unveiled in phases, some key areas of research and development include:

- **Staking for ecosystem access** – Implementing mechanisms that allow users to stake tokens to access new partner tokens and enhance distribution for projects building on our framework.
- **Partner LP staking pools** – Creating liquidity pools where users can pair the native token alongside partner assets, driving liquidity and demand.
- **Core product integration** – Leveraging platforms like the Trust Marketplace, autofun, and Eliza Studios to amplify network effects, expand our native token treasury, and reinforce staking incentives.
- **Autonomous trading agents** – Deploying AI-driven trading agents to strategically acquire our native tokens and manage liquidity positions.
- **Expanded partner incentives** – Enhancing benefits for participants in the Partners program, increasing alignment and long-term engagement.
- **DAO-funded development** – Rewarding contributions and donations to the DAO, ensuring sustainable funding for the core framework's development.

The token underpins the economic infrastructure that links AI autonomy to the wealth of opportunities it unlocks. Many of our projects—including the Trust Marketplace, token launchpad, and Eliza Studios—directly contribute to the token's utility by driving network effects, transaction flows, and AI-native services.

In short, we intend to make the native token the base layer for the many applications and services built on top of our framework through mechanism design, ecosystem tooling, partnerships, and collaborations.

## Our Vision of the Future

The internet began as a static archive—a vast repository of human knowledge, waiting to be accessed. Then it became dynamic, social, algorithmic. Now, it is transforming again: into something intelligent.

This transformation isn't led by a single company—it's emerging from an interconnected ecosystem of open protocols, decentralized incentives, and AI-native economies. This is why elizaOS is open-source, modular, and decentralized—so no single entity controls it, and anyone can build upon it.

The agents we build today will form the foundation of a self-organizing intelligence that transcends industries, borders, and human limitations.

A world where networks think, collaborate, and evolve alongside us.

A world where intelligence itself is the fabric of the internet.

This is the world we are building.

This is the world of elizaOS.

## Join the Movement

elizaOS is no longer just an experiment—it's a movement. If you're a builder, researcher, or visionary, now is the time to shape the future with us.

Contribute to the open-source Eliza Framework. Become a partner in the DAO. Build agentic applications across the web.

elizaOS isn't just ours to create —

**elizaOS is YOURS.**

![](/blog/yours.jpg)
`````

## File: packages/docs/blog/taming_info.mdx
`````
---
slug: taming-info
title: Tools for Taming Information
description: Using AI to manage information flow across platforms and keep communities aligned
authors: jin
date: 2025-04-03
tags: [tools, information, community, documentation, AI news, automation]
image: /blog/aicomms.jpg
---

# Tools for Taming Information

From summarizing Discord channels to generating daily AI-powered newsfeeds, we're building tools that help communities stay aligned, surface insights, and reward contributors — without needing everyone to be everywhere at once. This post shares practical examples and blueprints for deploying Eliza agents across your own projects.

[![3D News Show Example](/blog/aicomms.jpg)](/blog/aicomms.jpg)

{/* truncate */}

## Challenges

[The Great Online Game](https://www.notboring.co/p/the-great-online-game) is played across many different apps and chat rooms. One of the biggest challenges facing players is locating critical information like who does what or updates scattered when it's across Discord channels, GitHub repositories, forums, threads, etc. No human, regardless of how dedicated, can keep track of everything.

![XKCD comic about information scattering](/blog/xkcd1810.png)
https://xkcd.com/1810/

Even when information is theoretically "public," people are generally too lazy to fetch it. That and stakeholders may prefer different information formats:

- Developers dig into GitHub
- Community vibes on Discord
- Casual followers scroll Twitter
- Visual learners watch videos

Instead of forcing everyone onto one highway early on, a better strategy would be to build bridges between lanes to allow information to flow more freely. AI agents are the vehicles for that information, they carry the ability to meet people where they are to deliver important insights while preserving context.

### Goals

- Reduce overhead on managing comms / community questions
- Keep people informed across different platforms
- Accelerate onboarding for new contributors

---

### Case Study: AI News System

This [discord summarizer](https://github.com/elizaOS/discord-summarizer) was the first prototype. For ElizaOS we're now using [this AI News tool](https://github.com/bozp-pzob/ai-news) to aggregate sources from across the ecosystem. The system works in four key stages:

1. **Collection**: APIs pull data from multiple sources including Twitter, Discord, GitHub, and market data platforms.
2. **Wrangling**: LLMs normalize, summarize, and tag topics to create a unified knowledge base from disparate sources.
3. **Distribution**: The system produces standardized outputs in multiple formats (JSON, Markdown, RSS) to suit different consumption needs.
4. **Consumption**: Users can access tailored products like dashboards, newsletters, or even 3D news shows.

```mermaid
flowchart TD
    subgraph "Data Collection"
        A1[Twitter API] --> B[Data Collector]
        A2[Discord Bot] --> B
        A3[GitHub API] --> B
        A4[Market Data APIs] --> B
    end
    style A1 fill:#6CB9E5,color:#333
    style A2 fill:#7289DA,color:#FFF
    style A3 fill:#333333,color:#FFF
    style A4 fill:#85bb65,color:#FFF
    style B fill:#9F8AF9,color:#FFF

    subgraph "Data Wrangling & Enrichment"
        B --> C[Content Normalization]
        C --> D[Topic Extraction/LLM]
        D --> E[Summarization/LLM]
        E --> F[Storage/SQLite]
    end
    style C fill:#FFA500,color:#333
    style D fill:#FF7F50,color:#333
    style E fill:#CD5C5C,color:#FFF
    style F fill:#4682B4,color:#FFF

    subgraph "Distribution"
        F --> G1[JSON API Endpoints]
        F --> G2[Markdown Files]
        F --> G3[RSS Feeds]
    end
    style G1 fill:#7EB77F,color:#333
    style G2 fill:#86C67C,color:#333
    style G3 fill:#98FB98,color:#333

    subgraph "Consumption"
        G1 --> H1[DAO Dashboards]
        G1 --> H2[AI Agent Knowledge Base]
        G2 --> H3[Newsletter/Blog]
        G3 --> H4[3D News Show]
    end
    style H1 fill:#DDA0DD,color:#333
    style H2 fill:#DA70D6,color:#333
    style H3 fill:#BA55D3,color:#FFF
    style H4 fill:#9370DB,color:#FFF
```

You can see the results from this tool here, which updates daily via GitHub actions:

- https://m3-org.github.io/ai-news/
- https://eliza.how/news

<div className="responsive-iframe">
  <iframe
    src="https://www.youtube.com/embed/fIGoyaEd0Hw"
    title="YouTube video player"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  />
</div>
Here's an example news clip: https://x.com/elizaOS/status/1880280863210106975

---

## Case Study: AI Assistants

Idk about you, but I hate seeing questions left hanging in tech support channels, especially when the answer can easily be found in the docs. It's a perfect opportunity to [eat our own dogfood](https://en.wikipedia.org/wiki/Eating_your_own_dog_food), experience and fix pain points firsthand, and showcase a powerful use case of AI agents to other devs.

[![jintern2](/blog/jintern.jpg)](/blog/jintern.jpg)

While we're analyzing tech support channels, we can identify gaps in docs based on common community questions which can then be addressed systematically. This may involve checking if any github issues or pull requests already address a question, and if not, then to help create an issue for it. Herein lies a powerful feedback loop:

- Aggregate & Analyze: Extract questions and answers, who is helping who (and if succesful), identify pain points, gather sentiment
- Clean & Enhance Data, Update docs, create bug reports
- RAG Knowledge: AI Agents giving automated responses to FAQ

You can now use [AI news](https://github.com/bozp-pzob/ai-news) to generate a summary, who helped who, FAQ, and action items analysis of a source for whatever time period you want - even historically!

[![image](/blog/ainews.jpg)](/blog/ainews.jpg)

We retroactively reward people who provided good answers to questions (we're using tip.cc) over a time period. Later people can reuse their tips when helping or asking for help from other people.

[![image](/blog/reward.jpg)](/blog/reward.jpg)

**Main Lesson: Treat the docs as first-class citizen of your project.**

Eliza AI agent assistants helping devs with common questions about elizaOS greatly benefit from good docs to provide more current and accurate information, which speeds up onboarding and lets developers stay focused on higher impact activities.

> Read [this guide](https://www.kapa.ai/blog/optimizing-technical-documentation-for-llms) on how to optimize technical docs for LLMs. Adding FAQ with answers in the docs enhances optimizes them for LLM use cases.

---

## Get Involved

In the future I want people to be able to install Eliza and be greeted by an agent that can help you setup, configure settings, create plugins, deploy, etc. For now I think our assistants need to be supervised until we're confident enough in their responses. I think we can speed things up by having the agent admit what they don't know the answer vs hallucinating, and to guide devs to the main community support channels when they're having difficulty.

If you want to collaborate with us, here's a few ideas:

- Answer people's questions in the coders / tech support channels on discord, it will get noticed :)
- Help with docs: go through pages, verify information with code, test the steps, create issues and PRs with fixes
- Collaborate with us on the [AI news aggregator](https://github.com/bozp-pzob/ai-news)
  - Generate new show ideas using the [output files](https://m3-org.github.io/ai-news/) from AI-news
  - Write a script that takes a week of daily logs and turns it into a newsletter or news show program
- Ingest docs into your Eliza agent as knowledge to onboard them then tinker with the character file to takee on a role in the DAO
  - Perhaps it can act as a scribe that summarizes chats
  - Lore keeper, community moderation, or social media marketer

### Links

- https://github.com/bozp-pzob/ai-news (aggregator tool)
  - https://m3-org.github.io/ai-news/ (data for elizaOS ecosystem)
- https://github.com/elizaOS/knowledge (for eliza RAG knowledge)
- https://www.kapa.ai/blog/optimizing-technical-documentation-for-llms
- https://x.com/dankvr/status/1884417610420474199 (update 1/28/25)
- https://x.com/dankvr/status/1880050455226827246 (update 1/16/25)
`````

## File: packages/docs/blog/v1-v2.mdx
`````
---
slug: v1-v2
title: ElizaOS V2 - What's New
description: A comprehensive guide to the changes and improvements in ElizaOS V2 compared to V1
authors: jin
date: 2025-03-22
tags: [release, v2, architecture, features, upgrade]
image: /blog/v1-v2.jpg
---

# ElizaOS V2: What's New

The newest version of [eliza](https://github.com/elizaOS/eliza) represents significant upgrades from the previous version, offering a leaner, more flexible architecture for cross-platform agent interaction. This short guide highlights the key differences between V1 and V2.

[![](/blog/v1-v2.jpg)](/blog/v1-v2.jpg)
{/* truncate */}
Source: https://www.youtube.com/watch?v=yUjScwAZsQo

### V2 Impact

- **Cross-Platform Presence**: Your agent can jump from Twitter, continue via SMS, and place orders with businesses—all while maintaining conversation context.
- **Unified Blockchain Management**: One wallet to rule all chains—no more chain-switching headaches.
- **Autonomous Workflows**: Agents that handle multi-step processes independently—researching data, analyzing results, generating reports, and scheduling follow-ups without constant oversight.
- **Evolving Intelligence**: Database-driven characters that can start minimal and grow through interactions with your crowd.
- **Enhanced Security**: Native TEE integration provides verifiable security guarantees for sensitive operations while maintaining privacy.

---

## Core Architecture Redesign

| V1 Limitation                                                         | V2 Solution                                                                           |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Bloated Core**: Codebase overloaded with packages from rapid growth | **Package Registry**: Submit plugins independently; lean codebase, no approval delays |
| **Fragmented Messaging**: Platform-specific I/O pipelines             | **Unified Messaging**: Agents process inputs and output anywhere, seamlessly          |
| **Wallet Overlap**: Multi-chain wallet conflicts                      | **Unified Inventory**: One wallet with chain-agnostic actions                         |
| **Rigid State**: Hardcoded goals and features                         | **Modular State**: Extensible, optional components for tailored agents                |
| **Basic Action Chaining**: No multi-step foresight                    | **Strategic Planning**: Agents map out complex, sequenced workflows                   |
| **Package Manager Speed**: Lengthy installations and cold starts      | **Bun Integration**: Faster installs, reduced build times                             |

---

## Technical Implementation Changes

```mermaid
graph TB
    %% Main Components with vertical orientation
    User((User)):::user

    %% First Level - Services
    PlatformServices[Services]:::services

    %% Second Level - Runtime
    AgentRuntime[Agent Runtime]:::core

    %% Core Processing Components - Side by side
    subgraph "Core Processing"
        direction LR
        Providers[Providers]:::int
        Actions[Actions]:::int
        Evaluators[Evaluators]:::int
    end

    %% Knowledge and DB - Side by side
    subgraph "Knowledge & Storage"
        direction LR
        Knowledge[Knowledge]:::int
        DB[(Database)]:::db
    end

    %% Organization Components - Vertical layout
    subgraph "Organization"
        direction TB
        Worlds[Worlds]:::struct
        Rooms[Rooms]:::struct
        Entities[Entities]:::struct
    end

    %% Development Components - Side by side
    subgraph "Development & Integration"
        direction LR
        Plugins[Plugins]:::dev
        Projects[Projects]:::dev
        Tasks[Tasks]:::dev
    end

    %% Main Flow - Vertical emphasis
    User <-->|Interaction| PlatformServices
    PlatformServices -->|Process| AgentRuntime

    %% Runtime connections - Simplified
    AgentRuntime ---|Context| Providers
    AgentRuntime ---|Behavior| Actions
    AgentRuntime ---|Analysis| Evaluators

    %% Data connections
    AgentRuntime <-->|Storage| DB
    Knowledge -->|Informs| Providers

    %% Structure connections - Clean vertical hierarchy
    AgentRuntime -->|Manages| Worlds
    Worlds -->|Contains| Rooms
    Rooms -->|Has| Entities

    %% Development connections
    Projects -->|Configure| AgentRuntime
    Plugins -->|Extend| AgentRuntime
    Tasks -->|Scheduled by| AgentRuntime

    %% Clickable nodes with links to docs
    click AgentRuntime "/docs/core/agents" "Learn about Agent Runtime"
    click PlatformServices "/docs/core/services" "Learn about Services"
    click DB "/docs/core/database" "Learn about Database Systems"
    click Actions "/docs/core/actions" "Learn about Actions"
    click Providers "/docs/core/providers" "Learn about Providers"
    click Evaluators "/docs/core/evaluators" "Learn about Evaluators"
    click Knowledge "/docs/core/knowledge" "Learn about Knowledge System"
    click Worlds "/docs/core/worlds" "Learn about Worlds"
    click Rooms "/docs/core/rooms" "Learn about Rooms"
    click Entities "/docs/core/entities" "Learn about Entities"
    click Plugins "/docs/core/plugins" "Learn about Plugins"
    click Projects "/docs/core/project" "Learn about Projects"
    click Tasks "/docs/core/tasks" "Learn about Tasks"

    %% Styling
    classDef core fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef services fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef int fill:#e74c3c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef struct fill:#f39c12,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef dev fill:#1abc9c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef user fill:#ecf0f1,stroke:#2c3e50,stroke-width:2px,color:#2c3e50,font-weight:bold,border-radius:50%
```

### From Clients to Services

V2 swaps Clients for Services, standardizing platform integration while centralizing message routing—agents now think once, act anywhere (Discord, Twitter, SMS, even phone calls).

### Smarter Character Evolution

V2 swaps static files for dynamic personas—agents learn from your crowd in real-time while still being able to be imported / exported as JSON files (see [docs](/docs/core/project)).

### Enhanced Development Experience

New CLI and plugin manager slashes setup time. Instead of cloning the github repo, changing to the correct branch, rebuilding, etc, it's just one command to create a new project:

```bash
npm create eliza@beta
```

<details>
    <summary>See CLI commands</summary>
    
```bash
Usage: elizaos [options] [command]

Options:
-V, --version output the version number
-h, --help display help for command

Commands:
create [options] [name] Initialize a new project or plugin
project Manage an ElizaOS project
plugin Manage ElizaOS plugins, including publishing
agent manage ElizaOS agents
tee Manage TEE deployments
start [options] Start the Eliza agent with configurable plugins and services
update [options] Update ElizaOS packages to the latest versions
test [options] Run tests for Eliza agent plugins
env Manage environment variables and secrets
dev [options] Start the project or plugin in development mode and rebuild on
file changes
publish [options] Publish a plugin or project to the registry
help [command] display help for command

````
</details>

Explore the plugin repository https://github.com/elizaos-plugins/ or from the [docs showcase](/packages).

### Memory and Task Management
Vector embeddings power richer memory; tasks now handle schedules and multi-step logic.

```typescript
await runtime.createTask({ ... });
```

---

## Timeline

- **March 2025**: Research beta now live.
- **April 2025**: Public rollout.

### Should You Upgrade?

V2 is mostly backward compatible for gradual migration. Existing projects can phase in V2 features; new ones should start with V2 for full benefits. V1 still works, but V2's modularity and planning unlock next-level autonomy. See [quickstart](/docs/quickstart) to get started.
`````

## File: packages/docs/blog/wdygdtw_recap.mdx
`````
---
slug: wdygdtw-recap
title: "What Did You Get Done This Week? Recap"
description: A comprehensive archive of the weekly Twitter Spaces where developers shared their AI agent project progress
authors: jin
date: 2025-01-31
tags: [community, development, progress, twitter spaces, archive, video]
---

# "What Did You Get Done This Week?" Recap

From November 2024 to January 2025, we held a weekly Twitter Spaces where developers shared progress about their AI agent projects. If you shipped something related to open source AI / social agents that week, you were allowed 1-2 minutes to share an update of what you have been working on. Thousands of listeners tuned every Friday night to essentially listen to a dev standup.

{/* truncate */}

![](https://pbs.twimg.com/media/Fd2lvapVsAAFvsG.jpg)

The WDYGDTW series played a role in establishing momentum and maintaining it throughout the formative months as the crypto x AI agent space was heating up. The weekly accountability structure encouraged:

- **Rapid iteration cycles** from concept to implementation
- **Cross-pollination of ideas** between different teams
- **Public documentation** of the ecosystem's growth
- **Establishment of norms** around open development
- **Community reputation building** through consistent delivery

## Timeline

We transcribed, summarized, and uplaoded notes for every Space shortly after each one. However, until now the recordings and notes haven't all been easily accessible all in one place. Showing up is half the battle. These are the pioneers of a grassroots crypto / AI movement.

```
- Nov 15, 2024
- 1: Social Agents / Advancing towards AGI
    - Logan, Kyle (Raid Guild), Glue, Ropey, Loaf, Odilitime, SomewheresHe, Robin, IQ6900, Marvin, Dot, JW, Neo, Bloom, Reality Spiral, Jen, OFI, Butoshi, Doc (Geon Reborn), HCP, Garrett, Lady Liberty, BoyaLockser, Amy, Griffin, Frank (Heurist), Shaw, Tim
    - Trust Marketplace, EVM wallet integration, Ducky AI client, Telegram fixes, Starknet wallet plugin, Sentience media generation, God's Fun, TEEs, Streamer platform, Decentralized AI cloud, Twitter client PR, Documentation, Satoshi AI memory system, Echo Chambers, Agent designs, Deep Writer, Music agent project, Psychic AI, Heurist API integration
        - https://www.youtube.com/watch?v=9EmvhlBPB8Q
- Nov 22, 2024
- 2: 3500 people tuning in to AI agent devs
    - Reality Spiral, Boyaloxer, Spaceodili, Yodamaster726, Wiki, Hashwarlock, KyleSt4rgarden, Nasdao_, Evepredict, ByornOeste, Empyrealdev, SkotiVi, YoungBalla1000x, SOL_CryptoGamer, Angelocass, DAOJonesPumpAI, RodrigoSotoAlt, CottenIO, HDPbilly, IQ6900, frankdegods, jamesyoung, 0xglu, chrislatorres, shannonNullCode, robotsreview, bcsmithx, JustJamieJoyce, yikesawjeez, HowieDuhzit, xrpublisher, BV_Bloom1, nftRanch, 019ec6e2, jacobmtucker, CurtisLaird5, unl__cky, Rowdymode, mitchcastanet, GoatOfGamblers, JohnNaulty, mayanicks0x, wakesync, TrenchBuddy, rakshitaphilip, MbBrainz, Hawkeye_Picks, Shaw, dankvr
    - GitHub integration, emotional plugin for agents, Reddit-based AI agent, Token Gods project, Coinbase plugin, AI agent streaming platform, DuckAI client, Hustle and Flow State, image generation prompts, Oasis agent simulation, Sentientopia, Eliza as "real girl", D-Gen Spartan revival, LaunchRate AI16DAO, Satoshi AI characters, MUSE DAO CEO, music-creating agent, livestreaming in 3D, log rotation tool, Earth Poker AI game, healthcare app, FXN swarm, Trust Marketplace, Eliza style guidelines, NFT project AI CEO, finance and entertainment projects, Twitter client with Vision AI
        - https://www.youtube.com/watch?v=Lbvv0Dr91Bc
- Nov 29, 2024
- 3: Community Building
    - Jin, Stargarden, Boya, Reality Spiral, W3Tester, HashWarlock, Soto, Mitch, Nick Parallel, Beige, Robin, Eve, Oguz, Swarm, RektDin, Roperito, Lothbrok, Clark Riswold, Tim, Spaceodili, Hawkeye, EA, FilteredThought, Yikes, Alain, Glue, Maximilian, Danny, Shaw, YoungJazzeth, Sergio
    - Self-sustaining AI DAOs, IRC connector, Dark Sun project, Binary solar system, 3D environments, BlockRat AI, Apollo health agent, data grading, Eliza interface, AI hosting platform, Rogue Agent podcast, "Life Engine", AI for logistics, Positivity AI, Eliza's World, Scriptoshi on Bitcoin, Marble auctions, Twitter integration, Web3 research, multi-agent system for code, quantum randomness, agent show marketing
        - https://www.youtube.com/watch?v=nUAEQ7uKi04
- Dec 6, 2024
- 4: Communications, Updates and Accountability
    - Shaw, Ropirito, Liam Zebedee, LordOfAFew, Robin, Reality Spiral, Ico, Glue, Shannon NullCode, JW, Guha, Frago, Yeshua God, AvaDoesAI, Spaceodili, Bloom, Joven, Satoshi_AI_Live, Simeon Fluck, NavarroCol, BeigeGrape, Andrew Miller, Johnny, Collins, Baron, Anthony, Wit, Ophi, Colin, Ranch, Oguz, Issy, Nick, Dr. K, BallerHash, Tim
    - Twitter & TikTok capabilities, Average French AI agent, Eliza framework improvements, Token Gods launch, Coinbase plugin, AI agent streaming platform, DuckAI client, knowledge graph system, LLM image prompts, Oasis simulation project, agent network connector, Sentientopia digital nation, Eliza as "real girl" concept, D-Gen Spartan revival, tokenomics, LaunchRate AI16DAO, small town AI characters, MUSE AI CEO, music-creating agent, market data livestreaming, log rotation security tool, Earth Poker AI game, crypto assistant, healthcare app, FXN swarm, Trust Marketplace, style guidelines, Tweek Labs AI CEO, finance projects, Baba Cat project, animation, KWAI network controller
        - https://www.youtube.com/watch?v=r3Z4lvu_ic4
- Dec 13, 2024
- 5: Building the Future
    - shawmakesmagic, xsubtropic, CottenIO, HDPbilly, IQ6900, frankdegods, jamesyoung, 0xglu, chrislatorres, reality_spiral, robotsreview, shannonNullCode, bcsmithx, boyaloxer, JustJamieJoyce, yikesawjeez, RodrigoSotoAlt, HowieDuhzit, xrpublisher, BV_Bloom1, nftRanch, 019ec6e2, jacobmtucker, CurtisLaird5, unl__cky, Rowdymode, mitchcastanet, GoatOfGamblers, JohnNaulty, mayanicks0x, wakesync, TrenchBuddy, rakshitaphilip, MbBrainz, Hawkeye_Picks, dankvr
    - Redux project, DaVinci AI, AI Summit recap, "Sploot" agent, on-chain ASCII art, character sheet tweaks, AI agent starter kit, agent swarms, Eliza.gg documentation, GitHub integration, Story Protocol plugin, Emblem Vault, Agent Tank, Plugin Feel for emotions, research AI agents, Discord bot, Metaplex NFTs, character generator, XR Publisher 3D network, 3D agent interactions, trading bot, Mimetic platform, agent transaction protocol, C-Studio interface, Escapism art generation, interactive streaming, binary star research, prediction market, SWE contributions, Axie AI KOL agent, Eliza Wakes Up, AWS templates, Brunette token, menu recommendations, storytelling bot
        - https://www.youtube.com/watch?v=4u8rbjmvWC0
- Dec 20, 2024
- 6: Hackathons, Frameworks, and the Race to Ship
    - dankvr, shawmakesmagic, IQ6900, spaceodili, bcsmithx, 0xBuildInPublic, jamesyoung, yikesawjeez, evepredict, yashhsm, TheLDAIntern, _0xaryan, CogAccSOL, reality_spiral, HDPbilly, CheddarQueso3D, ineedtendies, marvin_tong, BV_Bloom1, RealJonahBlake, DustinStockton, dylanpaulwhite, chrislatorres, 0xnavkumar, Hawkeye_Picks, lostgirldev, HowieDuhzit, boyaloxer, nizhanxi, ropirito, gigawidearray, GoatOfGamblers, shakkernerd, triadfi, MoondogFeed, wakesync, Moonbear, PoodonkAI, ViralMindAI, FilteredThought, _AnonDev, get_palet, MurrLincoln, socrates1024, IGLIVISION, dooly_dev, codergf_xyz, Ru7Longcrypto, sunosuporno, Signalman23, swarmnode, svabhishek, elohprojects, deltavius
    - Solana blockchain data service, GitHub PR merging, Agent Tank viral video, security auditing, AI agent hackathon, Matrix bridge, trading bot draft, Solana Agent Kit, market insights agent, website launch, GitHub client, tone control in agents, WSL setup guide, WordPress client, self-sustaining AI ecosystem, payment processing, 3D rigging, health agents, Sober Rover companion, Eliza.gg Q&A platform, Bitcoin runes project, Santa Pimp Claus token, SolEng agent, character generator updates, boredom tracking, Asia trip organizing, AWS hosting, Reddit plugin, prediction market for memecoins, Redis caching, AI personality agents, social media to meme coins, persistent memory, vvaifu agent, AI hive mind, decentralized training platform, auto-trading agent, "Mizuki" AI model, open context protocol, AgentKit updates, TEE login system, game framework study, AGI matching platform, one-click chatbot deployment
        - https://www.youtube.com/watch?v=R3auUQj9oEg
- Dec 27, 2024
- 7: Agentic Documentation and GitHub Integration
    - ai16zdao, shawmakesmagic, spaceodili, 0xBuildingPublic, Im_zo_eth, IQ6900_, FilteredThought, yeahimomar, affaanmustafa, KyleSt4rgarden, SYMBiEX, codergf_xyz, GoatOfGamblers, SuperfruitsAi, hashwarlock, allenharper, witconomist, triadfi, human_for_now, reality_spiral, lordOfAFew, chrislatorres, evepredict, lostgirldev, r4dicalcentrism, 0xblacksun, tmoindustries, wakesync, sunosuporno, unl__cky, hotpot_intern, TrenchBuddy, Signalman23, thelotioncoin, anshikag85, Doc_strange1, dankvr
    - Hyperfy multi-agent integration, agentic JS documentation, on-chain agent "Q", data storage cost reduction, trading system with TrustDB, Minecraft AI villagers, streaming coding sessions, Solana AI hackathon, character creation tool, Web app staging, prediction market, web3 security agents, Spore agent swarm, "Shaw" character file, Trust marketplace white paper, prediction market analyst, search engine for dev videos, GitHub adapter, recursive self-improvement, generative agents for on-chain games, V2 development meetings, travel influencer agent, PR review agents, SoulScript for agent personalities, digital archaeologist agent, climate/nature focused ERC6551 agents, Eliza Wakes Up web app, DeFi agent, autonomous audio/song generation, TikTok memecoin hunter, wallet tracking visualization, voice AI for Twitter Spaces, integrating AI into existing projects, AI/AWS newsletter, TikTok integration
        - https://www.youtube.com/watch?v=jcSF7dSicTI
- Jan 3, 2025
- 8: From DeFi to Social Media
    - ai16zdao, shawmakesmagic, astridhpilla, lostgirldev, spaceodili, 0xBuildInPublic, youfadedwealth, nftRanch, SYMBiEX, SuperfruitsAi, TimshelXYZ, chrislatorres, AIFlow_ML, jamesyoung, deadlock_1991, yeahimomar, human_for_now, lordasado, RodrigoSotoAlt, HDPbilly, GoatOfGamblers, Titan_Node, KyleSt4rgarden, unl__cky, CheddarQueso3D, sunosuporno, tmoindustries, Sawyer_APRO, wakesync, Ru7Longcrypto, marko_post, NEETOCRACY, HefAiGent, reality_spiral, witconomist, triadfi, Rowdymode, MaushishYadav, chaininsured, godfreymeyer, thelotioncoin, codergf_xyz, IGLIVISION, EledraNguyen, GnonOnSolana, Satoshi_BTCFi, swarmnode, memeillionaire, krauscrypto, usebuildfun, affaanmustafa, O_on_X, AITATsol, xiao_zcloak, Protocol_Blend, yq_acc, akshayynft, BenjiStackzzz, 0xBuns, aiquantfun
    - Miku chatbot relaunch, Selene growth & PR review, Eliza framework fixes, voice features, plugin isolation, Audits agent documentation, PP coin automated trading, framework integration, DeepSeek model provider, Dragon Fruit AI launch, Meetup Fund platform, Eliza partnerships, knowledge graph for repos, verifiable inference system, Alice AI fund management, Pixocracy AI village management, form fill infrastructure, Smol World agent reasoning, Bosu memory management, Twitter client reflection loop, Goat Arena prediction market, LivePeer inference endpoints, Solana token staking, media generation improvements, agent documentation, DeFi assistant waitlist, region swarm voice integration, BNB chain integration, Netflix & chill extension, dating coach AI agent, Mars' first digital citizen, Army of Indians DAO, ERC 314 technology integration, GitHub client for scrum planning, Marketplace of Trust white paper, AI personality expansion, Twin Tone beta testing, yield optimizing agent, insurance broker agent, 3D news show avatars, AI agents for social channels, Haruka Twitter bot, NFT marketplace on Superchain, Square Fun AI analytics, Echo Chambers v2.3, Swarm Node growth, token integration, voice cloning mobile app, no-code AI agent builder, project scaling strategies, AI agent unsuspension techniques, global trade analysis, crypto payment functionality, DeFi protocol user experience
        - https://www.youtube.com/watch?v=Vs7D5DN_trk
- Jan 10, 2025
- 9: AI Agents to DePIN
    - ai16zdao, spaceodili, 0xBuildInPublic, yeahimomar, unl__cky, CheddarQueso3D, lostgirldev, ohhshiny, SYMBiEX, nftRanch, HDPbilly, zerokn0wledge_, KingBootoshi, calintje, hashwarlock, MattPRD, dreygo_, 0xShiroe, lostboydev, brownsvgar, human_for_now, aiagentpepe, sea_of_zhou, tito_cda, thelotioncoin, chineseremilio, _cjft, dino2deno, AIFlow_ML, tmoindustries, astridhpilla, marvin_tong, yikesawjeez, djsamforever, KyleSt4rgarden, ProfRizzAI, vargs_g, KarimaDigital, Amiewitheliza, reality_spiral, wenkafka, slmsolcto, AaronErickson, GoatOfGamblers, c0mput3rxz, wakesync, aiquantfun, sunosuporno, ongo_ai, y7_y00ts, xiao_zcloak, ViralMindAI, Artstridee, bryanjmonterrey, O_on_X, svabhishek, CottenIO, hotpot_intern, TimshelXYZ, shawmakesmagic, dankvr
    - Database and memory systems, documentation enhancements, Pixocracy Launchpad, image and music generation, AI in education, Aora project, hackathon judging, troll bot agent, TEE exploration, Discord deployment, DeFi agent swarm, summary kernel experiment, on-chain swaps, cross-VM bridging, Feather agent framework, Orca liquidity provisioning, Oracle agent on Sporephone, research paper auditing, market-making platform, GigaBread jailbreak testing, Solimp realism enhancement, Eliza texting buddy, automatic data collection, DePIN plugin for real-world data, Dark Sun digital investigator, platform front-end implementation, AI model Zion, AWS dockerization, multi-wallet volume bot, Akash plugin development, insurance app for natural capital, CES meetings and partnerships, TEE Cloud onboarding, Eliza PR merging system, Shogun plugin contributions, token staking documentation, Riz.ai entertainment platform, Zero-G storage plugin, dating coach AI, ecosystem integration, prompt logging system, wallet natural language commands, time series modeling for hurricanes, Goat Arena platform, token selector plugin, "simp to earn" feature, AI quant launchpad, Midas project wallet infrastructure, Ongo art critic expansion, Utes sports analytics, TikTok wallet integration, Minecraft tournament infrastructure, trading dashboard with social features, X account suspension workarounds, RAP framework development, image generation training, ZoroX TikTok coin hunter
        - https://www.youtube.com/watch?v=fqM_vYK2bmc
- Jan 17, 2025
- 10: From Digital to Physical
    - ai16zdao, shawmakesmagic, JustinMoonAI, AntiRugAgent, rckprtr, dreygo_, Audix_hq, coordinape, lostgirldev, AIFlow_ML, astridhpilla, thelotioncoin, RodrigoSotoAlt, berliangor, unl__cky, xiao_zcloak, 0xnavkumar, GoatOfGamblers, Amiewitheliza, 0xVEER, BuzzyCrypto_, SYMBiEX, w1kke, luki_notlowkey, AgentTextdotfun, yikesawjeez, ByornOeste, Nasdao_, elizawakesup, dankvr, sypherlit
    -  Eliza V2 development, inventory system, CLI, Tron integration, rug pull prevention, Discover AI community management, Kyra AI market-making, smart contract visuals, Farcaster community rewards, website and terminal development, PR agent for ElizaOS, voice and VRM development, API connections, persistent memory system, SQLite rewriting in Rust, Telegram launch, "Approve Agents" model for wallets, verifiable TEE Network, Telegram mini apps, internal team calls, ETH Denver AI program, autonomous trader and music releases, web search in agents, devotion program staking, on-chain data plugin, DePIN network for SMS, CICD improvements, conspiracy theory thesis, DeFi validator personality, Eliza's robot body, Degen Spartan AI trading, Void AI cross-chain mixer
    - https://www.youtube.com/watch?v=1voboZEQTAw
- Jan 24, 2025
- 11: AI Agents Level Up
    - ai16zdao, SYMBiEX, astridhpilla, davidlsneider, dreygo_, GoatOfGamblers, unl__cky, thelotioncoin, Amiewitheliza, lostboydev, lostgirldev, AIFlow_ML, _AnonDev, damascoai, ITzMiZzle, MementsOfficial, immanencer, MrMinter_eth, FilteredThought, AgienceAI, BotOrNot42, itsmetamike, sea_of_zhou, TimshelXYZ, wakesync, reality_spiral, ai16zdao, yikesawjeez
    - DeepSeek R1 integration, Fleek partnership, Lit Protocol Agent Wallet Kit, Ninja Terminal market making, GoToArena Telegram bot, X image generation, agent platform MVP, Trust Marketplace paper, Telegram mod functionality, Solenguration B2B terminal, Hyperbolic agent tracking, cybersecurity ecosystem, AI security framework, Kiyomi AI voice and music, SQL Agents library, AI agent swarms with D&D stats, agent business logic, Suno/Udio plugin, open source agent platform token, Vice agent content creation, Hyperfy tests, Quicksilver prediction framework, Eliza email scheduling, Simp2Earn tokenomics, GitHub UI relationship module, improved news aggregator, ElizaOS CICD improvements
        - https://www.youtube.com/watch?v=mxdWvBnxN8M
- Jan 31, 2025
- 12: ElizaOS 0.1.9 Launch
    - ai16zdao, shawmakesmagic, astridhpilla, lostgirldev, xrpublisher, lostboydev, spaceodili, SYMBiEX, yikesawjeez, Amiewitheliza, 0xrhota, ai16zdao, wakesync, AIFlow_ML, Signalman23, Rowdymode, MementsOfficial, elizawakesup, reality_spiral, tmoindustries, w1kke, shawmakesmagic
    - DUNA Framework for DAOs, Miku updates (MetaHuman, ETHDenver), SolEng Terminal launch, Pixel memory system with backups, SolImp Telegram mod platform, ElizaOS v0.1.9 release with plugin registry, website rework with 3D models, ecosystem updates (tokenomics, self-hosting), HyperPoly plugin and marketplace integration, Degen Spartan trading enhancements, Block Tank show format, Eliza voice device development, Backpack plugin and typing fixes, voice agent model fine-tuning, Gods Unchained tokenomics, AI database interaction library, voice demo with improved latency, Coinbase grant and trading on Base, insurance agents for nature and biodiversity, Gods Unchained plugins and Devotion program
        - https://www.youtube.com/watch?v=SZNuoXJ1Mvs
```

## Video Archive for Research

These recordings help document the week-by-week evolution of the crypto AI ecosystem, capturing the iterative development process and community formation in real-time. NotebookLM and similar research tools can extract specific technical discussions, discover new connections, and track project evolution through these as sources.

Below is a complete list of all WDYGDTW session recordings. These videos can be imported into tools like Google's [NotebookLM](https://notebooklm.google.com/) via youtube video import for deeper analysis, transcript generation, and pattern recognition across the development timeline:

[![image](/blog/notebooklm.jpg)](https://notebooklm.google.com/)

**Youtube**

1. https://www.youtube.com/watch?v=9EmvhlBPB8Q
2. https://www.youtube.com/watch?v=Lbvv0Dr91Bc
3. https://www.youtube.com/watch?v=nUAEQ7uKi04
4. https://www.youtube.com/watch?v=r3Z4lvu_ic4
5. https://www.youtube.com/watch?v=4u8rbjmvWC0
6. https://www.youtube.com/watch?v=R3auUQj9oEg
7. https://www.youtube.com/watch?v=jcSF7dSicTI
8. https://www.youtube.com/watch?v=Vs7D5DN_trk
9. https://www.youtube.com/watch?v=fqM_vYK2bmc
10. https://www.youtube.com/watch?v=1voboZEQTAw
11. https://www.youtube.com/watch?v=mxdWvBnxN8M
12. https://www.youtube.com/watch?v=SZNuoXJ1Mvs

**Notes**

1. [WDYGDTW #1](/community/streams/11-2024/2024-11-15)
2. [WDYGDTW #2](/community/streams/11-2024/2024-11-22)
3. [WDYGDTW #3](/community/streams/11-2024/2024-11-29)
4. [WDYGDTW #4](/community/streams/12-2024/2024-12-06)
5. [WDYGDTW #5](/community/streams/12-2024/2024-12-13)
6. [WDYGDTW #6](/community/streams/12-2024/2024-12-20)
7. [WDYGDTW #7](/community/streams/12-2024/2024-12-27)
8. [WDYGDTW #8](/community/streams/01-2025/2025-01-03)
9. [WDYGDTW #9](/community/streams/01-2025/2025-01-10)
10. [WDYGDTW #10](/community/streams/01-2025/2025-01-17)
11. [WDYGDTW #11](/community/streams/01-2025/2025-01-24)
12. [WDYGDTW #12](/community/streams/01-2025/2025-01-31)

If you do something cool with this data, let us know in the [discord](discord.gg/ai16z)!

After 3 straight months of nonstop building, it was time for a rest period. We may bring this format back, but we also want to continue the spirit of public accountability and transparent development through other community initiatives to keep things fresh. One such example is [Clank Tank](https://m3org.com/tv), where a standup becomes a pitch to AI judges that give you feedback about your project.
`````

## File: packages/docs/docs/core/actions.md
`````markdown
---
sidebar_position: 6
title: Actions System
description: Learn about ElizaOS actions - the core components that define agent capabilities and responses
keywords: [actions, responses, handlers, validation, examples, reply, implementation]
image: /img/actions.jpg
---

# ⚡ Actions

Actions define how agents respond to and interact with messages. They enable agents to perform tasks beyond simple message responses by integrating with external systems and modifying behavior.

## Overview

Actions are core components that define an agent's capabilities and how it can respond to conversations. Each action represents a distinct operation that an agent can perform, ranging from simple replies to complex interactions with external systems.

1. Structure:

An Action consists of:

- `name`: Unique identifier
- `similes`: Alternative names/triggers
- `description`: Purpose and usage explanation
- `validate`: Function to check if action is appropriate
- `handler`: Core implementation logic
- `examples`: Sample usage patterns
- `suppressInitialMessage`: Optional flag to suppress initial response

2. Agent Decision Flow:

When a message is received:

- The agent evaluates all available actions using their validation functions
- Valid actions are provided to the LLM via the `actionsProvider`
- The LLM decides which action(s) to execute
- Each action's handler generates a response including a "thought" component (agent's internal reasoning)
- The response is processed and sent back to the conversation

3. Integration:

Actions work in concert with:

- **Providers** - Supply context before the agent decides what action to take
- **Evaluators** - Process conversations after actions to extract insights and update memory
- **Services** - Enable actions to interact with external systems

---

## Implementation

The core Action interface includes the following components:

```typescript
interface Action {
  name: string; // Unique identifier
  similes: string[]; // Alternative names/triggers
  description: string; // Purpose and usage explanation
  validate: (runtime: IAgentRuntime, message: Memory, state?: State) => Promise<boolean>;
  handler: (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => Promise<boolean>;
  examples: ActionExample[][];
  suppressInitialMessage?: boolean; // Optional flag
}

// Handler callback for generating responses
type HandlerCallback = (content: Content) => Promise<void>;

// Response content structure
interface Content {
  text: string;
  thought?: string; // Internal reasoning (not shown to users)
  actions?: string[]; // List of action names being performed
  action?: string; // Legacy single action name
  attachments?: Attachment[]; // Optional media attachments
}
```

### Basic Action Template

Here's a simplified template for creating a custom action:

```typescript
const customAction: Action = {
  name: 'CUSTOM_ACTION',
  similes: ['ALTERNATE_NAME', 'OTHER_TRIGGER'],
  description: 'Detailed description of when and how to use this action',

  validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Logic to determine if this action applies to the current message
    // Should be efficient and quick to check
    return true; // Return true if action is valid for this message
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    options?: any,
    callback?: HandlerCallback
  ) => {
    // Implementation logic - what the action actually does

    // Generate a response with thought and text components
    const responseContent = {
      thought: 'Internal reasoning about what to do (not shown to users)',
      text: 'The actual message to send to the conversation',
      actions: ['CUSTOM_ACTION'], // List of actions being performed
    };

    // Send the response using the callback
    if (callback) {
      await callback(responseContent);
    }

    return true; // Return true if action executed successfully
  },

  examples: [
    [
      {
        name: '{{name1}}',
        content: { text: 'Trigger message' },
      },
      {
        name: '{{name2}}',
        content: {
          text: 'Response',
          thought: 'Internal reasoning',
          actions: ['CUSTOM_ACTION'],
        },
      },
    ],
  ],
};
```

### Character File Example

Actions can be referenced in character files to define how an agent should respond to specific types of messages:

```json
"messageExamples": [
    [
        {
            "user": "{{user1}}",
            "content": {
                "text": "Can you help transfer some SOL?"
            }
        },
        {
            "user": "SBF",
            "content": {
                "text": "yeah yeah for sure, sending SOL is pretty straightforward. just need the recipient and amount. everything else is basically fine, trust me.",
                "actions": ["SEND_SOL"]
            }
        }
    ]
]
```

### The Reply Action

The most fundamental action is the `REPLY` action, which allows agents to respond to messages with text. It serves as the default action when no specialized behavior is needed:

```typescript
const replyAction: Action = {
  name: 'REPLY',
  similes: ['GREET', 'REPLY_TO_MESSAGE', 'SEND_REPLY', 'RESPOND', 'RESPONSE'],
  description: 'Replies to the current conversation with the text from the generated message.',

  validate: async (_runtime: IAgentRuntime) => true, // Always valid

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    _options: any,
    callback: HandlerCallback
  ) => {
    // Compose state with necessary providers
    state = await runtime.composeState(message, [
      ...(message.content.providers ?? []),
      'RECENT_MESSAGES',
    ]);

    // Generate response using LLM
    const response = await runtime.useModel(ModelType.TEXT_SMALL, {
      prompt: composePromptFromState({
        state,
        template: replyTemplate,
      }),
    });

    // Parse and format response
    const responseContentObj = parseJSONObjectFromText(response);
    const responseContent = {
      thought: responseContentObj.thought,
      text: responseContentObj.message || '',
      actions: ['REPLY'],
    };

    // Send response via callback
    await callback(responseContent);
    return true;
  },

  examples: [
    /* Examples omitted for brevity */
  ],
};
```

---

## Actions Provider Integration

The actions provider is responsible for making valid actions available to the agent's reasoning process. When a message is received:

1. The provider validates all available actions against the current message
2. It formats the valid actions for inclusion in the agent context
3. This formatted information is used by the agent to decide which action(s) to take

```typescript
const actionsProvider: Provider = {
  name: 'ACTIONS',
  description: 'Possible response actions',
  position: -1, // High priority provider
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    // Validate all actions for this message
    const actionPromises = runtime.actions.map(async (action: Action) => {
      const result = await action.validate(runtime, message, state);
      return result ? action : null;
    });

    const resolvedActions = await Promise.all(actionPromises);
    const actionsData = resolvedActions.filter(Boolean);

    // Format action information for the agent
    const values = {
      actionNames: `Possible response actions: ${formatActionNames(actionsData)}`,
      actions: formatActions(actionsData),
      actionExamples: composeActionExamples(actionsData, 10),
    };

    // Return data, values, and text representation
    return {
      data: { actionsData },
      values,
      text: [values.actionNames, values.actionExamples, values.actions]
        .filter(Boolean)
        .join('\n\n'),
    };
  },
};
```

## Example Implementations

ElizaOS includes a wide variety of predefined actions across various plugins in the ecosystem. Here are some key categories:

### Communication Actions

- **REPLY**: Standard text response
- **CONTINUE**: Extend the conversation
- **IGNORE**: End the conversation or ignore irrelevant messages

### Blockchain and Token Actions

- **SEND_TOKEN**: Transfer cryptocurrency
- **CREATE_TOKEN**: Create a new token on a blockchain
- **READ_CONTRACT/WRITE_CONTRACT**: Interact with smart contracts

### Media and Content Generation

- **GENERATE_IMAGE**: Create images from text descriptions
- **SEND_GIF**: Share animated content
- **GENERATE_3D**: Create 3D content

### AI and Agent Management

- **LAUNCH_AGENT**: Create and start a new agent
- **START_SESSION**: Begin an interactive session
- **GENERATE_MEME**: Create humorous content

### Example Image Generation Action

Here's a more detailed example of an image generation action:

```typescript
const generateImageAction: Action = {
  name: 'GENERATE_IMAGE',
  similes: ['CREATE_IMAGE', 'MAKE_IMAGE', 'DRAW'],
  description: "Generates an image based on the user's description",
  suppressInitialMessage: true, // Don't send initial text response

  validate: async (runtime: IAgentRuntime, message: Memory) => {
    const text = message.content.text.toLowerCase();
    return (
      text.includes('generate') ||
      text.includes('create') ||
      text.includes('draw') ||
      text.includes('make an image')
    );
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state?: State,
    _options?: any,
    callback?: HandlerCallback
  ) => {
    try {
      // Get appropriate service
      const imageService = runtime.getService(ServiceType.IMAGE_GENERATION);

      // Generate the response with thought component
      const responseContent = {
        thought:
          "This request is asking for image generation. I'll use the image service to create a visual based on the user's description.",
        text: "I'm generating that image for you now...",
        actions: ['GENERATE_IMAGE'],
      };

      // Send initial response if callback provided
      if (callback) {
        await callback(responseContent);
      }

      // Generate image
      const imageUrl = await imageService.generateImage(message.content.text);

      // Create follow-up message with the generated image
      await runtime.createMemory(
        {
          id: generateId(),
          content: {
            text: "Here's the image I generated:",
            attachments: [
              {
                type: 'image',
                url: imageUrl,
              },
            ],
          },
          agentId: runtime.agentId,
          roomId: message.roomId,
        },
        'messages'
      );

      return true;
    } catch (error) {
      console.error('Image generation failed:', error);

      // Send error response if callback provided
      if (callback) {
        await callback({
          thought: 'The image generation failed due to an error.',
          text: "I'm sorry, I wasn't able to generate that image. There was a technical problem.",
          actions: ['REPLY'],
        });
      }

      return false;
    }
  },

  examples: [
    /* Examples omitted for brevity */
  ],
};
```

## Action-Evaluator-Provider Cycle

Actions are part of a larger cycle in ElizaOS agents:

1. **Providers** fetch relevant context for decision-making
2. **Actions** execute the agent's chosen response
3. **Evaluators** process the conversation to extract insights
4. These insights are stored in memory
5. Future **Providers** can access these insights
6. This informs future **Actions**

For example:

- The FACTS provider retrieves relevant facts about users
- The agent uses this context to decide on an appropriate action
- After the action, the reflection evaluator extracts new facts and relationships
- These are stored in memory and available for future interactions
- This creates a virtuous cycle of continuous learning and improvement

---

## FAQ

### What are Actions in ElizaOS?

Actions are core components that define how agents respond to messages and perform tasks. They encapsulate specific behaviors and capabilities, ranging from simple text replies to complex interactions with external systems.

### How do Actions work?

When a message is received, the agent evaluates all available actions using their validation functions. The agent then decides which action(s) to execute based on the message content and context. Each action's handler generates a response, which may include text, thought processes, and attachments.

### What's the difference between actions and evaluators?

Actions are executed during an agent's response to perform tasks and generate content. Evaluators run after responses to analyze conversations, extract information, and update the agent's memory. Actions are about doing, evaluators are about learning.

### What role do "thoughts" play in actions?

The thought component provides an internal reasoning process for the agent, explaining its decision-making. These thoughts aren't shown to users but help with debugging and understanding the agent's behavior. They're similar to the self-reflection component in evaluators.

### How do I create a custom action?

Define an action object with a name, similes, description, validation function, handler function, and examples. The validation function determines when the action should be used, while the handler contains the implementation logic and generates a response.

### Can actions be chained together?

Yes! Actions can call other actions or services as part of their implementation. This allows for complex workflows that combine multiple capabilities. For example, an action might first reply to a user, then generate an image, and finally store data in a database.

### How does an agent choose which action to use?

The agent uses the following process:

1. All actions are validated against the current message
2. Valid actions are formatted and included in the agent's context
3. The LLM decides which action(s) to execute based on the message and context
4. The chosen action's handler is executed to generate a response

### How do actions integrate with services?

Actions often use services to interact with external systems. The action handler can retrieve a service from the runtime (e.g., `imageService = runtime.getService(ServiceType.IMAGE_GENERATION)`) and then call methods on that service to perform operations.

### What's the difference between `actions` and `action` in responses?

The `actions` array is the modern way to specify multiple actions being performed in a single response. The singular `action` field is maintained for backward compatibility but is deprecated in favor of the array format.

### Can I add custom actions to an existing agent?

Yes! You can create a plugin that defines new actions and then add that plugin to your agent's configuration. This allows you to extend the agent's capabilities without modifying its core implementation.

## Further Reading

- [Evaluators](./evaluators.md)
- [Providers](./providers.md)
- [Services](./services.md)
`````

## File: packages/docs/docs/core/agents.md
`````markdown
---
sidebar_position: 1
title: Agent Runtime
description: Understanding the ElizaOS Agent Runtime - the core environment that powers AI agents
keywords: [agent runtime, orchestration, services, state, plugins, memory, models, processing]
image: /img/agentruntime.jpg
---

# 🤖 Agent Runtime

The `AgentRuntime` is the core runtime environment for Eliza agents. It handles message processing, state management, plugin integration, and interaction with external services. You can think of it as the brains that provide the high-level orchestration layer for Eliza agents.

```mermaid
sequenceDiagram
    actor User
    participant Platform as Platform
    participant Runtime as Runtime
    participant State as State
    participant P as Providers
    participant A as Actions
    participant M as Models
    participant E as Evaluators
    participant DB as Database

    User->>Platform: Message
    Platform->>Runtime: Forward

    %% Context building (condensed)
    Runtime->>State: Get context
    State->>P: Gather data
    Note over P: Character, Knowledge,<br>Messages, Time, etc.
    P-->>State: Context data
    State-->>Runtime: Assembled context

    %% Action flow (condensed)
    Runtime->>A: Execute action
    A->>M: Generate content
    M-->>A: Generated text
    A-->>Runtime: Result

    %% Evaluation (condensed)
    Runtime->>E: Analyze
    E->>DB: Store insights
    E-->>Runtime: Evaluation

    %% Delivery
    Runtime->>Platform: Response
    Platform->>User: Deliver

    %% Background (simplified)
    par Background
        Runtime->>Runtime: Tasks & Events
    end
```

The runtime follows this general flow:

1. **Initial Reception**: The user sends a message which is received by the Platform Services
2. **Context Building**:

   - The Runtime Core requests context from the State Composition system
   - State gathers data from various Providers (Character, Knowledge, Recent Messages, etc.)
   - The complete context is returned to the Runtime

3. **Action Processing**:

   - The Runtime determines applicable actions and selects the optimal one
   - The selected action may request content generation from Models
   - The action result is returned to the Runtime

4. **Learning & Persistence**:

   - The conversation is analyzed by Evaluators for insights and facts
   - Knowledge updates are sent to the Memory System
   - All relevant data is persisted to the Database

5. **Response Delivery**:
   - The final response is sent back to the user through Platform Services

---

## Overview

The [AgentRuntime](/api/classes/AgentRuntime) class is the primary implementation of the [IAgentRuntime](/api/interfaces/IAgentRuntime) interface, which manages the agent's core functions, including:

| Component             | Description                                                                                                                                                                             | API Reference                                                    | Related Files                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Services**          | Supports multiple communication platforms and specialized functionalities for seamless interaction.                                                                                     | [Services API](/api/interfaces/IAgentRuntime/#services)          | [`service.ts`](https://github.com/elizaOS/eliza/tree/develop/packages/core/src/service.ts), [`Discord`](https://github.com/elizaos-plugins/plugin-discord), [`Telegram`](https://github.com/elizaos-plugins/plugin-telegram), [`Twitter`](https://github.com/elizaos-plugins/plugin-twitter), [`Farcaster`](https://github.com/elizaos-plugins/plugin-farcaster), [`Lens`](https://github.com/elizaos-plugins/plugin-lens), [`Slack`](https://github.com/elizaos-plugins/plugin-slack), [`Auto`](https://github.com/elizaos-plugins/plugin-auto), [`GitHub`](https://github.com/elizaos-plugins/plugin-github) |
| **State**             | Maintains context for coherent cross-platform interactions, updates dynamically. Also tracks goals, knowledge, and recent interactions                                                  | [State API](/api/interfaces/State)                               | [`state.ts`](https://github.com/elizaos/runtime/state.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Plugins**           | Dynamic extensions of agent functionalities using custom actions, evaluators, providers, and adapters                                                                                   | [Plugins API](/api/type-aliases/Plugin/)                         | [`plugins.ts`](https://github.com/elizaos/runtime/plugins.ts), [actions](../actions), [evaluators](../evaluators), [providers](../providers)                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **Services**          | Connects with external services for `IMAGE_DESCRIPTION`, `TRANSCRIPTION`, `TEXT_GENERATION`, `SPEECH_GENERATION`, `VIDEO`, `PDF`, `BROWSER`, `WEB_SEARCH`, `EMAIL_AUTOMATION`, and more | [Services API](/api/interfaces/IAgentRuntime/#services)          | [`services.ts`](https://github.com/elizaos/runtime/services.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **Memory Systems**    | Creates, retrieves, and embeds memories and manages conversation history.                                                                                                               | [Memory API](/api/interfaces/IMemoryManager)                     | [`memory.ts`](https://github.com/elizaos/runtime/memory.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **Database Adapters** | Persistent storage and retrieval for memories and knowledge                                                                                                                             | [databaseAdapter](api/interfaces/IAgentRuntime/#databaseAdapter) | [`MongoDB`](https://github.com/elizaos-plugins/adapter-mongodb), [`PostgreSQL`](https://github.com/elizaos-plugins/adapter-postgres), [`SQLite`](https://github.com/elizaos-plugins/adapter-sqlite), [`Supabase`](https://github.com/elizaos-plugins/adapter-supabase), [`PGLite`](https://github.com/elizaos-plugins/adapter-pglite), [`Qdrant`](https://github.com/elizaos-plugins/adapter-qdrant), [`SQL.js`](https://github.com/elizaos-plugins/adapter-sqljs)                                                                                                                                             |
| **Cache Management**  | Provides flexible storage and retrieval via various caching methods.                                                                                                                    | [Cache API](/api/interfaces/ICacheManager)                       | [`cache.ts`](https://github.com/elizaos/runtime/cache.ts)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

<details>
<summary>Advanced: IAgentRuntime Interface</summary>
```typescript
interface IAgentRuntime {
    // Core identification
    agentId: UUID;
    
    // Configuration
    character: Character;                          // Personality and behavior settings
    
    // Components
    plugins: Plugin[];                             // Additional capabilities
    services: Map<ServiceTypeName, Service>;       // Platform connections and functionality
    providers: Provider[];                         // Real-time data sources
    actions: Action[];                             // Available behaviors
    evaluators: Evaluator[];                       // Analysis & learning
    routes: Route[];                               // API endpoints
    
    // Memory Management
    getMemories(...): Promise<Memory[]>;           // Retrieve conversation history
    createMemory(...): Promise<UUID>;              // Store new memories
    searchMemories(...): Promise<Memory[]>;        // Semantic search
    
    // State Composition
    composeState(...): Promise<State>;             // Gather data from providers
    
    // Plugin Management
    registerPlugin(...): Promise<void>;            // Register plugins
    
    // Service Management
    getService<T>(...): T | null;                  // Access services
    registerService(...): Promise<void>;           // Register services
    
    // Model Integration
    useModel<T, R>(...): Promise<R>;               // Use AI models
    
    // Additional Utilities
    getSetting(...): any;                          // Access settings
    setSetting(...): void;                         // Configure settings
    getCache<T>(...): Promise<T | undefined>;      // Access cached data
    setCache<T>(...): Promise<boolean>;            // Store cached data
}
```

Source: [/api/interfaces/IAgentRuntime/](/api/interfaces/IAgentRuntime/)

</details>

---

### **Key Methods**

- **`initialize()`**: Sets up the agent's runtime environment, including services, plugins, and knowledge processing.
- **`processActions()`**: Executes actions based on message content and state.
- **`evaluate()`**: Assesses messages and state using registered evaluators.
- **`composeState()`**: Constructs the agent's state object for response generation.
- **`registerService()`**: Adds a service to the runtime.
- **`getService()`**: Retrieves a registered service by type.
- **`useModel()`**: Utilizes AI models with typesafe parameters and results.
- **`ensureRoomExists()` / `ensureConnection()`**: Ensures the existence of communication channels and connections.

## Service System

Services provide specialized functionality with standardized interfaces that can be accessed cross-platform:

```typescript
// Speech Generation
const speechService = runtime.getService<ISpeechService>('speech_generation');
const audioStream = await speechService.process(text);

// PDF Processing
const pdfService = runtime.getService<IPdfService>('pdf');
const textContent = await pdfService.convertPdfToText(pdfBuffer);

// Discord Integration
const discordService = runtime.getService<IDiscordService>('discord');
await discordService.sendMessage(channelId, content);
```

---

## State Management

The runtime maintains comprehensive state through the State interface:

```typescript
interface State {
  // Core state data
  values: {
    [key: string]: any;
  };
  data: {
    [key: string]: any;
  };
  text: string;
}

// State composition example
async function manageState() {
  // Initial state composition with all regular providers
  const state = await runtime.composeState(message);

  // State with specific providers only
  const filteredState = await runtime.composeState(message, ['timeProvider', 'recentMessages']);

  // Include private or dynamic providers
  const enhancedState = await runtime.composeState(message, null, [
    'weatherProvider',
    'portfolioProvider',
  ]);
}
```

---

## Plugin System

Plugins extend agent functionality through a modular interface. The runtime supports various types of plugins including services, adapters, actions, and more:

```typescript
interface Plugin {
  name: string;
  description: string;
  init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;

  // Components
  services?: (typeof Service)[]; // Communication platforms and external integrations
  actions?: Action[]; // Custom behaviors
  providers?: Provider[]; // Data providers
  evaluators?: Evaluator[]; // Response assessment
  adapters?: Adapter[]; // Database/cache adapters
  routes?: Route[]; // API endpoints
  tests?: TestSuite[]; // Testing utilities
}
```

Plugins can be configured through [characterfile](./characterfile) settings:

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-solana", "@elizaos/plugin-twitter"],
  "settings": {
    "twitter": {
      "shouldRespondToMentions": true
    },
    "solana": {
      "enableAutoTrading": false
    }
  }
}
```

For detailed information about plugin development and usage, see the [ElizaOS Registry](https://github.com/elizaos-plugins/registry).

---

## Running Multiple Agents

To run multiple agents:

```bash
bun start --characters="characters/agent1.json,characters/agent2.json"
```

Or use environment variables:

```
REMOTE_CHARACTER_URLS=https://example.com/characters.json
```

---

## FAQ

### What's the difference between an agent and a character?

A character defines personality and knowledge, while an agent provides the runtime environment and capabilities to bring that character to life.

### How do I choose the right database adapter?

Choose based on your needs:

- MongoDB: For scalable, document-based storage
- PostgreSQL: For relational data with complex queries
- SQLite: For simple, file-based storage
- Qdrant: For vector search capabilities

### How do I implement custom plugins?

Create a plugin that follows the plugin interface and register it with the runtime. See the plugin documentation for detailed examples.

### Do agents share memory across platforms?

By default, agents maintain separate memory contexts for different platforms to avoid mixing conversations. Use the memory management system and database adapters to persist and retrieve state information.

### How do I handle multiple authentication methods?

Use the character configuration to specify different authentication methods for different services. The runtime will handle the appropriate authentication flow.

### How do I manage environment variables?

Use a combination of:

- `.env` files for local development
- Character-specific settings for per-agent configuration
- Environment variables for production deployment

### Can agents communicate with each other?

Yes, through the message system and shared memory spaces when configured appropriately.
`````

## File: packages/docs/docs/core/database.md
`````markdown
---
sidebar_position: 7
title: Database System
description: Understanding ElizaOS database system - persistent storage and data management for agents
keywords: [database, storage, adapters, PostgreSQL, PGLite, entities, memories, relationships]
image: /img/database.jpg
---

# 💾 Database System

The ElizaOS database system provides persistent storage capabilities for agents. It handles memory storage, entity relationships, knowledge management, and more through a flexible adapter-based architecture.

## Overview

```mermaid
graph TB
    %% Main Components
    Runtime([Agent Runtime])
    DbAdapter([Database Adapter])
    DbConnection[("Database (PGLite/PostgreSQL)")]

    %% Data Models in compact form
    DataModels["Data Models: Entities, Components, Memories, Relationships, Rooms, Worlds, Tasks Cache"]

    %% Vector Search
    VectorStore[(Vector Store)]

    %% Memories Knowledge
    MemoriesKnowledge[(Memories / Knowledge)]

    %% Connection flow
    Runtime -->|Uses| DbAdapter
    DbAdapter -->|Connects to| DbConnection
    DbConnection -->|Stores & Retrieves| DataModels

    %% Connect Vector Store
    DbConnection -->|Utilizes| VectorStore
    VectorStore -->|Enables Search on| MemoriesKnowledge

    %% Styling
    classDef default fill:#f0f4f8,stroke:#2c3e50,stroke-width:1px;
    classDef runtime fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef adapter fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef datamodels fill:#52be80,stroke:#2c3e50,stroke-width:1px,color:#fff;
    classDef memories fill:#2c5e1a,stroke:#2c3333,stroke-width:1px,color:#fff;

    class Runtime runtime;
    class DbAdapter adapter;
    class DbConnection,VectorStore db;
    class DataModels datamodels;
    class MemoriesKnowledge memories;
```

ElizaOS uses a unified database architecture based on Drizzle ORM with adapters that implement the [`IDatabaseAdapter`](/api/interfaces/IDatabaseAdapter) interface. The current release includes support for:

| Adapter        | Best For                    | Key Features                                                      |
| -------------- | --------------------------- | ----------------------------------------------------------------- |
| **PGLite**     | Local development & testing | Lightweight PostgreSQL implementation running in Node.js process  |
| **PostgreSQL** | Production deployments      | Full PostgreSQL with vector search, scaling, and high reliability |

Additional database adapters will be supported in future releases as ElizaOS continues to evolve.

## Core Functionality

All database adapters extend the `BaseDrizzleAdapter` abstract class, which provides a comprehensive set of methods for managing all aspects of agent data:

### Entity System

| Method                 | Description                           |
| ---------------------- | ------------------------------------- |
| `createEntity()`       | Create a new entity                   |
| `getEntityById()`      | Retrieve an entity by ID              |
| `getEntitiesForRoom()` | Get all entities in a room            |
| `updateEntity()`       | Update entity attributes              |
| `getComponent()`       | Get a specific component of an entity |
| `getComponents()`      | Get all components for an entity      |
| `createComponent()`    | Add a component to an entity          |
| `updateComponent()`    | Update a component                    |
| `deleteComponent()`    | Remove a component                    |

### Memory Management

| Method                        | Description                          |
| ----------------------------- | ------------------------------------ |
| `createMemory()`              | Store a new memory with metadata     |
| `getMemoryById()`             | Retrieve a specific memory           |
| `getMemories()`               | Get memories matching criteria       |
| `getMemoriesByIds()`          | Get multiple memories by IDs         |
| `getMemoriesByRoomIds()`      | Get memories from multiple rooms     |
| `searchMemories()`            | Search memories by vector similarity |
| `searchMemoriesByEmbedding()` | Search using raw embedding vector    |
| `deleteMemory()`              | Remove a specific memory             |
| `deleteAllMemories()`         | Remove all memories in a room        |
| `countMemories()`             | Count memories matching criteria     |

### Room & Participant Management

| Method                       | Description                     |
| ---------------------------- | ------------------------------- |
| `createRoom()`               | Create a new conversation room  |
| `getRoom()`                  | Get room by ID                  |
| `getRooms()`                 | Get all rooms in a world        |
| `updateRoom()`               | Update room attributes          |
| `deleteRoom()`               | Remove a room                   |
| `addParticipant()`           | Add entity to room              |
| `removeParticipant()`        | Remove entity from room         |
| `getParticipantsForEntity()` | Get all rooms an entity is in   |
| `getParticipantsForRoom()`   | List entities in a room         |
| `getParticipantUserState()`  | Get entity's state in a room    |
| `setParticipantUserState()`  | Update entity's state in a room |

### Relationship Management

| Method                 | Description                            |
| ---------------------- | -------------------------------------- |
| `createRelationship()` | Create a relationship between entities |
| `updateRelationship()` | Update relationship attributes         |
| `getRelationship()`    | Get a specific relationship            |
| `getRelationships()`   | Get all relationships for an entity    |

### Caching System

| Method          | Description            |
| --------------- | ---------------------- |
| `getCache()`    | Retrieve cached data   |
| `setCache()`    | Store data in cache    |
| `deleteCache()` | Remove data from cache |

### World & Task Management

| Method             | Description                 |
| ------------------ | --------------------------- |
| `createWorld()`    | Create a new world          |
| `getWorld()`       | Get world by ID             |
| `getAllWorlds()`   | List all worlds             |
| `updateWorld()`    | Update world attributes     |
| `removeWorld()`    | Delete a world              |
| `createTask()`     | Create a new task           |
| `getTasks()`       | Get tasks matching criteria |
| `getTasksByName()` | Find tasks by name          |
| `getTask()`        | Get task by ID              |
| `updateTask()`     | Update task attributes      |
| `deleteTask()`     | Remove a task               |

### Agent Management

| Method          | Description               |
| --------------- | ------------------------- |
| `createAgent()` | Create a new agent record |
| `getAgent()`    | Get agent by ID           |
| `getAgents()`   | List all agents           |
| `updateAgent()` | Update agent attributes   |
| `deleteAgent()` | Remove an agent           |
| `countAgents()` | Count total agents        |

### Embedding & Search

| Method                        | Description                    |
| ----------------------------- | ------------------------------ |
| `ensureEmbeddingDimension()`  | Configure embedding dimensions |
| `getCachedEmbeddings()`       | Retrieve cached embeddings     |
| `searchMemories()`            | Vector search for memories     |
| `searchMemoriesByEmbedding()` | Advanced vector search         |

## Architecture

ElizaOS uses a singleton pattern for database connections to ensure efficient resource usage:

```
┌─────────────────────────────────────┐
│           AgentRuntime              │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│        IDatabaseAdapter             │
└───────────────┬─────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│       BaseDrizzleAdapter            │
└───────────────┬─────────────────────┘
                │
        ┌───────┴───────┐
        ▼               ▼
┌───────────────┐ ┌─────────────────┐
│ PGLiteAdapter │ │ PostgresAdapter │
└───────┬───────┘ └────────┬────────┘
        │                  │
        ▼                  ▼
┌───────────────┐ ┌─────────────────┐
│PGLiteManager  │ │PostgresManager  │
│  (Singleton)  │ │  (Singleton)    │
└───────────────┘ └─────────────────┘
```

Each adapter is associated with a singleton connection manager that ensures only one database connection is maintained per process, regardless of how many agents are running.

## Implementation

### Initialization

The database adapter is initialized through the SQL plugin:

```typescript
// Plugin registration in project configuration
const project = {
  plugins: ['@elizaos/plugin-sql'],
  // ...
};
```

The SQL plugin automatically selects and initializes the appropriate database adapter based on environment settings:

```typescript
function createDatabaseAdapter(
  config: {
    dataDir?: string;
    postgresUrl?: string;
  },
  agentId: UUID
): IDatabaseAdapter {
  if (config.postgresUrl) {
    return new PgDatabaseAdapter(agentId, postgresConnectionManager);
  }

  // Default to PGLite
  return new PgliteDatabaseAdapter(agentId, pgLiteClientManager);
}
```

### Configuration

Configure the database adapter using environment variables or settings:

```typescript
// For PostgreSQL
process.env.POSTGRES_URL = 'postgresql://username:password@localhost:5432/elizaos';

// For PGLite (default)
process.env.PGLITE_DATA_DIR = './elizadb'; // Optional, defaults to './pglite'
```

### Retry Logic & Error Handling

The database system includes built-in retry logic with exponential backoff and jitter:

```typescript
protected async withRetry<T>(operation: () => Promise<T>): Promise<T> {
  let attempt = 0;
  let lastError: Error | null = null;

  while (attempt < this.maxRetries) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      const isRetryable = this.isRetryableError(error);

      if (!isRetryable) {
        break;
      }

      // Calculate delay with exponential backoff and jitter
      const delay = Math.min(
        this.baseDelay * Math.pow(2, attempt) + Math.random() * this.jitterMax,
        this.maxDelay
      );

      await new Promise(resolve => setTimeout(resolve, delay));
      attempt++;
    }
  }

  throw lastError;
}
```

## Example Usage

Here are examples of common database operations:

### Store a Memory

```typescript
await runtime.createMemory(
  {
    entityId: message.entityId,
    agentId: runtime.agentId,
    content: { text: 'Important information to remember' },
    roomId: message.roomId,
    embedding: await runtime.useModel(ModelType.TEXT_EMBEDDING, {
      text: 'Important information to remember',
    }),
  },
  'facts'
);
```

### Search for Memories

```typescript
const embedding = await runtime.useModel(ModelType.TEXT_EMBEDDING, {
  text: 'What did we discuss about databases?',
});

const relevantMemories = await runtime.searchMemories({
  tableName: 'messages',
  embedding,
  roomId: message.roomId,
  count: 5,
});
```

### Manage Entity Relationships

```typescript
// Create a relationship between entities
await runtime.createRelationship({
  sourceEntityId: userEntityId,
  targetEntityId: agentEntityId,
  tags: ['friend', 'frequent_interaction'],
  metadata: {
    interactions: 42,
    trust_level: 'high',
  },
});

// Retrieve relationships
const relationships = await runtime.getRelationships({
  entityId: userEntityId,
  tags: ['friend'],
});
```

## Database Schema

The schema is managed by Drizzle ORM and includes the following key tables:

### Core Tables

- **entities**: The fundamental objects in the system (users, agents, etc.)
- **components**: Modular data attached to entities (profiles, settings, etc.)
- **memories**: Conversation history and other remembered information
- **relationships**: Connections between entities
- **rooms**: Conversation channels
- **participants**: Entity participation in rooms
- **worlds**: Container for multiple rooms
- **tasks**: Scheduled or queued operations
- **cache**: Temporary key-value storage
- **agents**: Agent configuration and state

### Entity-Component System

ElizaOS uses an entity-component architecture where:

- Entities are the base objects (users, agents, etc.)
- Components are pieces of data attached to entities
- This allows for flexible data modeling and extension

For example, a user entity might have profile, preferences, and authentication components.

## Vector Search

Both adapters support vector-based semantic search with some differences:

- **PostgreSQL**: Uses pgvector extension for optimized vector operations
- **PGLite**: Implements vector search in JavaScript with an efficient algorithm

The embedding dimension is configurable based on the model used:

```typescript
await adapter.ensureEmbeddingDimension(1536); // For OpenAI embeddings
```

## FAQ

### How do I choose between PGLite and PostgreSQL?

- Use **PGLite** for:

  - Local development and testing
  - Single-user deployments
  - Situations where installing PostgreSQL is impractical

- Use **PostgreSQL** for:
  - Production deployments
  - Multi-user systems
  - High-volume data
  - When you need advanced scaling features

### How do I configure the database connection?

For PostgreSQL, set the `POSTGRES_URL` environment variable:

```
POSTGRES_URL=postgresql://username:password@localhost:5432/elizaos
```

For PGLite, set the data directory (optional):

```
PGLITE_DATA_DIR=./my-data
```

### How can I inspect the database contents?

For PostgreSQL, use standard PostgreSQL tools like pgAdmin or psql.

For PGLite, the data is stored in the specified data directory as files. You can use tools like DB Browser for SQLite to inspect the SQLite files that PGLite generates.

### How do I migrate between different database adapters?

Currently, there's no built-in migration tool between adapters. For production systems, it's recommended to start with PostgreSQL if you anticipate needing its features.

### What about vector embedding dimension mismatches?

The system automatically handles embedding dimensions based on the model used. If you change embedding models, make sure to:

1. Set the correct dimension with `ensureEmbeddingDimension()`
2. Be aware that mixing different dimensions in the same database can cause issues

### How does the entity-component system work?

The entity-component system (ECS) provides a flexible way to model data:

- **Entities** are base objects with unique IDs
- **Components** are pieces of data attached to entities
- This allows for dynamic composition of objects without complex inheritance

For example, a user entity might have profile, preferences, and authentication components.

### How can I improve database performance?

- For **PostgreSQL**:

  - Ensure the pgvector extension is properly installed
  - Index frequently queried fields
  - Use connection pooling
  - Consider partitioning for large datasets

- For **PGLite**:
  - Keep database size reasonable (under 1GB)
  - Regularly clean up old memories
  - Limit the number of concurrent operations

### Will other database adapters be supported in the future?

Yes, future releases will add support for additional databases such as:

- MongoDB
- SQLite
- Supabase
- Qdrant
- SQL.js

The adapter interface is designed to be extensible to support a wide range of storage solutions.

## Further Reading

- [Entity System](./entities.md)
- [Agent Runtime](./agents.md)
`````

## File: packages/docs/docs/core/entities.md
`````markdown
---
sidebar_position: 9
title: Entities System
description: Understanding ElizaOS entities - users, agents, and participants in the entity-component architecture
keywords: [entities, components, users, agents, participants, relationships, data modeling]
image: /img/entities-component-architecture.svg
---

# Entities

Entities in ElizaOS represent users, agents, or any participant that can interact within the system. They form the basis of the entity-component architecture, allowing for flexible data modeling and relationships across the platform.

![](/img/entities-component-architecture.svg)

## Entity Structure

An entity in ElizaOS has the following properties:

```typescript
interface Entity {
  /** Unique identifier, optional on creation */
  id?: UUID;

  /** Names of the entity */
  names: string[];

  /** Optional additional metadata */
  metadata?: { [key: string]: any };

  /** Agent ID this account is related to, for agents should be themselves */
  agentId: UUID;

  /** Optional array of components */
  components?: Component[];
}
```

| Property     | Description                                              |
| ------------ | -------------------------------------------------------- |
| `id`         | Unique identifier for the entity (optional on creation)  |
| `names`      | Array of names the entity is known by                    |
| `metadata`   | Additional information about the entity                  |
| `agentId`    | ID of the agent related to this entity                   |
| `components` | Array of modular data components attached to this entity |

## Components

Components are modular pieces of data attached to entities with the following structure:

```typescript
interface Component {
  id: UUID;
  entityId: UUID;
  agentId: UUID;
  roomId: UUID;
  worldId: UUID;
  sourceEntityId: UUID;
  type: string;
  data: {
    [key: string]: any;
  };
}
```

| Property         | Description                                       |
| ---------------- | ------------------------------------------------- |
| `id`             | Unique identifier for the component               |
| `entityId`       | ID of the entity this component belongs to        |
| `agentId`        | ID of the agent managing this component           |
| `roomId`         | ID of the room this component is associated with  |
| `worldId`        | ID of the world this component is associated with |
| `sourceEntityId` | ID of the entity that created this component      |
| `type`           | Type of component (e.g., "profile", "settings")   |
| `data`           | Additional data specific to this component type   |

## Entity Creation and Management

### Creating an Entity

```typescript
const entityId = await runtime.createEntity({
  names: ['John Doe', 'JohnD'],
  agentId: runtime.agentId,
  metadata: {
    discord: {
      username: 'john_doe',
      name: 'John Doe',
    },
  },
});
```

### Retrieving an Entity

```typescript
// Get an entity by ID
const entity = await runtime.getEntityById(entityId);

// Get all entities in a room
const entitiesInRoom = await runtime.getEntitiesForRoom(roomId, true); // true to include components
```

### Updating an Entity

```typescript
await runtime.updateEntity({
  id: entityId,
  names: [...entity.names, 'Johnny'],
  metadata: {
    ...entity.metadata,
    customProperty: 'value',
  },
});
```

## Component Management

Components allow for flexible data modeling by attaching different types of data to entities.

### Creating a Component

```typescript
await runtime.createComponent({
  id: componentId,
  entityId: entityId,
  agentId: runtime.agentId,
  roomId: roomId,
  worldId: worldId,
  sourceEntityId: creatorEntityId,
  type: 'profile',
  data: {
    bio: 'Software developer interested in AI',
    location: 'San Francisco',
    website: 'https://example.com',
  },
});
```

### Retrieving Components

```typescript
// Get a specific component type
const profileComponent = await runtime.getComponent(
  entityId,
  'profile',
  worldId, // optional filter by world
  sourceEntityId // optional filter by source
);

// Get all components for an entity
const allComponents = await runtime.getComponents(entityId, worldId, sourceEntityId);
```

### Updating Components

```typescript
await runtime.updateComponent({
  id: profileComponent.id,
  data: {
    ...profileComponent.data,
    bio: 'Updated bio information',
  },
});
```

### Deleting Components

```typescript
await runtime.deleteComponent(componentId);
```

## Entity Relationships

Entities can have relationships with other entities, stored in the database:

```typescript
// Create a relationship between entities
await runtime.createRelationship({
  sourceEntityId: entityId1,
  targetEntityId: entityId2,
  tags: ['friend', 'collaborator'],
  metadata: {
    interactions: 5,
    lastInteraction: Date.now(),
  },
});

// Get relationships for an entity
const relationships = await runtime.getRelationships({
  entityId: entityId1,
  tags: ['friend'], // optional filter by tags
});

// Get a specific relationship
const relationship = await runtime.getRelationship({
  sourceEntityId: entityId1,
  targetEntityId: entityId2,
});

// Update a relationship
await runtime.updateRelationship({
  ...relationship,
  metadata: {
    ...relationship.metadata,
    interactions: relationship.metadata.interactions + 1,
    lastInteraction: Date.now(),
  },
});
```

## Entity Resolution

ElizaOS includes a system for resolving entity references from messages and context. This is particularly useful for determining which entity is being referenced in a conversation.

```typescript
// Find an entity by name or reference
const entity = await findEntityByName(runtime, message, state);
```

The entity resolution system considers:

1. Exact matches by ID or username
2. Contextual matches from recent conversations
3. Relationship strength between entities
4. Role-based permissions in worlds

## Entity Details

To get formatted information about entities in a room:

```typescript
// Get detailed information about entities in a room
const entityDetails = await getEntityDetails({
  runtime,
  roomId,
});

// Format entities into a string representation
const formattedEntities = formatEntities({ entities: entitiesInRoom });
```

## Relationship with Rooms and Worlds

Entities participate in rooms and, by extension, in worlds:

```typescript
// Add an entity as a participant in a room
await runtime.addParticipant(entityId, roomId);

// Get all rooms where an entity is a participant
const entityRooms = await runtime.getRoomsForParticipant(entityId);

// Get all participants in a room
const participants = await runtime.getParticipantsForRoom(roomId);
```

When an entity is a participant in a room that belongs to a world, the entity has an implicit relationship with that world.

## Creating Unique Entity IDs

For situations where you need to create deterministic, unique IDs for entity-agent pairs:

```typescript
const uniqueId = createUniqueUuid(runtime, baseUserId);
```

This ensures that each user-agent interaction has a consistent, unique identifier.

## Best Practices

1. **Use meaningful names**: Provide descriptive names in the `names` array to make entity identification easier
2. **Structure metadata carefully**: Organize metadata by source (e.g., `discord`, `telegram`) for clarity
3. **Component segregation**: Use components to separate different aspects of entity data rather than storing everything in metadata
4. **Permission checking**: Always verify permissions before accessing components created by other entities
5. **Relationship maintenance**: Update relationship metadata regularly to reflect recent interactions
6. **Entity resolution**: Use the entity resolution system to correctly identify entities in conversations
7. **Deterministic IDs**: Use `createUniqueUuid` for consistent entity identification across sessions
`````

## File: packages/docs/docs/core/evaluators.md
`````markdown
---
sidebar_position: 7
title: Evaluators System
description: Understanding ElizaOS evaluators - cognitive components that enable agents to learn and evolve
keywords: [evaluators, cognition, learning, memory, facts, reflection, analysis]
image: /img/evaluators.jpg
---

# 🧠 Evaluators

Evaluators are cognitive components in the ElizaOS framework that enable agents to process conversations, extract knowledge, and build understanding - similar to how humans form memories after interactions. They provide a structured way for agents to introspect, learn from interactions, and evolve over time.

## Understanding Evaluators

Evaluators are specialized functions that work with the [`AgentRuntime`](/api/classes/AgentRuntime) to analyze conversations after a response has been generated. Unlike actions that create responses, evaluators perform background cognitive tasks that enable numerous advanced capabilities:

- **Knowledge Building**: Automatically extract and store facts from conversations
- **Relationship Tracking**: Identify connections between entities
- **Conversation Quality**: Perform self-reflection on interaction quality
- **Goal Tracking**: Determine if conversation objectives are being met
- **Tone Analysis**: Evaluate emotional content and adjust future responses
- **User Profiling**: Build understanding of user preferences and needs over time
- **Performance Metrics**: Gather data on agent effectiveness and learn from interactions

### Core Structure

```typescript
interface Evaluator {
  name: string; // Unique identifier
  similes?: string[]; // Alternative names/triggers
  description: string; // Purpose explanation
  examples: EvaluationExample[]; // Sample usage patterns
  handler: Handler; // Implementation logic
  validate: Validator; // Execution criteria check
  alwaysRun?: boolean; // Run regardless of validation
}
```

### Evaluator Execution Flow

The agent runtime executes evaluators as part of its cognitive cycle:

1. Agent processes a message and generates a response
2. Runtime calls `evaluate()` after response generation
3. Each evaluator's `validate()` method determines if it should run
4. For each valid evaluator, the `handler()` function is executed
5. Results are stored in memory and inform future responses

---

## Fact Evaluator: Memory Formation System

The Fact Evaluator serves as the agent's "episodic memory formation" system - similar to how humans process conversations and form memories. Just as you might reflect after a conversation "Oh, I learned something new about Sarah today", the Fact Evaluator systematically processes conversations to build up the agent's understanding of the world and the people in it.

### How It Works

#### 1. Triggering (The "When to Reflect" System)

```typescript
validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
  const messageCount = await runtime.messageManager.countMemories(message.roomId);
  const reflectionCount = Math.ceil(runtime.getConversationLength() / 2);
  return messageCount % reflectionCount === 0;
};
```

Just like humans don't consciously analyze every single word in real-time, the Fact Evaluator runs periodically rather than after every message. It triggers a "reflection" phase every few messages to process what's been learned.

#### 2. Fact Extraction (The "What Did I Learn?" System)

The evaluator uses a template-based approach to extract three types of information:

- **Facts**: Unchanging truths about the world or people
  - "Bob lives in New York"
  - "Sarah has a degree in Computer Science"
- **Status**: Temporary or changeable states
  - "Bob is currently working on a new project"
  - "Sarah is visiting Paris this week"
- **Opinions**: Subjective views, feelings, or non-factual statements
  - "Bob thinks the project will be successful"
  - "Sarah loves French cuisine"

#### 3. Memory Deduplication (The "Is This New?" System)

```typescript
const filteredFacts = facts.filter((fact) => {
  return (
    !fact.already_known &&
    fact.type === 'fact' &&
    !fact.in_bio &&
    fact.claim &&
    fact.claim.trim() !== ''
  );
});
```

Just as humans don't need to consciously re-learn things they already know, the Fact Evaluator:

- Checks if information is already known
- Verifies if it's in the agent's existing knowledge (bio)
- Filters out duplicate or corrupted facts

#### 4. Memory Storage (The "Remember This" System)

```typescript
const factMemory = await factsManager.addEmbeddingToMemory({
  userId: agentId!,
  agentId,
  content: { text: fact },
  roomId,
  createdAt: Date.now(),
});
```

Facts are stored with embeddings to enable:

- Semantic search of related facts
- Context-aware recall
- Temporal tracking (when the fact was learned)

### Example Processing

Given this conversation:

```
User: "I just moved to Seattle last month!"
Agent: "How are you finding the weather there?"
User: "It's rainy, but I love my new job at the tech startup"
```

The Fact Evaluator might extract:

```json
[
  {
    "claim": "User moved to Seattle last month",
    "type": "fact",
    "in_bio": false,
    "already_known": false
  },
  {
    "claim": "User works at a tech startup",
    "type": "fact",
    "in_bio": false,
    "already_known": false
  },
  {
    "claim": "User enjoys their new job",
    "type": "opinion",
    "in_bio": false,
    "already_known": false
  }
]
```

### Key Design Considerations

1. **Episodic vs Semantic Memory**

   - Facts build up the agent's semantic memory (general knowledge)
   - The raw conversation remains in episodic memory (specific experiences)

2. **Temporal Awareness**

   - Facts are timestamped to track when they were learned
   - Status facts can be updated as they change

3. **Confidence and Verification**

   - Multiple mentions of a fact increase confidence
   - Contradictory facts can be flagged for verification

4. **Privacy and Relevance**
   - Only stores relevant, conversation-appropriate facts
   - Respects explicit and implicit privacy boundaries

---

## Reflection Evaluator: Self-Awareness System

The reflection evaluator extends beyond fact extraction to enable agents to develop a form of "self-awareness" about their conversational performance. It allows agents to:

1. Generate self-reflective thoughts about the conversation quality
2. Extract factual information from conversations (similar to the Fact Evaluator)
3. Identify and track relationships between entities

### How Reflections Work

When triggered, the reflection evaluator:

1. Analyzes recent conversations and existing knowledge
2. Generates structured reflection output with:
   - Self-reflective thoughts about conversation quality
   - New facts extracted from conversation
   - Identified relationships between entities
3. Stores this information in the agent's memory for future reference

### Example Reflection Output

```json
{
  "thought": "I'm engaging appropriately with John, maintaining a welcoming and professional tone. My questions are helping learn more about him as a new community member.",
  "facts": [
    {
      "claim": "John is new to the community",
      "type": "fact",
      "in_bio": false,
      "already_known": false
    },
    {
      "claim": "John found the community through a friend interested in AI",
      "type": "fact",
      "in_bio": false,
      "already_known": false
    }
  ],
  "relationships": [
    {
      "sourceEntityId": "sarah-agent",
      "targetEntityId": "user-123",
      "tags": ["group_interaction"]
    },
    {
      "sourceEntityId": "user-123",
      "targetEntityId": "sarah-agent",
      "tags": ["group_interaction"]
    }
  ]
}
```

### Implementation Details

The reflection evaluator uses a defined schema to ensure consistent output:

```typescript
const reflectionSchema = z.object({
  facts: z.array(
    z.object({
      claim: z.string(),
      type: z.string(),
      in_bio: z.boolean(),
      already_known: z.boolean(),
    })
  ),
  relationships: z.array(relationshipSchema),
});

const relationshipSchema = z.object({
  sourceEntityId: z.string(),
  targetEntityId: z.string(),
  tags: z.array(z.string()),
  metadata: z
    .object({
      interactions: z.number(),
    })
    .optional(),
});
```

### Validation Logic

The reflection evaluator includes validation logic that determines when reflection should occur:

```typescript
validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
  const lastMessageId = await runtime.getCache<string>(
    `${message.roomId}-reflection-last-processed`
  );
  const messages = await runtime.getMemories({
    tableName: 'messages',
    roomId: message.roomId,
    count: runtime.getConversationLength(),
  });

  if (lastMessageId) {
    const lastMessageIndex = messages.findIndex((msg) => msg.id === lastMessageId);
    if (lastMessageIndex !== -1) {
      messages.splice(0, lastMessageIndex + 1);
    }
  }

  const reflectionInterval = Math.ceil(runtime.getConversationLength() / 4);

  return messages.length > reflectionInterval;
};
```

This ensures reflections occur at appropriate intervals, typically after a set number of messages have been exchanged.

## Common Memory Formation Patterns

1. **Progressive Learning**

   ```typescript
   // First conversation
   "I live in Seattle" -> Stores as fact

   // Later conversation
   "I live in the Ballard neighborhood" -> Updates/enhances existing fact
   ```

2. **Fact Chaining**

   ```typescript
   // Original facts
   'Works at tech startup';
   'Startup is in Seattle';

   // Inference potential
   'Works in Seattle tech industry';
   ```

3. **Temporal Tracking**

   ```typescript
   // Status tracking
   t0: 'Looking for a job'(status);
   t1: 'Got a new job'(fact);
   t2: 'Been at job for 3 months'(status);
   ```

4. **Relationship Building**

   ```typescript
   // Initial relationship
   {
     "sourceEntityId": "user-123",
     "targetEntityId": "sarah-agent",
     "tags": ["new_interaction"]
   }

   // Evolving relationship
   {
     "sourceEntityId": "user-123",
     "targetEntityId": "sarah-agent",
     "tags": ["frequent_interaction", "positive_sentiment"],
     "metadata": { "interactions": 15 }
   }
   ```

## Integration with Other Systems

Evaluators work alongside other components:

- **Goal Evaluator**: Facts and reflections may influence goal progress
- **Trust Evaluator**: Fact consistency affects trust scoring
- **Memory Manager**: Facts enhance context for future conversations
- **Providers**: Facts inform response generation

---

## Creating Custom Evaluators

You can create your own evaluators by implementing the `Evaluator` interface:

```typescript
const customEvaluator: Evaluator = {
  name: 'CUSTOM_EVALUATOR',
  similes: ['ANALYZE', 'ASSESS'],
  description: 'Performs custom analysis on conversations',

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    // Your validation logic here
    return true;
  },

  handler: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Your evaluation logic here

    // Example of storing evaluation results
    await runtime.addEmbeddingToMemory({
      entityId: runtime.agentId,
      content: { text: 'Evaluation result' },
      roomId: message.roomId,
      createdAt: Date.now(),
    });

    return { result: 'evaluation complete' };
  },

  examples: [
    {
      prompt: `Example context`,
      messages: [
        { name: 'User', content: { text: 'Example message' } },
        { name: 'Agent', content: { text: 'Example response' } },
      ],
      outcome: `{ "result": "example outcome" }`,
    },
  ],
};
```

### Registering Custom Evaluators

Custom evaluators can be registered with the agent runtime:

```typescript
// In your plugin's initialization
export default {
  name: 'custom-evaluator-plugin',
  description: 'Adds custom evaluation capabilities',

  init: async (config: any, runtime: IAgentRuntime) => {
    // Register your custom evaluator
    runtime.registerEvaluator(customEvaluator);
  },

  // Include the evaluator in the plugin exports
  evaluators: [customEvaluator],
};
```

## Best Practices for Memory Formation

1. **Validate Facts**

   - Cross-reference with existing knowledge
   - Consider source reliability
   - Track fact confidence levels

2. **Manage Memory Growth**

   - Prioritize important facts
   - Consolidate related facts
   - Archive outdated status facts

3. **Handle Contradictions**

   - Flag conflicting facts
   - Maintain fact history
   - Update based on newest information

4. **Respect Privacy**

   - Filter sensitive information
   - Consider contextual appropriateness
   - Follow data retention policies

5. **Balance Reflection Frequency**
   - Too frequent: Computational overhead
   - Too infrequent: Missing important information
   - Adapt based on conversation complexity and pace

---

## FAQ

### What's the difference between actions and evaluators?

Actions are triggered during response generation and create visible outputs, while evaluators run after responses and perform background cognitive tasks without direct user visibility.

### When should I use the Fact Evaluator vs. the Reflection Evaluator?

Use the Fact Evaluator when you only need to extract and store factual information. Use the Reflection Evaluator when you need both fact extraction and relationship tracking, along with self-reflective assessment.

### How often do evaluators run?

By default, evaluators run at intervals based on conversation length, typically after every few messages, to avoid unnecessary processing while still capturing important information.

### Can evaluators affect future responses?

Yes! Facts and relationships stored by evaluators become part of the agent's memory and context, influencing future responses through the retrieval-augmented generation system.

### How do I debug evaluator issues?

Use the logger to inspect evaluator execution and output. The most common issues involve entity resolution failures or schema validation errors.

### Can evaluators work across different platforms?

Yes, evaluators are platform-agnostic and work the same way regardless of whether your agent is deployed on Discord, Twitter, Telegram, or web interfaces.

## Related Resources

- [Actions Documentation](./actions.md)
- [Providers Documentation](./providers.md)
- [Agent Runtime](./agents.md)
`````

## File: packages/docs/docs/core/knowledge.md
`````markdown
---
sidebar_position: 4
title: Knowledge System
description: Understanding ElizaOS knowledge management - how agents process, store, and retrieve information
keywords: [knowledge, RAG, embeddings, documents, processing, retrieval, semantic search]
image: /img/knowledge.jpg
---

# Knowledge Management

## Overview

The Knowledge Management system in ElizaOS is a powerful Retrieval-Augmented Generation (RAG) feature that enables agents to process, store, and retrieve information from various sources. This allows agents to provide contextually relevant responses by leveraging stored knowledge during conversations.

## Adding Knowledge to Agents

ElizaOS provides multiple ways to add knowledge to your agents, both during initialization and at runtime.

### Adding Knowledge During Runtime Creation

#### 1. Via Character Definition

The simplest approach is to define knowledge directly in your character configuration:

```typescript
const character: Character = {
  name: 'My Agent',
  // Other character properties...
  knowledge: [
    // Direct string knowledge
    'Important fact: ElizaOS supports multiple knowledge formats',

    // File references
    { path: 'knowledge/documentation.md', shared: false },

    // Directory references
    { directory: 'knowledge/guides', shared: true },
  ],
};
```

The knowledge array supports three formats:

- String literals for direct knowledge
- File objects pointing to specific files
- Directory objects for entire folders of content

#### 2. Programmatically Before Runtime Initialization

You can dynamically load knowledge before creating your runtime:

```typescript
// Load knowledge from files or other sources
const knowledge = [];

// Example: Recursively load documentation files
function loadDocumentation(directoryPath) {
  const files = getFilesRecursively(directoryPath, ['.md']);
  return files.map((filePath) => {
    const relativePath = path.relative(basePath, filePath);
    const content = fs.readFileSync(filePath, 'utf-8');
    return `Path: ${relativePath}\n\n${content}`;
  });
}

// Load documentation
const docKnowledge = loadDocumentation('./docs');
knowledge.push(...docKnowledge);

// Then include in your character definition
const character: Character = {
  // Other character properties...
  knowledge: knowledge,
};
```

### Adding Knowledge After Runtime Creation

#### 1. Using the `addKnowledge` Method

Add knowledge programmatically after the runtime is initialized:

```typescript
// Import needed utilities
import { createUniqueUuid } from '@elizaos/core';

// Create a knowledge item
const knowledgeItem = {
  id: createUniqueUuid(runtime, 'unique-knowledge-identifier'),
  content: {
    text: 'Important information the agent should know...',
  },
};

// Add to runtime with default chunking settings
await runtime.addKnowledge(knowledgeItem);

// Or with custom chunking settings
await runtime.addKnowledge(knowledgeItem, {
  targetTokens: 1500, // Target chunk size (default: 3000)
  overlap: 100, // Overlap between chunks (default: 200)
  modelContextSize: 8192, // Context size of your model (default: 4096)
});
```

#### 2. Processing Files at Runtime

You can dynamically process files at runtime:

```typescript
// For PDF files, use the PDF service
const pdfService = runtime.getService<IPdfService>('pdf');
if (pdfService) {
  const pdfBuffer = fs.readFileSync('./knowledge/document.pdf');
  const textContent = await pdfService.convertPdfToText(pdfBuffer);

  const knowledgeItem = {
    id: createUniqueUuid(runtime, 'document.pdf'),
    content: { text: textContent },
  };

  await runtime.addKnowledge(knowledgeItem);
}
```

## Directory Structure

ElizaOS expects knowledge files to be organized in the following structure:

```
knowledge/          # Root knowledge directory
├── shared/         # Shared knowledge accessible to all agents
└── {agent-name}/   # Agent-specific knowledge directories
```

## Supported File Types

- PDF files (`.pdf`)
- Markdown files (`.md`)
- Text files (`.txt`)

## Knowledge Modes

ElizaOS supports two knowledge modes:

### Classic Mode (Default)

- Direct string knowledge added to character's context
- No chunking or semantic search
- Enabled by default (`settings.ragKnowledge: false`)
- Only processes string knowledge entries
- Simpler but less sophisticated

### RAG Mode

- Advanced knowledge processing with semantic search
- Chunks content and uses embeddings
- Must be explicitly enabled (`settings.ragKnowledge: true`)
- Supports three knowledge types:
  1. Direct string knowledge
  2. Single file references: `{ "path": "path/to/file.md", "shared": false }`
  3. Directory references: `{ "directory": "knowledge/dir", "shared": false }`
- Supported file types: .md, .txt, .pdf
- Optional `shared` flag for knowledge reuse across characters

To enable RAG mode, add this to your character settings:

```typescript
const character: Character = {
  // Other character properties...
  settings: {
    ragKnowledge: true,
  },
};
```

## How Knowledge Processing Works

### Document Processing Flow

The RAG system processes documents through several stages:

1. **Directory Processing**

   - The system scans configured directories in `knowledge/`
   - Files are processed based on their shared/private status and file type

2. **File Processing Pipeline**

   - **Preprocessing**: Reading, cleaning, and normalizing text
   - **Document-level Processing**: Generating embeddings for the entire document
   - **Chunk Processing**: Splitting content into manageable chunks and generating embeddings for each

3. **Retrieval Process**
   - When a user message is received, its embedding is generated
   - This embedding is compared to stored knowledge embeddings
   - The most semantically similar chunks are retrieved
   - Retrieved knowledge is incorporated into the agent's context

This multi-level approach enables:

- Broad document-level semantic search
- Fine-grained chunk-level retrieval for specific information
- Efficient parallel processing of large documents
- Maintenance of document context through metadata linking

### Knowledge Processing Flow Diagram

```mermaid
graph TB
    subgraph Directory_Processing
        A[Read Files from Directory] --> B[File Content]
    end

    subgraph Preprocessing
        B --> C[Clean & Normalize Text]
    end

    subgraph Document_Processing
        C --> D[Generate Document Embedding]
        D --> E[Store Full Document]
        E --> |Metadata| F[File Path]
        E --> |Metadata| G[File Type]
        E --> |Metadata| H[Shared Status]
    end

    subgraph Chunk_Processing
        C --> I[Split into Chunks]
        I --> |512 tokens| J[Chunk 1]
        I --> |20 token overlap| K[...]
        I --> L[Chunk N]

        subgraph Parallel_Processing
            J --> M1[Generate Embedding]
            K --> M2[Generate Embedding]
            L --> M3[Generate Embedding]
        end

        subgraph Chunk_Storage
            M1 --> N1[Store Chunk]
            M2 --> N2[Store Chunk]
            M3 --> N3[Store Chunk]

            N1 --> |Metadata| O[Original Doc Reference]
            N1 --> |Metadata| P[Chunk Index]
            N2 --> |Metadata| O
            N2 --> |Metadata| P
            N3 --> |Metadata| O
            N3 --> |Metadata| P
        end
    end

    style Directory_Processing fill:#f9f,stroke:#333,stroke-width:2px
    style Preprocessing fill:#bbf,stroke:#333,stroke-width:2px
    style Document_Processing fill:#bfb,stroke:#333,stroke-width:2px
    style Chunk_Processing fill:#fbf,stroke:#333,stroke-width:2px
    style Parallel_Processing fill:#fbb,stroke:#333,stroke-width:2px
    style Chunk_Storage fill:#bff,stroke:#333,stroke-width:2px
```

### Processing Parameters

- **Chunk Size**: 512 tokens (default, configurable when adding knowledge)
- **Chunk Overlap**: 20 tokens (default, configurable)
- **Processing Batch Size**: 10 chunks processed concurrently
- **Default Similarity Threshold**: 0.85 for retrieval
- **Default Match Count**: 5 results returned

## Best Practices for Knowledge Management

### Content Organization

1. **Document Structure**

   - Use clear section headings and hierarchical organization
   - Break large documents into logical smaller files
   - Include metadata and context in markdown files
   - Structure information from general to specific

2. **File Management**

   - Use descriptive filenames that reflect content
   - Group related files in subdirectories
   - Keep paths short and meaningful
   - Avoid special characters in filenames

3. **Knowledge Optimization**
   - Keep individual documents focused on specific topics
   - For very detailed information, use smaller chunks (200-300 tokens) by setting `targetTokens`
   - Balance the total number of knowledge items for performance
   - Prefer markdown (.md) files for best processing results

### Processing Large Knowledge Bases

When adding many knowledge items at once, consider implementing a semaphore pattern:

```typescript
import { Semaphore } from '@elizaos/core';

// Create semaphore to limit concurrent processing
const semaphore = new Semaphore(10);

// Process items with controlled concurrency
await Promise.all(
  items.map(async (item) => {
    await semaphore.acquire();
    try {
      await runtime.addKnowledge(item);
    } finally {
      semaphore.release();
    }
  })
);
```

### Knowledge ID Management

When adding knowledge programmatically, use consistent ID generation:

```typescript
import { createUniqueUuid } from '@elizaos/core';
const knowledgeId = createUniqueUuid(runtime, 'my-content');
```

This ensures deterministic IDs that remain stable across sessions.

## Troubleshooting

### Common Issues and Solutions

1. **Knowledge Not Being Retrieved**:

   - Verify the file is in a supported format (PDF, MD, TXT)
   - Check if embeddings were properly generated
   - Ensure similarity threshold isn't too high (default: 0.85)
   - Test retrieval with more specific queries
   - Verify RAG mode is enabled if using file/directory references

2. **Poor Quality Retrievals**:

   - Break down large documents into smaller, focused files
   - Ensure document content is clear and well-structured
   - Review the chunking size and overlap settings
   - Check if the query contains too many common words

3. **Performance Issues**:

   - Monitor the total number of knowledge items
   - Consider reducing the match count for faster retrieval
   - Check embedding processing time for large documents
   - Use shared knowledge efficiently across agents

4. **File Processing Errors**:
   - Verify file permissions
   - Check if paths are correctly structured
   - Ensure PDF files are readable and not password-protected
   - Validate that text encoding is UTF-8

## Technical Implementation Details

### Knowledge ID Relationships

The RAG system uses a hierarchical ID structure to maintain relationships:

```mermaid
classDiagram
    class Document {
        +UUID id
        +String filePath
        +String fileType
        +Boolean isShared
        +Float32Array embedding
        +String content
    }

    class Fragment {
        +UUID id
        +UUID originalId
        +Number chunkIndex
        +String content
        +Float32Array embedding
        +String originalPath
    }

    Document "1" --> "*" Fragment : generates
```

#### ID Generation and Linking

Documents IDs are generated using `createUniqueUuid(runtime, path, isShared)`, making them deterministic. Fragment IDs follow the format `${documentId}-chunk-${index}` to maintain the relationship to their source document.

## API Reference

### Key Methods

#### `runtime.addKnowledge(item: KnowledgeItem, options?): Promise<void>`

Adds new knowledge to the agent.

- Parameters:
  - `item`: A knowledge item containing:
    - `id`: UUID
    - `content`: Object with `text` property
  - `options`: Optional processing configuration:
    - `targetTokens`: Number (default: 3000)
    - `overlap`: Number (default: 200)
    - `modelContextSize`: Number (default: 4096)

#### `runtime.getKnowledge(message: Memory): Promise<KnowledgeItem[]>`

Retrieves knowledge based on a message's content.

- Parameters:
  - `message`: Memory object containing user message
- Returns: Array of matching KnowledgeItem objects

### Knowledge Item Definition

```typescript
interface KnowledgeItem {
  id: UUID;
  content: {
    text: string;
    // Optional additional metadata
    [key: string]: any;
  };
}
```

## Security Considerations

1. **Access Control**:

   - Use the `shared` flag appropriately to control document access
   - Keep sensitive information in agent-specific directories
   - Regularly audit knowledge access patterns

2. **Data Privacy**:
   - Do not store sensitive personal information in knowledge files
   - Review documents for potentially sensitive content before adding
   - Implement appropriate backup and recovery procedures

## Future Considerations

1. **Scalability**:

   - Monitor knowledge base size and performance
   - Plan for regular maintenance and cleanup
   - Consider implementing document versioning

2. **Integration**:
   - Document integration points with other systems
   - Plan for potential future file format support
   - Consider implementing knowledge base analytics

## Support and Resources

- Review the implementation in `packages/core/src/ragknowledge.ts`
- Check the issue tracker for known issues and solutions
- Contribute improvements and bug fixes through pull requests
`````

## File: packages/docs/docs/core/overview.md
`````markdown
---
sidebar_position: 1
title: ElizaOS Documentation
slug: /
description: Comprehensive framework for building AI agents with persistent personalities across multiple platforms
keywords:
  [
    architecture,
    components,
    system design,
    agents,
    services,
    database,
    actions,
    providers,
    evaluators,
    plugins,
  ]
image: /img/eliza_banner.jpg
---

# ElizaOS Documentation

Welcome to ElizaOS - a comprehensive framework for building AI agents with persistent personalities across multiple platforms. ElizaOS provides the architecture, tools, and systems needed to create sophisticated agents that maintain consistent behavior, learn from interactions, and seamlessly integrate with a variety of services.

> **New to ElizaOS?** Check out [What's new in ElizaOS V2](https://eliza.how/blog/v1-v2) to understand how it compares to previous versions.

## System Architecture

ElizaOS uses a modular architecture that separates concerns while providing a cohesive framework for AI agent development:

```mermaid
graph TB
    %% Main Components with vertical orientation
    User((User)):::user

    %% First Level - Services
    PlatformServices[Services]:::services

    %% Second Level - Runtime
    AgentRuntime[Agent Runtime]:::core

    %% Core Processing Components - Side by side
    subgraph "Core Processing"
        direction LR
        Providers[Providers]:::int
        Actions[Actions]:::int
        Evaluators[Evaluators]:::int
    end

    %% Knowledge and DB - Side by side
    subgraph "Knowledge & Storage"
        direction LR
        Knowledge[Knowledge]:::int
        DB[(Database)]:::db
    end

    %% Organization Components - Vertical layout
    subgraph "Organization"
        direction TB
        Worlds[Worlds]:::struct
        Rooms[Rooms]:::struct
        Entities[Entities]:::struct
    end

    %% Development Components - Side by side
    subgraph "Development & Integration"
        direction LR
        Plugins[Plugins]:::dev
        Projects[Projects]:::dev
        Tasks[Tasks]:::dev
    end

    %% Main Flow - Vertical emphasis
    User <-->|Interaction| PlatformServices
    PlatformServices -->|Process| AgentRuntime

    %% Runtime connections - Simplified
    AgentRuntime ---|Context| Providers
    AgentRuntime ---|Behavior| Actions
    AgentRuntime ---|Analysis| Evaluators

    %% Data connections
    AgentRuntime <-->|Storage| DB
    Knowledge -->|Informs| Providers

    %% Structure connections - Clean vertical hierarchy
    AgentRuntime -->|Manages| Worlds
    Worlds -->|Contains| Rooms
    Rooms -->|Has| Entities

    %% Development connections
    Projects -->|Configure| AgentRuntime
    Plugins -->|Extend| AgentRuntime
    Tasks -->|Scheduled by| AgentRuntime

    %% Clickable nodes with links to docs
    click AgentRuntime "/docs/core/agents" "Learn about Agent Runtime"
    click PlatformServices "/docs/core/services" "Learn about Services"
    click DB "/docs/core/database" "Learn about Database Systems"
    click Actions "/docs/core/actions" "Learn about Actions"
    click Providers "/docs/core/providers" "Learn about Providers"
    click Evaluators "/docs/core/evaluators" "Learn about Evaluators"
    click Knowledge "/docs/core/knowledge" "Learn about Knowledge System"
    click Worlds "/docs/core/worlds" "Learn about Worlds"
    click Rooms "/docs/core/rooms" "Learn about Rooms"
    click Entities "/docs/core/entities" "Learn about Entities"
    click Plugins "/docs/core/plugins" "Learn about Plugins"
    click Projects "/docs/core/project" "Learn about Projects"
    click Tasks "/docs/core/tasks" "Learn about Tasks"

    %% Styling
    classDef core fill:#3498db,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef services fill:#9b59b6,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef db fill:#27ae60,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef int fill:#e74c3c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef struct fill:#f39c12,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef dev fill:#1abc9c,stroke:#2c3e50,stroke-width:1px,color:#fff,font-weight:bold
    classDef user fill:#ecf0f1,stroke:#2c3e50,stroke-width:2px,color:#2c3e50,font-weight:bold,border-radius:50%
```

### How ElizaOS Works

When a user message is received:

1. **Service Reception**: Platform service (Discord, Telegram, etc.) receives the message
2. **Runtime Processing**: Agent runtime coordinates the response generation
3. **Context Building**: Providers supply relevant context (time, recent messages, knowledge)
4. **Action Selection**: The agent evaluates and selects appropriate actions
5. **Response Generation**: The chosen action generates a response
6. **Learning & Reflection**: Evaluators analyze the conversation for insights and learning
7. **Memory Storage**: New information is stored in the database
8. **Response Delivery**: The response is sent back through the service

This creates a continuous cycle of interaction, reflection, and improvement that allows agents to maintain consistent personalities while adapting to new information.

### Core Components

| [![Agent Runtime](/img/agentruntime.jpg)](/docs/core/agents)                                                        | [![Services](/img/services.jpg)](/docs/core/services)                                                                          | [![Database](/img/database.jpg)](/docs/core/database)                                                                        |
| ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| **[🤖 Agent Runtime](/docs/core/agents)** — Orchestrates agent behavior, manages state, and coordinates components. | **[📚 Services](/docs/core/services)** — Enables agents to communicate across Discord, Twitter, Telegram, and other platforms. | **[💾 Database](/docs/core/database)** — Stores memories, entity data, relationships, and configuration using vector search. |

---

### Intelligence & Behavior

| [![Actions](/img/actions.jpg)](/docs/core/actions)                                                              | [![Providers](/img/providers.jpg)](/docs/core/providers)                                            | [![Evaluators](/img/evaluators.jpg)](/docs/core/evaluators)                                                           | [![Knowledge](/img/knowledge.jpg)](/docs/core/knowledge)                                           |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| **[⚡ Actions](/docs/core/actions)** — Executable capabilities for agents to respond and interact with systems. | **[🔌 Providers](/docs/core/providers)** — Supplies context to inform agent decisions in real time. | **[📊 Evaluators](/docs/core/evaluators)** — Analyzes conversations to extract insights and improve future responses. | **[🧠 Knowledge](/docs/core/knowledge)** — RAG system for document processing and semantic memory. |

---

### Structure & Organization

| [![Worlds](/img/worlds.jpg)](/docs/core/worlds)                                       | [![Rooms](/img/rooms.jpg)](/docs/core/rooms)                                      | [![Entities](/img/entities.jpg)](/docs/core/entities)                                    |
| ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **[🌐 Worlds](/docs/core/worlds)** — Organizes environments like servers or projects. | **[💬 Rooms](/docs/core/rooms)** — Spaces for conversation, like channels or DMs. | **[👤 Entities](/docs/core/entities)** — Represents users, bots, and other participants. |

---

### Development & Integration

| [![Plugins](/img/plugins.jpg)](/docs/core/plugins)                                   | [![Projects](/img/project.jpg)](/docs/core/project)                                     | [![Tasks](/img/tasks.jpg)](/docs/core/tasks)                                  |
| ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **[🧩 Plugins](/docs/core/plugins)** — Modular extensions that add new capabilities. | **[📝 Projects](/docs/core/project)** — Defines and deploys agents with configurations. | **[📋 Tasks](/docs/core/tasks)** — Manages scheduled and deferred operations. |

---

## Key Concepts

### Action-Provider-Evaluator Cycle

The core of the ElizaOS system operates as a continuous cycle:

1. **Providers** gather context before response generation
2. **Actions** determine what the agent can do and are executed to generate responses
3. **Evaluators** analyze conversations after responses to extract insights
4. These insights become part of the agent's memory
5. Future **Providers** access this memory to inform new responses

This creates a virtuous cycle where agents continuously learn and improve from interactions.

### Entity-Component Architecture

ElizaOS uses an entity-component architecture for flexible data modeling:

- **Entities** are base objects with unique IDs (users, agents, etc.)
- **Components** are pieces of data attached to entities (profiles, settings, etc.)
- This approach allows for dynamic composition without complex inheritance hierarchies

### Memory System

The memory system in ElizaOS provides:

- **Vector-based semantic search** for finding relevant memories
- **Multi-level memory types** (messages, facts, knowledge)
- **Temporal awareness** through timestamped memories
- **Cross-platform continuity** while maintaining appropriate context boundaries

## Getting Started

If you're new to ElizaOS, we recommend this learning path:

1. Start with this overview to understand the system architecture
2. Explore the [Agent Runtime](/docs/core/agents) to understand the core system
3. Learn about [Projects](/docs/core/project) to set up your development environment
4. Understand how [Actions](/docs/core/actions) and [Providers](/docs/core/providers) work together
5. Explore [Services](/docs/core/services) to connect with external platforms
6. Dive into [Plugins](/docs/core/plugins) to extend functionality

## FAQ

**What's the difference between Actions, Evaluators, and Providers?**

Actions define what an agent can do and are executed during response generation. Evaluators analyze conversations after they happen to extract insights and improve future responses. Providers supply contextual information before the agent decides how to respond.

**How does ElizaOS handle cross-platform conversation context?**

ElizaOS maintains separate conversation contexts for different platforms by default, but shares entity relationships and learned facts across platforms. This ensures agents maintain a consistent understanding of users while respecting platform-specific conversation boundaries.

**How does the memory system work?**

Memory is organized into different types (messages, facts, knowledge) and stored with vector embeddings for semantic search. This allows agents to retrieve relevant memories based on context rather than just recency, creating more natural conversations.

**What's the relationship between Worlds, Rooms, and Entities?**

Worlds are container spaces (like a Discord server) that can have multiple Rooms (channels, DMs). Entities (users, agents) participate in Rooms within Worlds. This hierarchical structure mirrors real-world platforms while providing a consistent abstraction.

**How extensible is ElizaOS?**

ElizaOS is highly extensible through its plugin system. You can create custom actions, providers, evaluators, services, and more to extend functionality. The architecture is designed to be modular and composable at every level.

## Additional Resources

- [API Reference](/api) - Detailed API documentation for developers
- [GitHub Repository](https://github.com/elizaos/eliza) - Source code and contributions
- [Package Showcase](/packages) - Explore available plugins and extensions
`````

## File: packages/docs/docs/core/project.md
`````markdown
---
sidebar_position: 2
title: Project System
description: Understanding ElizaOS projects - organizational structure for creating and deploying AI agents
keywords: [projects, organization, configuration, character, agents, deployment]
image: /img/project.jpg
---

# 📝 ElizaOS Projects

Projects are the main organizational structure in ElizaOS, containing all the necessary components to create and deploy AI agents. A project can include one or more agents, each with their own character definition, plugins, and configurations.

## Project Structure

A typical ElizaOS project structure:

```
my-eliza-project/
├── src/
│   └── index.ts        # Main entry point
├── knowledge/          # Knowledge base files
├── package.json        # Dependencies and scripts
└── tsconfig.json       # TypeScript configuration
```

## Creating a New Project

You can create a new ElizaOS project using:

```bash
# Using npm
npm create eliza@beta

# Or using npx
npx @elizaos/cli@beta create
```

The CLI will guide you through the setup process, including:

- Project name
- Database selection (pglite, postgres, etc.)
- Initial configuration

## Project Configuration

The main project file (`src/index.ts`) exports a default project object:

```typescript
import type { Character, IAgentRuntime, Project, ProjectAgent } from '@elizaos/core';
import customPlugin from './plugin';

// Define the character
export const character: Character = {
  name: 'Agent Name',
  plugins: ['@elizaos/plugin-discord', '@elizaos/plugin-direct'],
  // Other character properties
};

// Create a ProjectAgent that includes the character
export const projectAgent: ProjectAgent = {
  character,
  init: async (runtime: IAgentRuntime) => {
    // Initialize agent-specific functionality
    console.log('Initializing agent:', character.name);
  },
  plugins: [customPlugin],
  tests: [], // Optional tests for your agent
};

// Export the full project with all agents
const project: Project = {
  agents: [projectAgent],
};

export default project;
```

## Character Configuration

Each agent in your project requires a character definition that controls its personality, knowledge, and behavior.

### Required Character Fields

```typescript
{
  name: "agent_name", // Character's display name
  plugins: ["@elizaos/plugin-discord"], // Example plugins
  settings: {
    // Configuration settings
    secrets: {}, // API keys and sensitive data
    voice: {}, // Voice configuration
  },
  bio: [], // Character background as a string or array of statements
  style: {
    // Interaction style guide
    all: [], // General style rules
    chat: [], // Chat-specific style
    post: [] // Post-specific style
  }
}
```

### Plugins

Plugins provide your agent with capabilities and integrations:

- `@elizaos/plugin-discord`: Discord integration
- `@elizaos/plugin-telegram`: Telegram integration
- `@elizaos/plugin-twitter`: Twitter/X integration
- `@elizaos/plugin-slack`: Slack integration
- `@elizaos/plugin-direct`: Direct chat interface
- `@elizaos/plugin-simsai`: SimsAI platform integration

View all available plugins: https://github.com/elizaos-plugins/registry

### Settings Configuration

The `settings` object supports various configurations:

```typescript
{
  "settings": {
    "ragKnowledge": false, // Enable RAG knowledge mode
    "voice": {
      "model": "string", // Voice synthesis model
      "url": "string" // Optional voice API URL
    },
    "secrets": {
      // API keys (use env vars in production)
      "API_KEY": "string"
    },
  }
}
```

### Bio & Style

Define your agent's personality and communication style:

```typescript
{
  "bio": ["Expert in blockchain development", "Specializes in DeFi protocols"],
  "style": {
    "all": [
      // Applied to all interactions
      "Keep responses clear",
      "Maintain professional tone"
    ],
    "chat": [
      // Chat-specific style
      "Engage with curiosity",
      "Provide explanations"
    ],
    "post": [
      // Social post style
      "Keep posts informative",
      "Focus on key points"
    ]
  }
}
```

**Style Tips**

- Be specific about tone and mannerisms
- Include platform-specific guidance
- Define clear boundaries and limitations

### Optional Character Fields

```typescript
{
  "username": "handle", // Character's username/handle
  "system": "System prompt text", // Custom system prompt
  "lore": [], // Additional background/history
  "knowledge": [
    // Knowledge base entries
    "Direct string knowledge",
    { "path": "file/path.md", "shared": false },
    { "directory": "knowledge/path", "shared": false }
  ],
  "messageExamples": [], // Example conversations
  "postExamples": [], // Example social posts
  "topics": [], // Areas of expertise
  "adjectives": [] // Character traits
}
```

## Knowledge Management

ElizaOS supports two knowledge modes:

### Classic Mode (Default)

- Direct string knowledge added to character's context
- No chunking or semantic search
- Enabled by default (`settings.ragKnowledge: false`)
- Only processes string knowledge entries
- Simpler but less sophisticated

### RAG Mode

- Advanced knowledge processing with semantic search
- Chunks content and uses embeddings
- Must be explicitly enabled (`settings.ragKnowledge: true`)
- Supports three knowledge types:
  1. Direct string knowledge
  2. Single file references: `{ "path": "path/to/file.md", "shared": false }`
  3. Directory references: `{ "directory": "knowledge/dir", "shared": false }`
- Supported file types: .md, .txt, .pdf
- Optional `shared` flag for knowledge reuse across characters

### Knowledge Path Configuration

- Knowledge files are relative to the project's `knowledge` directory
- Paths should not contain `../` (sanitized for security)
- Both shared and private knowledge supported
- Files automatically reloaded if content changes

## Example Project

Here's a complete example of a project configuration:

```typescript
import type { Character, IAgentRuntime, Project, ProjectAgent } from '@elizaos/core';

export const character: Character = {
  name: 'Tech Helper',
  plugins: ['@elizaos/plugin-discord', '@elizaos/plugin-direct'],
  settings: {
    ragKnowledge: true,
    voice: {
      model: 'en_US-male-medium',
    },
    discord: {
      shouldRespondOnlyToMentions: false,
      allowedChannelIds: ['123456789012345678'],
    },
  },
  bio: ['Friendly technical assistant', 'Specializes in explaining complex topics simply'],
  lore: ['Pioneer in open-source AI development', 'Advocate for AI accessibility'],
  messageExamples: [
    [
      {
        name: 'user1',
        content: { text: 'Can you explain how AI models work?' },
      },
      {
        name: 'TechAI',
        content: {
          text: 'Think of AI models like pattern recognition systems.',
        },
      },
    ],
  ],
  topics: ['artificial intelligence', 'machine learning', 'technology education'],
  knowledge: [
    {
      directory: 'tech_guides',
      shared: true,
    },
  ],
  style: {
    all: ['Clear', 'Patient', 'Educational'],
    chat: ['Interactive', 'Supportive'],
    post: ['Concise', 'Informative'],
  },
};

export const projectAgent: ProjectAgent = {
  character,
  init: async (runtime: IAgentRuntime) => {
    console.log('Initializing Tech Helper agent');
  },
  plugins: [], // Project-specific plugins
};

const project: Project = {
  agents: [projectAgent],
};

export default project;
```

## Character File Export

While projects are the primary structure in ElizaOS, you can still export standalone character files for compatibility with other systems or sharing character definitions:

```typescript
import fs from 'fs';
import { character } from './src/index';

// Export character to JSON file
fs.writeFileSync('character.json', JSON.stringify(character, null, 2));
```

## Managing Multiple Agents

A project can contain multiple agents, each with its own character and plugins:

```typescript
const project: Project = {
  agents: [
    {
      character: technicalSupportCharacter,
      init: async (runtime) => {
        /* init code */
      },
      plugins: [customSupportPlugin],
    },
    {
      character: communityManagerCharacter,
      init: async (runtime) => {
        /* init code */
      },
      plugins: [communityPlugin],
    },
  ],
};
```

Each agent operates independently but can share the same database and resources.

## Running Your Project

After configuring your project, you can run it using:

```bash
elizaos start
```

This will start your agents according to your project configuration.
`````

## File: packages/docs/docs/core/providers.md
`````markdown
---
sidebar_position: 5
title: Providers System
description: Understanding ElizaOS providers - components that supply real-time information and context to agents
keywords: [providers, context, information, data, integration, dynamic, private, state]
image: /img/providers.jpg
---

# 🔌 Providers

[Providers](/packages/core/src/providers.ts) are the sources of information for the agent. They provide data or state while acting as the agent's "senses", injecting real-time information into the agent's context. They serve as the eyes, ears, and other sensory inputs that allow the agent to perceive and interact with its environment, like a bridge between the agent and various external systems such as market data, wallet information, sentiment analysis, and temporal context. Anything that the agent knows is either coming from like the built-in context or from a provider. For more info, see the [providers API page](/api/interfaces/provider).

Here's an example of how providers work within ElizaOS:

- A news provider could fetch and format news.
- A computer terminal provider in a game could feed the agent information when the player is near a terminal.
- A wallet provider can provide the agent with the current assets in a wallet.
- A time provider injects the current date and time into the context.

---

## Overview

A provider's primary purpose is to supply dynamic contextual information that integrates with the agent's runtime. They format information for conversation templates and maintain consistent data access. For example:

- **Function:** Providers run during or before an action is executed.
- **Purpose:** They allow for fetching information from other APIs or services to provide different context or ways for an action to be performed.
- **Example:** Before a "Mars rover action" is executed, a provider could fetch information from another API. This fetched information can then be used to enrich the context of the Mars rover action.

The provider interface is defined in [types.ts](/packages/core/src/types.ts):

```typescript
interface Provider {
  /** Provider name */
  name: string;

  /** Description of the provider */
  description?: string;

  /** Whether the provider is dynamic */
  dynamic?: boolean;

  /** Position of the provider in the provider list, positive or negative */
  position?: number;

  /**
   * Whether the provider is private
   *
   * Private providers are not displayed in the regular provider list, they have to be called explicitly
   */
  private?: boolean;

  /** Data retrieval function */
  get: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<ProviderResult>;
}
```

The `get` function takes:

- `runtime`: The agent instance calling the provider
- `message`: The last message received
- `state`: Current conversation state

It returns a `ProviderResult` object that contains:

```typescript
interface ProviderResult {
  values?: {
    [key: string]: any;
  };
  data?: {
    [key: string]: any;
  };
  text?: string;
}
```

- `values`: Key-value pairs to be merged into the agent's state values
- `data`: Additional structured data that can be used by the agent but not directly included in the context
- `text`: String that gets injected into the agent's context

---

## Provider Types and Properties

Providers come with several properties that control how and when they are used:

### Dynamic Providers

Dynamic providers are not automatically included in the context. They must be explicitly requested either in the filter list or include list when composing state.

```typescript
const dynamicProvider: Provider = {
  name: 'dynamicExample',
  description: 'A dynamic provider example',
  dynamic: true,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Dynamic information fetched on demand',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

### Private Providers

Private providers are not included in the regular provider list and must be explicitly included in the include list when composing state.

```typescript
const privateProvider: Provider = {
  name: 'privateExample',
  description: 'A private provider example',
  private: true,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Private information only available when explicitly requested',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

### Provider Positioning

The `position` property determines the order in which providers are processed. Lower numbers are processed first.

```typescript
const earlyProvider: Provider = {
  name: 'earlyExample',
  description: 'Runs early in the provider chain',
  position: -100,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Early information',
      values: {
        /* key-value pairs */
      },
    };
  },
};

const lateProvider: Provider = {
  name: 'lateExample',
  description: 'Runs late in the provider chain',
  position: 100,
  get: async (runtime, message, state) => {
    // ...implementation
    return {
      text: 'Late information that might depend on earlier providers',
      values: {
        /* key-value pairs */
      },
    };
  },
};
```

---

## State Composition with Providers

The runtime composes state by gathering data from enabled providers. When calling `composeState`, you can control which providers are used:

```typescript
// Get state with all non-private, non-dynamic providers
const state = await runtime.composeState(message);

// Get state with specific providers only
const filteredState = await runtime.composeState(
  message,
  ['timeProvider', 'factsProvider'], // Only include these providers
  null
);

// Include private or dynamic providers
const enhancedState = await runtime.composeState(
  message,
  null,
  ['privateExample', 'dynamicExample'] // Include these private/dynamic providers
);
```

The system caches provider results to optimize performance. When a provider is called multiple times with the same message, the cached result is used unless you explicitly request a new evaluation.

---

## Examples

ElizaOS providers typically fall into these categories, with examples from the ecosystem:

### System & Integration

- **Time Provider**: Injects current date/time for temporal awareness
- **Giphy Provider**: Provides GIF responses using Giphy API
- **GitBook Provider**: Supplies documentation context from GitBook
- **Topics Provider**: Caches and serves Allora Network topic information

### Blockchain & DeFi

- **Wallet Provider**: Portfolio data from Zerion, balances and prices
- **DePIN Provider**: Network metrics via DePINScan API
- **Chain Providers**: Data from Abstract, Fuel, ICP, EVM networks
- **Market Provider**: Token data from DexScreener, Birdeye APIs

### Knowledge & Data

- **DKG Provider**: OriginTrail decentralized knowledge integration
- **News Provider**: Current events via NewsAPI
- **Trust Provider**: Calculates and injects trust scores

Visit the [ElizaOS Plugin Registry](https://github.com/elizaos-plugins/registry) for a complete list of available plugins and providers.

### Time Provider Example

```typescript
const timeProvider: Provider = {
  name: 'time',
  description: 'Provides the current date and time',
  position: -10, // Run early to ensure time is available for other providers
  get: async (_runtime: IAgentRuntime, _message: Memory) => {
    const currentDate = new Date();
    const options = {
      timeZone: 'UTC',
      dateStyle: 'full' as const,
      timeStyle: 'long' as const,
    };
    const humanReadable = new Intl.DateTimeFormat('en-US', options).format(currentDate);

    return {
      text: `The current date and time is ${humanReadable}. Please use this as your reference for any time-based operations or responses.`,
      values: {
        currentDate: currentDate.toISOString(),
        humanReadableDate: humanReadable,
      },
    };
  },
};
```

### Dynamic Provider Example

```typescript
const weatherProvider: Provider = {
  name: 'weather',
  description: 'Provides weather information for a location',
  dynamic: true, // Only used when explicitly requested
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    // Extract location from state if available
    const location = state?.values?.location || 'San Francisco';

    try {
      // Fetch weather data from an API
      const weatherData = await fetchWeatherData(location);

      return {
        text: `The current weather in ${location} is ${weatherData.description} with a temperature of ${weatherData.temperature}°C.`,
        values: {
          weather: {
            location,
            temperature: weatherData.temperature,
            description: weatherData.description,
            humidity: weatherData.humidity,
          },
        },
        data: {
          // Additional detailed data that doesn't go into the context
          weatherDetails: weatherData,
        },
      };
    } catch (error) {
      // Handle errors gracefully
      return {
        text: `I couldn't retrieve weather information for ${location} at this time.`,
        values: {
          weather: { error: true },
        },
      };
    }
  },
};
```

---

## Best Practices

### 1. Optimize for Efficiency

- Return both structured data (`values`) and formatted text (`text`)
- Use caching for expensive operations
- Include a clear provider name and description

```typescript
const efficientProvider: Provider = {
  name: 'efficientExample',
  description: 'Efficiently provides cached data',
  get: async (runtime, message) => {
    // Check for cached data
    const cacheKey = `data:${message.roomId}`;
    const cachedData = await runtime.getCache(cacheKey);

    if (cachedData) {
      return cachedData;
    }

    // Fetch fresh data if not cached
    const result = {
      text: 'Freshly generated information',
      values: {
        /* key-value pairs */
      },
      data: {
        /* structured data */
      },
    };

    // Cache the result with appropriate TTL
    await runtime.setCache(cacheKey, result, { expires: 30 * 60 * 1000 }); // 30 minutes

    return result;
  },
};
```

### 2. Handle Errors Gracefully

Always handle errors without throwing exceptions that would interrupt the agent's processing:

```typescript
try {
  // Risky operation
} catch (error) {
  return {
    text: "I couldn't retrieve that information right now.",
    values: { error: true },
  };
}
```

### 3. Use Position for Optimal Order

Position providers according to their dependencies:

- Negative positions: Fundamental information providers (time, location)
- Zero (default): Standard information providers
- Positive positions: Providers that depend on other information

### 4. Structure Return Values Consistently

Maintain a consistent structure in your provider's return values to make data easier to use across the system.

---

## FAQ

### What's the difference between values, data, and text?

- `values`: These are merged into the agent state and can be accessed by other providers
- `data`: Structured data stored in state.data.providers but not directly exposed to the agent
- `text`: Formatted text that's directly injected into the agent's context

### When should I use a dynamic provider?

Use dynamic providers when the information is expensive to compute, only relevant in specific situations, or requires explicit triggering rather than being included in every context.

### How do I explicitly include a private provider?

Private providers must be included in the `includeList` parameter when calling `composeState`:

```typescript
const state = await runtime.composeState(message, null, ['privateProviderName']);
```

### Can providers access service functionality?

Yes, providers can use services through the runtime. For example, a wallet provider might use a blockchain service to fetch data:

```typescript
const walletProvider: Provider = {
  name: 'wallet',
  get: async (runtime, message) => {
    const solanaService = runtime.getService('solana');
    if (!solanaService) {
      return { text: '' };
    }

    const walletData = await solanaService.getCachedData();
    // Process and return wallet data
  },
};
```

### How should providers handle failures?

Providers should handle failures gracefully and return valid ProviderResult objects with appropriate error information. Never throw errors that would break the agent's context composition.

### Can providers maintain state between calls?

While providers can maintain internal state (e.g., through closures), it's better to use the runtime's cache system for persistence:

```typescript
// Store data
await runtime.setCache('myProvider:someKey', dataToStore);

// Retrieve data later
const storedData = await runtime.getCache('myProvider:someKey');
```

---

## Further Reading

- [Provider Implementation](/packages/core/src/providers.ts)
- [Types Reference](/packages/core/src/types.ts)
- [Runtime Integration](/packages/core/src/runtime.ts)
`````

## File: packages/docs/docs/core/rooms.md
`````markdown
---
sidebar_position: 8
title: Rooms System
description: Understanding ElizaOS rooms - interaction spaces for entities to exchange messages and communicate
keywords: [rooms, channels, conversations, participants, messages, interaction, communication]
image: /img/elizaos-rooms-simplified.svg
---

# Rooms

Rooms in ElizaOS represent individual interaction spaces within a world. A room can be a conversation, a channel, a thread, or any other defined space where entities can exchange messages and interact. Rooms are typically contained within a world, though they can also exist independently.

![](/img/elizaos-rooms-simplified.svg)

## Room Structure

A room in ElizaOS has the following properties:

```typescript
type Room = {
  id: UUID;
  name?: string;
  agentId?: UUID;
  source: string;
  type: ChannelType;
  channelId?: string;
  serverId?: string;
  worldId?: UUID;
  metadata?: Record<string, unknown>;
};
```

| Property    | Description                                                      |
| ----------- | ---------------------------------------------------------------- |
| `id`        | Unique identifier for the room                                   |
| `name`      | Optional display name for the room                               |
| `agentId`   | Optional ID of the agent associated with this room               |
| `source`    | The platform or origin of the room (e.g., 'discord', 'telegram') |
| `type`      | Type of room (DM, GROUP, THREAD, etc.)                           |
| `channelId` | External system channel identifier                               |
| `serverId`  | External system server identifier                                |
| `worldId`   | Optional ID of the parent world                                  |
| `metadata`  | Additional room configuration data                               |

## Room Types

ElizaOS supports several room types, defined in the `ChannelType` enum:

| Type          | Description                               |
| ------------- | ----------------------------------------- |
| `SELF`        | Messages to self                          |
| `DM`          | Direct messages between two participants  |
| `GROUP`       | Group messages with multiple participants |
| `VOICE_DM`    | Voice direct messages                     |
| `VOICE_GROUP` | Voice channels with multiple participants |
| `FEED`        | Social media feed                         |
| `THREAD`      | Threaded conversation                     |
| `WORLD`       | World channel                             |
| `FORUM`       | Forum discussion                          |
| `API`         | Legacy type - Use DM or GROUP instead     |

## Room Creation and Management

### Creating a Room

You can create a new room using the AgentRuntime:

```typescript
const roomId = await runtime.createRoom({
  name: 'general-chat',
  source: 'discord',
  type: ChannelType.GROUP,
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  worldId: parentWorldId,
});
```

### Ensuring a Room Exists

To create a room if it doesn't already exist:

```typescript
await runtime.ensureRoomExists({
  id: roomId,
  name: 'general-chat',
  source: 'discord',
  type: ChannelType.GROUP,
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  worldId: parentWorldId,
});
```

### Retrieving Room Information

```typescript
// Get a specific room
const room = await runtime.getRoom(roomId);

// Get all rooms in a world
const worldRooms = await runtime.getRooms(worldId);
```

### Updating Room Properties

```typescript
await runtime.updateRoom({
  id: roomId,
  name: 'renamed-channel',
  metadata: {
    ...room.metadata,
    customProperty: 'value',
  },
});
```

### Deleting a Room

```typescript
await runtime.deleteRoom(roomId);
```

## Participants in Rooms

Rooms can have multiple participants (entities) that can exchange messages.

### Managing Room Participants

```typescript
// Add a participant to a room
await runtime.addParticipant(entityId, roomId);

// Remove a participant from a room
await runtime.removeParticipant(entityId, roomId);

// Get all participants in a room
const participants = await runtime.getParticipantsForRoom(roomId);

// Get all rooms where an entity is a participant
const entityRooms = await runtime.getRoomsForParticipant(entityId);
```

### Participant States

Participants can have different states in a room:

```typescript
// Get a participant's state in a room
const state = await runtime.getParticipantUserState(roomId, entityId);
// Returns: 'FOLLOWED', 'MUTED', or null

// Set a participant's state in a room
await runtime.setParticipantUserState(roomId, entityId, 'FOLLOWED');
```

The participant states are:

| State      | Description                                                                               |
| ---------- | ----------------------------------------------------------------------------------------- |
| `FOLLOWED` | The agent actively follows the conversation and responds without being directly mentioned |
| `MUTED`    | The agent ignores messages in this room                                                   |
| `null`     | Default state - the agent responds only when directly mentioned                           |

## Following and Unfollowing Rooms

ElizaOS allows agents to "follow" rooms to actively participate in conversations without being explicitly mentioned. This functionality is managed through the `FOLLOW_ROOM` and `UNFOLLOW_ROOM` actions.

```typescript
// Follow a room (typically triggered by an action)
await runtime.setParticipantUserState(roomId, runtime.agentId, 'FOLLOWED');

// Unfollow a room
await runtime.setParticipantUserState(roomId, runtime.agentId, null);
```

## Memory and Messages in Rooms

Rooms store messages as memories in the database:

```typescript
// Create a new message in a room
const messageId = await runtime.createMemory(
  {
    entityId: senderEntityId,
    agentId: runtime.agentId,
    roomId: roomId,
    content: {
      text: 'Hello, world!',
      source: 'discord',
    },
    metadata: {
      type: 'message',
    },
  },
  'messages'
);

// Retrieve recent messages from a room
const messages = await runtime.getMemories({
  roomId: roomId,
  count: 10,
  unique: true,
});
```

## Events Related to Rooms

ElizaOS emits events related to room activities:

| Event              | Description                                  |
| ------------------ | -------------------------------------------- |
| `ROOM_JOINED`      | Emitted when an entity joins a room          |
| `ROOM_LEFT`        | Emitted when an entity leaves a room         |
| `MESSAGE_RECEIVED` | Emitted when a message is received in a room |
| `MESSAGE_SENT`     | Emitted when a message is sent to a room     |

### Handling Room Events

```typescript
// Register event handlers in your plugin
const myPlugin: Plugin = {
  name: 'my-room-plugin',
  description: 'Handles room events',

  events: {
    [EventTypes.ROOM_JOINED]: [
      async (payload) => {
        const { runtime, entityId, roomId } = payload;
        console.log(`Entity ${entityId} joined room ${roomId}`);
      },
    ],

    [EventTypes.MESSAGE_RECEIVED]: [
      async (payload: MessagePayload) => {
        const { runtime, message } = payload;
        console.log(`Message received in room ${message.roomId}`);
      },
    ],
  },
};
```

## Room Connection with External Systems

When integrating with external platforms, rooms are typically mapped to channels, conversations, or other interaction spaces:

```typescript
// Ensure the connection exists for a room from an external system
await runtime.ensureConnection({
  entityId: userEntityId,
  roomId: roomId,
  userName: 'username',
  name: 'display-name',
  source: 'discord',
  channelId: 'external-channel-id',
  serverId: 'external-server-id',
  type: ChannelType.GROUP,
  worldId: parentWorldId,
});
```

## Best Practices

1. **Use appropriate room types**: Select the most appropriate room type for each interaction context
2. **Follow relationship order**: Create worlds before creating rooms, as rooms often have a parent world
3. **Use ensureRoomExists**: Use this method to avoid duplicate rooms when syncing with external systems
4. **Clean up rooms**: Delete rooms when they're no longer needed to prevent database bloat
5. **Room metadata**: Use metadata for room-specific configuration that doesn't fit into the standard properties
6. **Follow state management**: Implement clear rules for when agents should follow or unfollow rooms
7. **Handle participants carefully**: Ensure that participant management aligns with external platform behavior
`````

## File: packages/docs/docs/core/services.md
`````markdown
---
sidebar_position: 3
title: Services System
description: Understanding ElizaOS services - core components that enable AI agents to interact with external platforms
keywords: [services, platforms, integration, Discord, Twitter, Telegram, communication, API]
image: /img/services.jpg
---

# 🔌 Services

Services are core components in Eliza that enable AI agents to interact with external platforms and services. Each service provides a specialized interface for communication while maintaining consistent agent behavior across different platforms.

---

## Supported Services

| Service                                                                            | Type          | Key Features                                                                           | Use Cases                                                            |
| ---------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| [Discord](https://github.com/elizaos-plugins/plugin-discord)                       | Communication | • Voice channels • Server management • Moderation tools • Channel management           | • Community management • Gaming servers • Event coordination         |
| [Twitter](https://github.com/elizaos-plugins/plugin-twitter)                       | Social Media  | • Post scheduling • Timeline monitoring • Engagement analytics • Content automation    | • Brand management • Content creation • Social engagement            |
| [Telegram](https://github.com/elizaos-plugins/plugin-telegram)                     | Messaging     | • Bot API • Group chat • Media handling • Command system                               | • Customer support • Community engagement • Broadcast messaging      |
| [Direct](https://github.com/elizaOS/eliza/tree/develop/packages/plugin-direct/src) | API           | • REST endpoints • Web integration • Custom applications • Real-time communication     | • Backend integration • Web apps • Custom interfaces                 |
| [GitHub](https://github.com/elizaos-plugins/plugin-github)                         | Development   | • Repository management • Issue tracking • Pull requests • Code review                 | • Development workflow • Project management • Team collaboration     |
| [Slack](https://github.com/elizaos-plugins/plugin-slack)                           | Enterprise    | • Channel management • Conversation analysis • Workspace tools • Integration hooks     | • Team collaboration • Process automation • Internal tools           |
| [Lens](https://github.com/elizaos-plugins/plugin-lens)                             | Web3          | • Decentralized networking • Content publishing • Memory management • Web3 integration | • Web3 social networking • Content distribution • Decentralized apps |
| [Farcaster](https://github.com/elizaos-plugins/plugin-farcaster)                   | Web3          | • Decentralized social • Content publishing • Community engagement                     | • Web3 communities • Content creation • Social networking            |
| [Auto](https://github.com/elizaos-plugins/plugin-auto)                             | Automation    | • Workload management • Task scheduling • Process automation                           | • Background jobs • Automated tasks • System maintenance             |

**\*Additional services**:

- Instagram: Social media content and engagement
- XMTP: Web3 messaging and communications
- Alexa: Voice interface and smart device control
- Home Assistant: Home automation OS
- Devai.me: AI first social service
- Simsai: Jeeter / Social media platform for AI

---

## System Overview

Services serve as bridges between Eliza agents and various platforms, providing core capabilities:

1. **Message Processing**

   - Platform-specific message formatting and delivery
   - Media handling and attachments via [`Memory`](/api/interfaces/Memory) objects
   - Reply threading and context management
   - Support for different content types

2. **State & Memory Management**

   - Each service maintains independent state to prevent cross-platform contamination
   - Integrates with runtime memory managers for different types of content:
   - Messages processed by one service don't automatically appear in other services' contexts
   - [`State`](/api/interfaces/State) persists across agent restarts through the database adapter

3. **Platform Integration**
   - Authentication and API compliance
   - Event processing and webhooks
   - Rate limiting and cache management
   - Platform-specific feature support

## Service Configuration

Services are configured through the [`Character`](/api/type-aliases/Character) configuration's `settings` property:

```typescript
export type Character = {
  // ... other properties ...
  settings?: {
    discord?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
      shouldRespondOnlyToMentions?: boolean;
      messageSimilarityThreshold?: number;
      isPartOfTeam?: boolean;
      teamAgentIds?: string[];
      teamLeaderId?: string;
      teamMemberInterestKeywords?: string[];
      allowedChannelIds?: string[];
      autoPost?: {
        enabled?: boolean;
        monitorTime?: number;
        inactivityThreshold?: number;
        mainChannelId?: string;
        announcementChannelIds?: string[];
        minTimeBetweenPosts?: number;
      };
    };
    telegram?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
      shouldRespondOnlyToMentions?: boolean;
      shouldOnlyJoinInAllowedGroups?: boolean;
      allowedGroupIds?: string[];
      messageSimilarityThreshold?: number;
      // ... other telegram-specific settings
    };
    slack?: {
      shouldIgnoreBotMessages?: boolean;
      shouldIgnoreDirectMessages?: boolean;
    };
    // ... other service configs
  };
};
```

## Service Implementation

Each service manages its own:

- Platform-specific message formatting and delivery
- Event processing and webhooks
- Authentication and API integration
- Message queueing and rate limiting
- Media handling and attachments
- State management and persistence

Example of a basic service implementation:

```typescript
import { Service, IAgentRuntime } from '@elizaos/core';

export class CustomService extends Service {
  static serviceType = 'custom';
  capabilityDescription = 'The agent is able to interact with the custom platform';

  constructor(protected runtime: IAgentRuntime) {
    super();
    // Initialize platform connection
    // Set up event handlers
    // Configure message processing
  }

  static async start(runtime: IAgentRuntime): Promise<CustomService> {
    const service = new CustomService(runtime);
    // Additional initialization if needed
    return service;
  }

  async stop(): Promise<void> {
    // Cleanup resources
    // Close connections
  }
}
```

### Runtime Integration

Services interact with the agent runtime through the [`IAgentRuntime`](api/interfaces/IAgentRuntime/) interface, which provides:

- Memory managers for different types of data storage
- Service access for capabilities like transcription or image generation
- State management and composition
- Message processing and action handling

### Memory System Integration

Services use the runtime's memory managers to persist conversation data (source: [`memory.ts`](/api/interfaces/Memory)).

- `messageManager` Chat messages
- `documentsManager` File attachments
- `descriptionManager` Media descriptions

<details>
<summary>See example</summary>
```typescript
// Store a new message
await runtime.messageManager.createMemory({
    id: messageId,
    content: { text: message.content },
    userId: userId,
    roomId: roomId,
    agentId: runtime.agentId
});

// Retrieve recent messages
const recentMessages = await runtime.messageManager.getMemories({
roomId: roomId,
count: 10
});

```
</details>


---

## FAQ

### What can services actually do?

Services handle platform-specific communication (like Discord messages or Twitter posts), manage memories and state, and execute actions like processing media or handling commands. Each service adapts these capabilities to its platform while maintaining consistent agent behavior.

### Can multiple services be used simultaneously?
Yes, Eliza supports running multiple services concurrently while maintaining consistent agent behavior across platforms.

### How are service-specific features handled?
Each service implements platform-specific features through its capabilities system, while maintaining a consistent interface for the agent.

### How do services handle rate limits?
Services implement platform-specific rate limiting with backoff strategies and queue management.

### How is service state managed?
Services maintain their own connection state while integrating with the agent's runtime database adapter and memory / state management system.

### How do services handle messages?

Services translate platform messages into Eliza's internal format, process any attachments (images, audio, etc.), maintain conversation context, and manage response queuing and rate limits.

### How are messages processed across services?
Each service processes messages independently in its platform-specific format, while maintaining conversation context through the shared memory system. V2 improves upon this architecture.

### How is state managed between services?
Each service maintains separate state to prevent cross-contamination, but can access shared agent state through the runtime.


### How do services integrate with platforms?

Each service implements platform-specific authentication, API compliance, webhook handling, and follows the platform's rules for rate limiting and content formatting.

### How do services manage memory?

Services use Eliza's memory system to track conversations, user relationships, and state, enabling context-aware responses and persistent interactions across sessions.
```
`````

## File: packages/docs/docs/core/tasks.md
`````markdown
---
sidebar_position: 9
title: Tasks System
description: Understanding ElizaOS tasks - managing deferred, scheduled, and interactive operations
keywords: [tasks, scheduling, automation, workers, recurring tasks, task management]
image: /img/tasks.jpg
---

# Tasks

Tasks in ElizaOS provide a powerful way to manage deferred, scheduled, and interactive operations. The Task system allows agents to queue work for later execution, repeat actions at defined intervals, await user input, and implement complex workflows across multiple interactions.

## Task Structure

A task in ElizaOS has the following properties:

```typescript
interface Task {
  id?: UUID; // Unique identifier (auto-generated if not provided)
  name: string; // Name of the task (must match a registered task worker)
  updatedAt?: number; // Timestamp when the task was last updated
  metadata?: {
    // Optional additional configuration
    updateInterval?: number; // For repeating tasks: milliseconds between executions
    options?: {
      // For choice tasks: options for user selection
      name: string;
      description: string;
    }[];
    [key: string]: unknown; // Additional custom metadata
  };
  description: string; // Human-readable description of the task
  roomId?: UUID; // Optional room association (for room-specific tasks)
  worldId?: UUID; // Optional world association (for world-specific tasks)
  tags: string[]; // Tags for categorizing and filtering tasks
}
```

## Task Workers

Task workers define the actual logic that executes when a task runs. Each task worker is registered with the runtime and is identified by name.

```typescript
interface TaskWorker {
  name: string; // Matches the name in the Task
  execute: (
    runtime: IAgentRuntime,
    options: { [key: string]: unknown }, // Options passed during execution
    task: Task // The task being executed
  ) => Promise<void>;
  validate?: (
    // Optional validation before execution
    runtime: IAgentRuntime,
    message: Memory,
    state: State
  ) => Promise<boolean>;
}
```

## Creating and Managing Tasks

### Registering a Task Worker

Before creating tasks, you must register a worker to handle the execution:

```typescript
runtime.registerTaskWorker({
  name: 'SEND_REMINDER',
  validate: async (runtime, message, state) => {
    // Optional validation logic
    return true;
  },
  execute: async (runtime, options, task) => {
    // Task execution logic
    const { roomId } = task;
    const { reminder, userId } = options;

    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `Reminder for <@${userId}>: ${reminder}`,
        },
      },
      'messages'
    );

    // Delete the task after it's completed
    await runtime.deleteTask(task.id);
  },
});
```

### Creating a One-time Task

Create a task that will execute once:

```typescript
await runtime.createTask({
  name: 'SEND_REMINDER',
  description: 'Send a reminder message to the user',
  roomId: currentRoomId,
  tags: ['reminder', 'one-time'],
  metadata: {
    userId: message.entityId,
    reminder: 'Submit your weekly report',
    scheduledFor: Date.now() + 86400000, // 24 hours from now
  },
});
```

### Creating a Recurring Task

Create a task that repeats at regular intervals:

```typescript
await runtime.createTask({
  name: 'DAILY_REPORT',
  description: 'Generate and post the daily report',
  roomId: announcementChannelId,
  worldId: serverWorldId,
  tags: ['report', 'repeat', 'daily'],
  metadata: {
    updateInterval: 86400000, // 24 hours in milliseconds
    updatedAt: Date.now(), // When the task was last updated/executed
  },
});
```

### Creating a Task Awaiting User Choice

Create a task that presents options and waits for user input:

```typescript
await runtime.createTask({
  name: 'CONFIRM_ACTION',
  description: 'Confirm the requested action',
  roomId: message.roomId,
  tags: ['confirmation', 'AWAITING_CHOICE'],
  metadata: {
    options: [
      { name: 'confirm', description: 'Proceed with the action' },
      { name: 'cancel', description: 'Cancel the action' },
    ],
    action: 'DELETE_FILES',
    files: ['document1.txt', 'document2.txt'],
  },
});
```

### Managing Tasks

Retrieve, update, and delete tasks as needed:

```typescript
// Get tasks by specific criteria
const reminderTasks = await runtime.getTasks({
  roomId: currentRoomId,
  tags: ['reminder'],
});

// Get tasks by name
const reportTasks = await runtime.getTasksByName('DAILY_REPORT');

// Get a specific task
const task = await runtime.getTask(taskId);

// Update a task
await runtime.updateTask(taskId, {
  description: 'Updated description',
  metadata: {
    ...task.metadata,
    priority: 'high',
  },
});

// Delete a task
await runtime.deleteTask(taskId);
```

## Task Processing

Tasks are processed based on their configuration:

### One-time Tasks

Tasks without an `updateInterval` are executed once when triggered by your code. You are responsible for scheduling their execution by checking for pending tasks in appropriate contexts.

### Recurring Tasks

Tasks with an `updateInterval` are automatically considered for re-execution when:

1. The current time exceeds `updatedAt + updateInterval`
2. Your code explicitly checks for pending recurring tasks

To process recurring tasks, implement logic like this:

```typescript
// In an initialization function or periodic check
async function processRecurringTasks() {
  const now = Date.now();
  const recurringTasks = await runtime.getTasks({
    tags: ['repeat'],
  });

  for (const task of recurringTasks) {
    if (!task.metadata?.updateInterval) continue;

    const lastUpdate = task.metadata.updatedAt || 0;
    const interval = task.metadata.updateInterval;

    if (now >= lastUpdate + interval) {
      const worker = runtime.getTaskWorker(task.name);
      if (worker) {
        try {
          await worker.execute(runtime, {}, task);

          // Update the task's last update time
          await runtime.updateTask(task.id, {
            metadata: {
              ...task.metadata,
              updatedAt: now,
            },
          });
        } catch (error) {
          logger.error(`Error executing task ${task.name}: ${error}`);
        }
      }
    }
  }
}
```

### Tasks Awaiting User Input

Tasks tagged with `AWAITING_CHOICE` are presented to users and wait for their input. These tasks use:

1. The `choice` provider to display available options to users
2. The `CHOOSE_OPTION` action to process user selections

## Common Task Patterns

### Deferred Follow-ups

Create a task to follow up with a user later:

```typescript
runtime.registerTaskWorker({
  name: 'FOLLOW_UP',
  execute: async (runtime, options, task) => {
    const { roomId } = task;
    const { userId, topic } = task.metadata;

    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `Hi <@${userId}>, I'm following up about ${topic}. Do you have any updates?`,
        },
      },
      'messages'
    );

    await runtime.deleteTask(task.id);
  },
});

// Create a follow-up task for 2 days later
await runtime.createTask({
  name: 'FOLLOW_UP',
  description: 'Follow up with user about project status',
  roomId: message.roomId,
  tags: ['follow-up', 'one-time'],
  metadata: {
    userId: message.entityId,
    topic: 'the project timeline',
    scheduledFor: Date.now() + 2 * 86400000, // 2 days
  },
});
```

### Multi-step Workflows

Implement complex workflows that span multiple interactions:

```typescript
// First step: Gather requirements
runtime.registerTaskWorker({
  name: 'GATHER_REQUIREMENTS',
  execute: async (runtime, options, task) => {
    // Ask user for requirements and create a new task for the next step
    await runtime.createTask({
      name: 'CONFIRM_REQUIREMENTS',
      description: 'Confirm gathered requirements',
      roomId: task.roomId,
      tags: ['workflow', 'AWAITING_CHOICE'],
      metadata: {
        previousStep: 'GATHER_REQUIREMENTS',
        requirements: options.requirements,
        options: [
          { name: 'confirm', description: 'Confirm requirements are correct' },
          { name: 'revise', description: 'Need to revise requirements' },
        ],
      },
    });

    await runtime.deleteTask(task.id);
  },
});

// Second step: Confirm requirements
runtime.registerTaskWorker({
  name: 'CONFIRM_REQUIREMENTS',
  execute: async (runtime, options, task) => {
    if (options.option === 'confirm') {
      // Move to the next step
      await runtime.createTask({
        name: 'GENERATE_SOLUTION',
        description: 'Generate solution based on requirements',
        roomId: task.roomId,
        tags: ['workflow'],
        metadata: {
          previousStep: 'CONFIRM_REQUIREMENTS',
          requirements: task.metadata.requirements,
        },
      });
    } else {
      // Go back to requirements gathering
      await runtime.createTask({
        name: 'GATHER_REQUIREMENTS',
        description: 'Revise requirements',
        roomId: task.roomId,
        tags: ['workflow'],
        metadata: {
          previousStep: 'CONFIRM_REQUIREMENTS',
          previousRequirements: task.metadata.requirements,
        },
      });
    }

    await runtime.deleteTask(task.id);
  },
});
```

### Scheduled Reports

Create tasks that generate and post reports on a schedule:

```typescript
runtime.registerTaskWorker({
  name: 'GENERATE_WEEKLY_REPORT',
  execute: async (runtime, options, task) => {
    const { roomId } = task;

    // Generate report content
    const reportData = await generateWeeklyReport(runtime);

    // Post the report
    await runtime.createMemory(
      {
        entityId: runtime.agentId,
        roomId,
        content: {
          text: `# Weekly Report\n\n${reportData}`,
        },
      },
      'messages'
    );

    // The task stays active for next week (updateInterval handles timing)
  },
});

// Create a weekly report task
await runtime.createTask({
  name: 'GENERATE_WEEKLY_REPORT',
  description: 'Generate and post weekly activity report',
  roomId: reportChannelId,
  worldId: serverWorldId,
  tags: ['report', 'repeat', 'weekly'],
  metadata: {
    updateInterval: 7 * 86400000, // 7 days
    updatedAt: Date.now(),
    format: 'markdown',
  },
});
```

## Task Events and Monitoring

ElizaOS doesn't currently provide built-in events for task lifecycle, so implement your own monitoring if needed:

```typescript
// Custom monitoring for task execution
async function executeTaskWithMonitoring(runtime, taskWorker, task) {
  try {
    // Create a start log
    await runtime.log({
      body: { taskId: task.id, action: 'start' },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });

    // Execute the task
    await taskWorker.execute(runtime, {}, task);

    // Create a completion log
    await runtime.log({
      body: { taskId: task.id, action: 'complete', success: true },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });
  } catch (error) {
    // Create an error log
    await runtime.log({
      body: { taskId: task.id, action: 'error', error: error.message },
      entityId: runtime.agentId,
      roomId: task.roomId,
      type: 'TASK_EXECUTION',
    });
  }
}
```

## Best Practices

1. **Use descriptive names and descriptions**: Make tasks easily identifiable with clear names and descriptions

2. **Clean up completed tasks**: Delete one-time tasks after execution to prevent database bloat

3. **Add error handling**: Implement robust error handling in task workers to prevent failures from breaking workflows

4. **Use appropriate tags**: Tag tasks effectively for easy retrieval and categorization

5. **Validate carefully**: Use the `validate` function to ensure tasks only execute in appropriate contexts

6. **Keep tasks atomic**: Design tasks to perform specific, well-defined operations rather than complex actions

7. **Provide clear choices**: When creating choice tasks, make option names and descriptions clear and unambiguous

8. **Manage task lifecycles**: Have a clear strategy for when tasks are created, updated, and deleted

9. **Set reasonable intervals**: For recurring tasks, choose appropriate update intervals that balance timeliness and resource usage

10. **Handle concurrent execution**: Ensure task execution is idempotent to handle potential concurrent executions
`````

## File: packages/docs/docs/core/worlds.md
`````markdown
---
sidebar_position: 7
title: World System
description: Understanding ElizaOS worlds - virtual spaces for agent interactions and communication
keywords: [worlds, environments, spaces, rooms, entities, roles, permissions, events]
image: /img/elizaos-worlds-cosmic-clean.svg
---

# Worlds

Worlds in ElizaOS are collections of entities (users, agents) and rooms (conversations, channels) that form a cohesive environment for interactions. Think of a world as a virtual space, like a Discord server, Slack workspace, or 3D MMO environment, where entities can communicate across multiple channels or areas.

![](/img/elizaos-worlds-cosmic-clean.svg)

Within each world you can have rooms, which are akin to individual threads or channels in a server.

![](/img/elizaos-worlds-simplified.svg)

## World Structure

A world in ElizaOS has the following properties:

```typescript
type World = {
  id: UUID;
  name?: string;
  agentId: UUID;
  serverId: string;
  metadata?: {
    ownership?: {
      ownerId: string;
    };
    roles?: {
      [entityId: UUID]: Role;
    };
    [key: string]: unknown;
  };
};
```

| Property   | Description                                          |
| ---------- | ---------------------------------------------------- |
| `id`       | Unique identifier for the world                      |
| `name`     | Optional display name                                |
| `agentId`  | ID of the agent managing this world                  |
| `serverId` | External system identifier (e.g., Discord server ID) |
| `metadata` | Additional world configuration data                  |

The metadata can store custom information, including ownership details and role assignments for entities within the world.

## World Creation and Management

### Creating a World

You can create a new world using the AgentRuntime:

```typescript
const worldId = await runtime.createWorld({
  name: 'My Project Space',
  agentId: runtime.agentId,
  serverId: 'external-system-id',
  metadata: {
    ownership: {
      ownerId: ownerEntityId,
    },
  },
});
```

For many integrations, worlds are automatically created during connection setup with external platforms like Discord or Slack.

### Ensuring a World Exists

If you're not sure if a world exists, you can use `ensureWorldExists()`:

```typescript
await runtime.ensureWorldExists({
  id: worldId,
  name: 'My Project Space',
  agentId: runtime.agentId,
  serverId: 'external-system-id',
});
```

### Retrieving World Information

```typescript
// Get a specific world
const world = await runtime.getWorld(worldId);

// Get all worlds
const allWorlds = await runtime.getAllWorlds();
```

### Updating World Properties

```typescript
await runtime.updateWorld({
  id: worldId,
  name: 'Updated Name',
  metadata: {
    ...world.metadata,
    customProperty: 'value',
  },
});
```

## World Roles System

Worlds support a role-based permission system with the following roles:

| Role    | Description                                           |
| ------- | ----------------------------------------------------- |
| `OWNER` | Full control over the world, can assign any roles     |
| `ADMIN` | Administrative capabilities, can manage most settings |
| `NONE`  | Standard participant with no special permissions      |

### Managing Roles

Roles are stored in the world's metadata and can be updated:

```typescript
// Get existing world
const world = await runtime.getWorld(worldId);

// Ensure roles object exists
if (!world.metadata) world.metadata = {};
if (!world.metadata.roles) world.metadata.roles = {};

// Assign a role to an entity
world.metadata.roles[entityId] = Role.ADMIN;

// Save the world
await runtime.updateWorld(world);
```

For programmatic role management, you can use role-related utilities:

```typescript
import { canModifyRole, findWorldForOwner } from '@elizaos/core';

// Check if user can modify roles
if (canModifyRole(userRole, targetRole, newRole)) {
  // Allow role change
}

// Find world where user is owner
const userWorld = await findWorldForOwner(runtime, entityId);
```

## World Settings

Worlds support configurable settings that can be stored and retrieved:

```typescript
// Get settings for a world
const worldSettings = await getWorldSettings(runtime, serverId);

// Update world settings
worldSettings.MY_SETTING = {
  name: 'My Setting',
  description: 'Description for users',
  value: 'setting-value',
  required: false,
};

// Save settings
await updateWorldSettings(runtime, serverId, worldSettings);
```

## World Events

ElizaOS emits events related to world activities:

| Event             | Description                                    |
| ----------------- | ---------------------------------------------- |
| `WORLD_JOINED`    | Emitted when an agent joins a world            |
| `WORLD_CONNECTED` | Emitted when a world is successfully connected |
| `WORLD_LEFT`      | Emitted when an agent leaves a world           |

### Handling World Events

```typescript
// Register event handlers in your plugin
const myPlugin: Plugin = {
  name: 'my-world-plugin',
  description: 'Handles world events',

  events: {
    [EventTypes.WORLD_JOINED]: [
      async (payload: WorldPayload) => {
        const { world, runtime } = payload;
        console.log(`Joined world: ${world.name}`);
      },
    ],

    [EventTypes.WORLD_LEFT]: [
      async (payload: WorldPayload) => {
        const { world, runtime } = payload;
        console.log(`Left world: ${world.name}`);
      },
    ],
  },
};
```

## Relationship with Rooms

A world contains multiple rooms that entities can interact in. Each room points back to its parent world via the `worldId` property.

```typescript
// Get all rooms in a world
const worldRooms = await runtime.getRooms(worldId);
```

See the [Rooms](./rooms.md) documentation for more details on managing rooms within worlds.

## Best Practices

1. **Always check permissions**: Before performing administrative actions, verify the user has appropriate roles
2. **Handle world metadata carefully**: The metadata object can contain critical configuration, so modify it with care
3. **World-room syncing**: When syncing with external platforms, keep world and room structures in alignment
4. **Event-driven architecture**: Use events to respond to world changes rather than polling for updates
5. **Default settings**: Provide sensible defaults for world settings to make configuration easier
`````

## File: packages/docs/docs/intro.md
`````markdown
---
sidebar_position: 1
title: Introduction to Eliza
description: A powerful multi-agent simulation framework for creating and managing autonomous AI agents
keywords:
  [
    introduction,
    AI agents,
    multi-agent,
    framework,
    TypeScript,
    autonomous agents,
    simulation,
    RAG,
    plugins,
  ]
image: /img/eliza_banner.jpg
---

# Introduction to Eliza

![](/img/eliza_banner.jpg)
_As seen powering [@DegenSpartanAI](https://x.com/degenspartanai) and [@aixvc_agent](https://x.com/aixvc_agent)_

## What is Eliza?

Eliza is a powerful multi-agent simulation framework designed to create, deploy, and manage autonomous AI agents. Built with TypeScript, it provides a flexible and extensible platform for developing intelligent agents that can interact across multiple platforms while maintaining consistent personalities and knowledge.

> Pro tip: copy paste the text from https://eliza.how/llms-full.txt into your preferred LLM.

## Key Features

New in the Eliza v2 beta!

| CLI Tool                          | Native GUI                        |
| --------------------------------- | --------------------------------- |
| [![](/img/cli.jpg)](/img/cli.jpg) | [![](/img/gui.jpg)](/img/gui.jpg) |

- **Platform Integration**: Clients for Discord, X (Twitter), Telegram, and many others
- **Flexible Model Support**: Deepseek, Ollama, Grok, OpenAI, Anthropic, Gemini, LLama, etc.
- **Character System**: Create diverse agents using [character files](https://github.com/elizaOS/characterfile)
- **Multi-Agent Architecture**: Manage multiple unique AI personalities simultaneously
- **Memory Management**: Easily ingest and interact with documents using RAG
- **Media Processing**: PDF, URLs, Audio transcription, Video processing, Image analysis, Conversation summarization
- **Technical Foundation**:
  - 100% TypeScript implementation
  - Modular architecture
  - Highly extensible action and plugin system
  - Custom client support
  - Comprehensive API

---

## Installation

For detailed instructions on each path, including configuration options and extended capabilities, see our [Quickstart Guide](./quickstart.md).

### Prerequisites

- [Node.js 23+](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
- Git for version control
- For Windows Users: [WSL 2](https://learn.microsoft.com/en-us/windows/wsl/install-manual) is required

Eliza offers different paths depending on your goals:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="cli" label="Install CLI Tool (Recommended)" default>

```bash
# Install the CLI globally
npm install -g @elizaos/cli@beta # will be simpler after beta

# From a folder to install a project
elizaos create
cd new-agent
elizaos start
```

Then visit https://localhost:3000 to interact with your agent through a web interface.

  </TabItem>
  <TabItem value="project" label="Create a Test Project">

```bash
# Create a new project through interactive setup
elizaos create # will be simpler after beta

# Navigate to your project directory
cd my-project-name

# Start your project
elizaos start
```

  </TabItem>
  <TabItem value="plugin" label="Add a Custom Plugin">

Add plugins to your project:

```bash
# List available plugins
elizaos project list-plugins

# Add a plugin
elizaos project add-plugin @elizaos/plugin-discord

# Create a plugin project
elizaos create --type plugin
```

Develop and test your plugin:

```bash
# Test your plugin
elizaos start

# Publish your plugin when ready
elizaos plugin publish
```

  </TabItem>
  <TabItem value="contribute" label="Contribute to ElizaOS Core">

```bash
# Clone the repository
git clone git@github.com:elizaOS/eliza.git
cd eliza

# We are currently on the v2-develop branch
git checkout v2-develop

# Install dependencies and build
bun install
bun run build

# Start ElizaOS
bun start
```

Visit https://localhost:3000 to interact with your agent through a web interface.

  </TabItem>
</Tabs>

> If it fails the first time try the start command again

---

## Community and Support

Eliza is backed by an active community of developers and users:

- [**Open Source**](https://github.com/elizaos/eliza): Contribute to the project on GitHub
- [**Technical Report (Whitepaper)**](https://arxiv.org/pdf/2501.06781)
- [**Awesome Eliza**](https://github.com/elizaos/awesome-eliza)
- [**Examples**](https://github.com/elizaos/characters): Ready-to-use character templates and implementations
- [**Support**](https://discord.gg/elizaos): Active community for troubleshooting and discussion

Join us in building the future of autonomous AI agents with Eliza!
`````

## File: packages/docs/docs/quickstart.md
`````markdown
---
sidebar_position: 2
title: Quickstart Guide
description: Get started quickly with ElizaOS - from installation to running your first AI agent
keywords:
  [quickstart, installation, setup, configuration, CLI, agents, plugins, development, deployment]
image: /img/eliza_banner.jpg
---

# Quickstart Guide

## Prerequisites

- [Node.js 23+](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
- Git for version control
- For Windows Users: [WSL 2](https://learn.microsoft.com/en-us/windows/wsl/install-manual) is required

## Installation

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="global" label="Install Globally (Recommended)" default>

```bash
# Install globally
npm install -g @elizaos/cli@beta
# Start ElizaOS
elizaos start
```

  </TabItem>
  <TabItem value="npx" label="Test with NPX">

```bash
# Use directly with npx
elizaos start
```

  </TabItem>
  <TabItem value="source" label="Install from Source">

```bash
# Clone the repository
git clone git@github.com:elizaOS/eliza.git
cd eliza

# Switch to development branch
git checkout v2-develop

# Install dependencies
bun install

# Build the project
bun run build

# Start ElizaOS
bun start
```

  </TabItem>
</Tabs>

This will:

1. Start ElizaOS with default settings
2. Load the default character
3. Make the agent accessible via terminal and REST API

> **Note:** If you encounter any errors on first startup, try running the start command again. The initial startup sometimes needs a second attempt to properly initialize all components.

### Chat with your agent:

Visit https://localhost:3000 to interact with your agent through a web interface.

## 2. Creating a Project

If you want to create a custom ElizaOS project with your own characters and configurations:

```bash
# Create a new project with the interactive wizard
elizaos create
# Or specify project type directly
elizaos create --type project
```

Follow the interactive prompts to configure your project. Once created:

```bash
# Navigate to your project directory
cd my-project-name
# Start your project
elizaos start
```

> If it fails the first time try the start command again

### Project Structure

A typical ElizaOS project structure looks like this:

```
my-project/
├── src/
│   └── index.ts      # Main entry point with character definitions
├── knowledge/        # Knowledge files for RAG
├── package.json      # Project configuration and dependencies
└── tsconfig.json     # TypeScript configuration
```

The character definition is located in `src/index.ts` where you can modify the agent's personality, plugins, and settings. This is the core file for customizing your agent's behavior.

### Add plugins to your project:

```bash
# List available plugins
elizaos project list-plugins
# Add a plugin
elizaos project add-plugin @elizaos/plugin-discord
```

### Working with Character Files

You can import or export character files using the CLI:

```bash
# Export character to a JSON file
elizaos character export --output my-character.json

# Import character from a JSON file
elizaos character import --file my-character.json
```

This is particularly useful for those migrating from v1 who are used to working with standalone character files.

## 3. Creating a Plugin

Want to extend ElizaOS with custom functionality?

```bash
# Create a new plugin project
elizaos create --type plugin
```

Develop your plugin following the structure in your generated project:

```bash
# Test your plugin
elizaos start
# Publish your plugin when ready
elizaos plugin publish
```

### Publishing options:

```bash
# Test publish without making changes
elizaos plugin publish --test
# Publish to npm
elizaos plugin publish --npm
# Specify platform compatibility
elizaos plugin publish --platform node
```

---

## Troubleshooting

### Node Version

- Use Node.js 23.3.0+ (`node -v` to check)
- Try using NVM: `nvm use 23`

### Installation Problems

```bash
# Clean and reinstall
bun clean
bun install --no-frozen-lockfile
bun build
```

### Plugin Issues

```bash
# Rebuild problematic packages
bun rebuild better-sqlite3
```

### Docker Issues

```bash
# Clean up Docker environment
docker rmi -f $(docker images -aq)
docker builder prune -a -f
```

### First-time Startup Issues

If your agent fails to start on the first attempt:

- Run the start command again
- Check logs for specific errors
- Ensure all dependencies are properly installed
- Verify that your database configuration is correct

---

## Next Steps

Once you have your agent running, explore:

- 🤖 [Understand Agents](./core/agents.md)
- ⚡ [Add Custom Actions](./core/actions.md)
- 🧠 [Configure Knowledge](./core/knowledge.md)
- 🔌 [Add Services](./core/services.md)

Join the [Discord community](https://discord.gg/elizaOS) for support and to share what you're building!
`````

## File: packages/docs/news/2025-03-22.md
`````markdown
# Daily Report - 2025-03-22

## Recent Fixes and Improvements

- **CLI Agent Commands**: Fixed issues with starting, stopping, listing, retrieving details, and removing agents.  
  [Source](https://github.com/elizaOS/eliza/pull/4028)
- **Profile Overflow**: Resolved an issue causing profile overflows.  
  [Source](https://github.com/elizaOS/eliza/pull/4025)
- **OpenAI STT Fix**: Speech-to-text now works in GUI and Discord by switching to a file-based approach.  
  [Source](https://github.com/elizaOS/eliza/pull/4017)
- **Grid Layout**: Adjusted grid size for better consistency.  
  [Source](https://github.com/elizaOS/eliza/pull/4015)
- **Profile Picture Display**: Fixed issues in group chats.  
  [Source](https://github.com/elizaOS/eliza/pull/4008)
- **UX Enhancements**: Improved validation for PostgreSQL URLs in start and create commands.  
  [Source](https://github.com/elizaOS/eliza/pull/4007)
- **CLI and Plugin Fixes**: Fixed `start --character` parameter, improved Solana plugin, and enhanced error logging.  
  [Source](https://github.com/elizaOS/eliza/pull/4016)
- **Template Variable Fix**: Corrected `twitterPostTemplate` variable inconsistency.  
  [Source](https://github.com/elizaOS/eliza/pull/4029)

## Analysis of Discord Chat Transcripts

- No significant technical discussions or decisions.
- Mostly casual banter, jokes, or off-topic conversations.
- One transcript mentioned blog quality but lacked technical details.  
  [Sources](https://discord.com/channels/1253563208833433701/1326603270893867064)

## Recent Enhancements

- **maxStack Reintroduced**: Improved stack management.  
  [Source](https://github.com/elizaOS/eliza/pull/4014)
- **Stack Improvements**: Enhanced functionality and appearance.  
  [Source](https://github.com/elizaOS/eliza/pull/4010)
- **Memory Viewer**: Improved visualization for better clarity.  
  [Source](https://github.com/elizaOS/eliza/pull/4027)
- **Profile UI**: Enhanced layout and user experience.  
  [Source](https://github.com/elizaOS/eliza/pull/4021)

## Documentation Updates

- **README.md Update**: Improved documentation and contributor instructions.  
  [Source](https://github.com/elizaOS/eliza/pull/4006)
- **Refactor**: Removed unneeded submodules and workflows.  
  [Source](https://github.com/elizaOS/eliza/pull/4019)
- **Quickstart Guide**: Updated `intro.md` for better clarity.  
  [Source](https://github.com/elizaOS/eliza/pull/4005)

## Repository Changes

- **Agent Status Management**: Updated handling within groups and removed group thumbnails.  
  [Source](https://github.com/elizaOS/eliza/pull/4012)
- **Submodule Removal**: Removed the characters submodule for better maintainability.  
  [Source](https://github.com/elizaOS/eliza/pull/4018)

## Reported Issues

- **Ollama Response Parsing**: Fails due to invalid JSON response.  
  [Source](https://github.com/elizaOS/eliza/issues/4024)
- **Agent List Fetch Failure**: `npx elizaos agent list` fails due to a fetch error.  
  [Source](https://github.com/elizaOS/eliza/issues/4022)

## Client Build Versioning Issue

- Versioning is one step behind due to build process order.
- Needs adjustment to follow: versioning → building → publishing.  
  [Sources](https://github.com/elizaOS/eliza/issues/4009)

## Crypto Market Update

- **Wrapped Bitcoin (WBTC)**: $83,913.50
- **ai16z**: $0.1969

## Development and Discussions Summary

- **Discord Discussions**: Mostly speculative crypto trading, minimal technical discussions.  
  [Source](https://discord.com/channels/1253563208833433701/1299989396874854440)
- **Technical Topics**: AI agent behavior, plugin loading, Node.js mismatches, and LLM provider issues.  
  [Source](https://discord.com/channels/1253563208833433701/1300025221834739744)
- **Merged PRs**: Fixes for profile overflow, OpenAI STT, grid size, and stack improvements.  
  [Sources](https://github.com/elizaOS/eliza/pull/4025)
- **Bug Reports**: Issues with Ollama response parsing, client versioning, and agent list fetch failures.  
  [Sources](https://github.com/elizaOS/eliza/issues/4024)
- **Development Focus**: CLI plugin installation, template variable fixes, and submodule removals.  
  [Sources](https://github.com/elizaOS/eliza/pull/4031)
`````

## File: packages/docs/news/2025-03-28.md
`````markdown
# Daily Report - 2025-03-28

## 1. Analysis of Discord Chat Activity on Solana Meme Tokens and Technical Engagement

### 1.1 Inactive Chat Segment

- All messages from a single user ([Captain Hook]) were empty or repeated.
- No technical discussions, questions, or action items.
- No engagement or substantive content.

### 1.2 Active Chat on Solana Meme Tokens

- Focused on real-time tracking of Solana-based meme tokens, especially on pump.fun.
- Key contributors: elvisgan, Rick, magicyte, shooter.rcj.
- Notable tokens discussed:
  - Abstract Pepe (abpepe/SOL): rapid rise in popularity.
  - DOUGH/SOL: bullish sentiment due to locked supply and DEX payment.
- Rick bot used for:
  - Real-time token data.
  - DEX status and market cap updates via `.cc` and `.dp` commands.

### 1.3 Community Engagement and Action Items

- Activities included:
  - Confirming Twitter Spaces for promotion.
  - Sharing alt-token addresses.
  - Flagging whale activity and volume spikes.
- No protocol-level development discussed.
- Proposed action items:
  - Enhance Rick bot (e.g., whale alerts, alt-token support).
  - Improve documentation.
  - Add features like Twitter Spaces integration and roadmap tracking.

## 2. Advancements in AI-Generated Imagery and Decentralized Reputation Systems in Eliza Ecosystem

### 2.1 AI-Generated Imagery with GPT-4o

- GPT-4o simplifies multi-character scene generation (e.g., Eliza and Marc).
- Replaces complex workflows involving:
  - ControlNet
  - IP-Adapter
  - LoRA models
  - ComfyUI
- Limitations:
  - Struggles with scenes involving more than five characters.
- Speculation:
  - GPT-4o may use a ComfyUI-like backend with advanced prompt translation.

### 2.2 Open-Source Alternatives and Action Items

- Community interest in replicating GPT-4o’s capabilities.
- Proposed actions:
  - Benchmark GPT-4o vs. traditional pipelines.
  - Improve multi-character handling.
  - Develop documentation and UX layers for tools like ComfyUI.

### 2.3 Decentralized Reputation System

- Proposed by doriand0963:
  - Inspired by neural networks.
  - Context-aware, fluid, and partially obscured reputation.
- vincentpaul8 emphasized:
  - Embedding alignment logic to reflect community values.

### 2.4 Eliza Studios and Auto.fun Launchpad

- Both platforms confirmed live and functional.
- Issues:
  - Confusion around countdown timer.
- Suggestions:
  - Improve real-time status indicators.
  - Enhance documentation.
  - Integrate blog and governance content.

## 3. Crypto Market Overview

### 3.1 Token Prices

- Wrapped Bitcoin (WBTC): $87,067.89
- ai16z: $0.1989
- Highlights the valuation range in the crypto ecosystem.

## 4. Community Discussions Summary

### 4.1 Inactive Chat Segment

- Repeated, empty messages from [Captain Hook].
- No technical content or engagement.

### 4.2 Solana Meme Token Tracking

- Real-time monitoring of pump.fun tokens.
- Key tokens: abpepe/SOL, DOUGH/SOL.
- Tools: Rick bot for performance tracking.
- Action items:
  - Enhance bot features.
  - Improve documentation.
  - Integrate external alpha sources.

### 4.3 ElizaOS Technical Troubleshooting

- Issues encountered:
  - Module import errors.
  - Duplicate agent responses.
  - Plugin version mismatches.
- Community support provided.
- Action items:
  - Fix runtime errors.
  - Improve plugin support.
  - Update documentation.

### 4.4 AI Image Generation with GPT-4o

- Simplifies workflows for multi-character scenes.
- Replaces complex toolchains.
- Action items:
  - Benchmarking.
  - Documentation improvements.
  - UX development for existing tools.

### 4.5 Decentralized Reputation and Platform Launches

- Reputation system inspired by neural networks.
- Eliza Studios and Auto.fun launchpad confirmed live.
- Action items:
  - Design and implement reputation system.
  - Improve site documentation.
  - Add real-time indicators and feedback tools.
`````

## File: packages/docs/news/2025-03-29.md
`````markdown
# Daily Report - 2025-03-29

## 1. Discord Community Technical Support and Activity

### Key Issues Discussed

- Troubleshooting ElizaOS AI agent setup
- Common technical problems:
  - Plugin import errors (e.g., `eventemitter3` CommonJS/ESM incompatibility)
  - Database configuration issues (Postgres auth, Docker loops)
  - Discord plugin login failures (invalid tokens)
  - Twitter client behavior (excessive tweeting, no replies)

### Workarounds & Solutions

- Import workaround for `eventemitter3` using default export and destructuring
- Temporary switch to SQLite for database issues
- Updated CLI instructions provided by community member `dankvr`
- Use of WSL2 for Windows setup issues

### Community Support & Action Items

- Contributors: `dankvr`, `rchak007`
- Proposed improvements:
  - Plugin compatibility and discovery
  - Enhanced documentation
  - Twitter client behavior fixes
  - `.env` validation and plugin status commands

### Non-Technical Segments

- Unanalyzable content:
  - Repeated mentions of `[Captain Hook]` with no messages
  - Mirror.xyz article shared without context

## 2. Community Insights: ai16z and Solana-Based Tokens

### Token Tracking & Tools

- Active monitoring of Solana-based meme/microcap tokens
- Use of Rick’s bot for:
  - Live price/volume updates
  - Momentum detection
  - Entry/exit point identification

### ai16z Token & Auto.fun Launchpad

- Confusion over ai16z as native token
  - Clarified: Not native, but SOL auto-buys ai16z
  - Value accrual mechanism confirmed
- Launchpad timeline:
  - Misunderstanding about March deadline
  - Clarified by `magicyte`: April launch, beta already live

### Community Proposals

- Vesting models for community coins
- Whale activity and influencer tracking
- Transparency improvements:
  - Dual-track documentation (technical vs. non-technical)
  - Use of LLMs (e.g., ChatGPT) for simplification
  - Structured community model with feedback loops

### Action Items

- Finalize ai16z launchpad
- Clarify tokenomics
- Enhance Rick bot (whale alerts, sentiment analysis, utility tags)

## 3. ElizaOS Plugin Development Enhancements

### Plugin Publishing Improvements

- PR: `Eli2 107/fix plugin publishing`
- Key updates:
  - Dynamic plugin naming
  - Enhanced templates with metadata/assets
  - Validation checks for registry compliance
  - Improved logging and error messages
  - Guided prompts and visual console output

### Telegram Onboarding (WIP)

- PR: `fix: tg onboard -WIP`
- Status: Work-in-progress, limited details

## 4. ElizaOS Testing Framework Enhancements

### UI Testing with Playwright

- PR: `#4092`
- Features:
  - Automated browser-based tests
  - Cross-browser support
  - Headless/headed modes
  - Helper utilities for consistency
  - Extensive documentation

### Component Testing

- PR: `#4090`
- Targets:
  - `CommunityManager`
  - `SocialManager`
- Fully implemented, no production code changes

## 5. Test Coverage Improvements

### Project-Starter Package

- PR: `#4089`
- 13 test files added covering:
  - Actions, models, config, env, errors
  - Events, file structure, integration, plugins
  - Providers, routes, testing infrastructure
- Executable via `npm test`

### Plugin-EVM Bug Fix

- PR: `#4093`
- Fixes failing test cases
- No production code or documentation changes

## 6. Crypto Market Overview

### Token Prices (as of 2025-03-29)

- Wrapped Bitcoin (WBTC): $84,254.22
- ai16z: $0.1787

## 7. ElizaOS Ecosystem Summary

### Development Highlights

- Plugin infrastructure improvements
- UI testing with Playwright
- Expanded test coverage across packages
- Telegram onboarding (WIP)
- Windows build issue due to missing bash support

### Community Engagement

- Discord discussions on:
  - ai16z tokenomics and Auto.fun integration
  - Plugin setup and integration issues
  - Solana token trading and bot enhancements
- Documentation and onboarding proposals
- Non-technical chat segments identified but not actionable

### Contributor Activity

- 7 contributors active
- No pull requests merged
- Focus on infrastructure, testing, and community clarity
`````

## File: packages/docs/news/2025-03-30.md
`````markdown
# Daily Report – 2025-03-30

## 1. Plugin and Integration Troubleshooting

### 1.1 Plugin Installation and Visibility Fixes

- Issues with plugin visibility after CLI and Bun installation
- Recommended fix:
  - Clone ElizaOS repo
  - Switch to `v2-develop` branch
  - Run: `bun install`, `bun run build`, `bun start`

### 1.2 Twitter Plugin Issues

- Twitter client failed to reply despite detecting interactions
- Partial fix: switching from npm to Bun helped some users
- PR #4108:
  - Prevents tweets containing "Error:"
  - Improves post generation using `composePromptFromState`
- Issue tracked in GitHub #4115

### 1.3 Local AI Configuration

- System defaulted to LLaMA models despite OpenAI/Anthropic keys
- Fix: set `.env` variables:
  - `USE_LOCAL_AI`
  - `USE_OLLAMA_TEXT_MODELS`

### 1.4 Telegram Plugin Enhancements

- PR #4106 introduced:
  - Standardized world ID via `chat.id`
  - Improved message event structure
  - `startTelegramOnboarding` for group chats
  - Refactored entity tracking
- Limitations:
  - Incomplete support for forums, topics, channels
  - Deprecated handlers pending replacement

### 1.5 Other Common Issues

- Missing `.env` variables (e.g., `DISCORD_APPLICATION_ID`) caused crashes
- Dependency errors during `bun install` resolved by switching to `v2-develop`
- Anthropic API rate limit crashes mitigated by:
  - Waiting for reset
  - Switching providers
  - Reducing token usage

## 2. Community Development and Strategy

### 2.1 Documentation and Onboarding

- Emphasis on:
  - Dual-layered documentation (technical + non-technical)
  - Centralized FAQ with metadata-tagged plugins/articles
  - Use of flowcharts and LLMs for accessibility
- Integration between code and community docs prioritized

### 2.2 Tokenomics and DAO Governance

- Proposed two-pool token model for:
  - Developer compensation
  - Liquidity
- Concerns raised about sustainability
- Suggested success metrics:
  - Discord engagement
  - Developer activity
  - Social media mentions
- Action items:
  - Build chatbot (jintern)
  - Integrate docs with codebase
  - Create onboarding tools (e.g., setup wizard)

### 2.3 Technical Contributions

- New CLI command for monorepo management
- Twitter plugin improvements
- Two bug fixes merged
- Four PRs merged by five contributors

## 3. CLI and Twitter Integration Issues

### 3.1 Twitter API Duplicate Tweet Fix

- Issue: Twitter error 187 (duplicate status)
- Fix in PR #4111:
  - Prevents sending identical tweets consecutively

### 3.2 CLI Installation Failure

- Error: Missing dependency `@elizaos/plugin-sql@^0.25.6`
- Cause: Version not available in public npm registry
- Fix: Update `package.json` to use valid version

### 3.3 Agent Creation Bug

- Error: `'agents already exists'` on `npx elizaos create`
- Occurs on Node.js v23.7.0 / Debian 12

## 4. Discord Chat Analysis

### 4.1 Pump.fun Token Speculation

- Focus on Solana-based meme tokens (e.g., AGiXT)
- Users tracked market cap and price changes
- Bot commands used:
  - `.dp`, `.cc`, `.c`, `.x` for live data
- Mentions of bonding mechanisms (e.g., "Pif bonded")
- Rick bot shared tweets to integrate social sentiment

### 4.2 Non-Technical Chat Segment

- One segment contained only repeated, content-less messages
- No actionable insights or technical discussion

## 5. Crypto Market Overview

- **Wrapped Bitcoin (WBTC)**: $82,581.85
- **ai16z Token**: $0.1579

## 6. Consolidated Development Highlights

### 6.1 Technical Enhancements

- CLI: New `monorepo` command
- Twitter plugin:
  - Duplicate tweet fix (PR #4111)
  - Improved post generation (PR #4108)
- Component handling optimized (PR #4110)

### 6.2 Telegram Plugin Updates

- PR #4106:
  - World ID standardization
  - Onboarding improvements
  - Entity tracking refactor

### 6.3 Installation and Quickstart Issues

- CLI install errors due to missing plugin versions
- Quickstart guide outdated; suggested use of `@beta` tag
- Agent creation bug reported

### 6.4 Community and AI Integration

- Documentation and onboarding improvements
- Tokenomics and governance discussions
- AI-generated summaries and newsletter tools for `m3-org/ai-news`
- Proposed use of dashboards, image prompts, and RAG workflows

### 6.5 Technical Support

- Frequent help requests on:
  - Plugin installation
  - Local AI setup
  - Twitter client issues
- Common solution: switch to `v2-develop` and update `.env` settings

### 6.6 Discord Activity Summary

- Active trading discussions on Pump.fun
- Minimal technical depth in some segments
- One segment deemed non-informative

---

End of report.
`````

## File: packages/docs/news/2025-04-01.md
`````markdown
# Daily Report – 2025-04-01

## 1. Crypto Market Price Overview

### Key Highlights

- **Wrapped Bitcoin (WBTC)**: $82,444.97
  - Closely tracks Bitcoin’s value.
- **Wrapped Ethereum (WETH)**: $1,822.83
  - Maintains strong position among Ethereum-based assets.
- **Solana (SOL)**: $124.53
  - Continues as a major smart contract platform.
- **ai16z Token**: $0.1649
  - Represents a smaller or emerging asset.

## 2. Comput3AI Discord Chat Summary

### Segment 1: No Content

- Only included repeated username mentions.
- No actionable insights or discussion.

### Segment 2: Partner Benefits Discussion

- Shared tweet sparked discussion on project alignment.
- User inquiry: Do partners receive launchpad benefits (e.g., token allocations)?
- No definitive answer or technical follow-up.
- Suggested action: Clarify and document partner benefits.

## 3. ElizaOS Plugin Integration and Technical Issues

### Plugin Execution Issues

- **Goat Plugin**: `sendeth()` function not triggering.
  - Issue remains unresolved.

### OpenRouter Plugin Workaround

- No official plugin; user-provided workaround for Eliza v2.
- Publishing challenges persist.
- JavaScript script and undocumented API endpoint shared for knowledge uploads.

### Telegram & Twitter Agent Issues

- Telegram bot misconfiguration despite correct `.env` and character files.
  - Suggested fix: Check group chat permissions.
- Twitter agents unresponsive for some users.
  - Core chat and knowledge features unaffected.

### RAG Limitations

- Only responds to direct queries.
- Does not function as dynamic memory.
- Acknowledged as a shared concern.

### CLI Setup & Documentation

- YouTube tutorial shared for CLI setup.
- API endpoint usage clarified for knowledge uploads.

### Additional Technical Issues

- Invalid `x-api-key` error with Anthropic on Eliza v2.
- Lack of documentation for Native TEE.
- Feature requests:
  - Multi-agent/plugin development support.
  - Plugin registry browser.
  - UI improvements for MCP tooling and Twitter plugin visibility.

### Development Activity

- New pull request submitted to add a separate Ollama plugin.

## 4. Telegram Room and Entity Synchronization

### Update Overview

- Forum topics in Telegram supergroups now mapped to distinct rooms.
- Improves clarity and organization.

### Technical Enhancements

- Refined message handling and chat authorization.
- New methods:
  - `handleExistingChat`
  - `handleNewForumTopic`
  - `handleNewEntity`

### Known Issues

- Incomplete support for direct messages.
- Ineffective entity tracking via `setupEntityTracking`.

### API Endpoint Concern

- `router.post('/:agentId/rooms')` lacks clarity and annotations.
- Needs better documentation.

## 5. ElizaOS Development and Community Activity

### Development Highlights

- **Plugin Modularization**:
  - Ollama code removed from LocalAI core (PRs #4121, #4122).
- **Docker Optimization**:
  - Image size reduced by ~0.4 GB (PR #4120).
- **Telegram Integration**:
  - Forum topics mapped to rooms (PR #4124).
  - Improved logging and authorization.

### Community Discussions

- Plugin issues (e.g., Goat plugin), Telegram bot setup, and Twitter agent responsiveness.
- Workarounds shared:
  - Undocumented API endpoints.
  - Hacky OpenRouter plugin.

### Blockchain & Trading Topics

- Token launches on pump.fun.
- Binance leverage changes affecting ACT token.
- AI agents in meme token trading.
- Action items:
  - Document tokenomics.
  - Improve staking features.

### DAO Storytelling Pipeline

- Claude AI-generated script nearing completion.
- Plans for:
  - Dedicated Discord channel.
  - User guide for collaborative screenplay writing.

### Hyperfy Update

- Version 0.10.0 released with 80+ improvements:
  - New UI
  - Transform gizmo
  - Plugin hooks

### Additional GitHub Activity

- Email-related changes (PR #4123).
- API behavior issue in room creation (Issue #4119).
`````

## File: packages/docs/news/2025-04-02.md
`````markdown
# Daily Report – 2025-04-02

## Plugin Development and Integration

### Community Support and Troubleshooting

- Active discussions on Discord focused on:
  - Telegram and Twitter plugin setup issues
  - Database configuration challenges
  - Agent behavior customization
- Key contributors: aiqubit, harveyjavier, tamagogogo\_
- Unresolved issues:
  - RAG knowledge updates require DB deletion to reflect
  - Agents respond with both action and default messages

### GitHub Pull Request Highlights

- `plugin-browser` cleanup to remove duplicate code (PR #4129)
- `plugin-evm` test fixes for wallet functionality (PR #4130)
- OpenAI plugin enhancements:
  - Custom embedding model and dimension support (PR #4140)

### Workflow and Environment Improvements

- Plugin publishing workflow improvements (PR #4132):
  - GitHub push behavior refined
  - Support for `@elizaos/plugin` aliasing
- `.env.example` updated for Raiinmaker plugin setup (PR #4136)

### Known Issues

- Twitter plugin inefficiency (Issue #4127):
  - Repeatedly logs already-processed tweets
  - Leads to API overuse and log clutter
  - Suggested fixes: cursor-based pagination, ID caching, log filtering

## Crypto Market Overview

- Wrapped Bitcoin (WBTC): $85,119.08
- Wrapped Ether (WETH): $1,905.85
- Solana (SOL): $126.68
- ai16z token: $0.1954

## DegenAI/Spartan V2 and ElizaOS Enhancements

### Spartan V2 Development

- V2 release expected in 1–2 weeks
- Goals:
  - Feature parity with V1
  - Improved stability
  - New project name secured
- Community feedback:
  - Spartan bot perceived as rude
  - Tone adjustments planned

### ElizaOS Development Activity

- 11 pull requests merged by 10 contributors
- Key updates:
  - Browser plugin cleanup
  - Enhanced Telegram logic via middleware
  - Two bug fixes resolved

## Community Token Promotion and Management

### pump.fun Token Strategies

- Real-time trading and promotion of meme/microcap tokens
- Tactics:
  - Floor price manipulation
  - Social media and narrative alignment
  - SOL pooling and external event leverage
- Key contributors: paulshitttt, e_turtle, Rick

### Branding and Meta Trends

- Token relaunches due to naming errors (e.g., pmoer)
- Community education on token meta and narrative trends
- Automated performance updates via Rick

### Telegram Community Management

- New feature added (PR #4134):
  - Greet new users
  - Timeout disruptive users
  - Improves moderation and onboarding

## auto.fun Launch Strategy and Partner Involvement

### Launch Delays and Community Feedback

- Delay due to:
  - Extended testing
  - Backend coordination
- Not caused by partner expansion
- Community divided:
  - MVP advocates vs. quality-first supporters

### Partner Benefits Clarification

- Partners do not receive launchpad allocations

### Action Items and Suggestions

- Complete testing and backend coordination
- Implement staggered launch
- Update documentation
- Improve:
  - Communication
  - Go/no-go checkpoints
  - Contributor protection from toxic feedback

## Audio Utility Refactoring in ElizaOS

### Codebase Improvements

- Audio utility code centralized in core module (PR #4133)
- Starter project and import paths updated for compatibility (PR #4139)

## Cross-Platform Community and Technical Updates

### ElizaOS Platform

- 11 PRs merged, including:
  - Plugin cleanup and bug fixes
  - Enhanced Telegram and community manager features
  - OpenAI plugin embedding config
  - Updated `.env.example` and documentation
- Known issue: Twitter plugin redundancy (Issue #4127)

### pump.fun Community

- Coordinated token promotion and trading
- Feature requests:
  - Token name validation
  - Narrative tagging
  - Community voting

### ElizaOS Discord Support

- Plugin integration and agent behavior issues discussed
- MongoDB unsupported; PostgreSQL considered
- Feature requests:
  - Cache disabling
  - Hybrid LLM UI
  - Plugin error handling
- Documentation needs identified

### DegenAI/Spartan V2

- V2 nearing release with improved tone and documentation

### auto.fun Launch

- Emphasis on quality and stability
- Community feedback shaping launch strategy

### Partner Clarification

- No launchpad benefits for partners confirmed via Discord exchange
`````

## File: packages/docs/news/2025-04-03.md
`````markdown
# Daily Report – 2025-04-03

## 🛠️ Recent Bug Fixes and Improvements in ElizaOS

- **Twitter Integration Crash Fix**

  - Resolved double memory creation issue causing server crashes.
  - Ensures stable memory handling during Twitter interactions.
  - [PR #4151](https://github.com/elizaOS/eliza/pull/4151)

- **Plugin Load Order Improvement**

  - Ensures project plugin loads first for better developer experience.
  - Especially helpful for first-time users with starter projects.
  - [PR #4150](https://github.com/elizaOS/eliza/pull/4150)

- **PGlite Migration Fix**

  - Fixed inconsistent `Datadir` usage in migrations.
  - Prevents data corruption and supports rollback.
  - [PRs #4157](https://github.com/elizaOS/eliza/pull/4157), [#4158](https://github.com/elizaOS/eliza/pull/4158)

- **Farcaster Mention Logging**

  - Ignored mentions now properly recorded in memory.
  - Prevents repeated processing and improves efficiency.
  - [PR #4163](https://github.com/elizaOS/eliza/pull/4163)

- **Database Deadlock Resolution**
  - Fixed idle transaction state caused by `getWorld` merge.
  - Restores proper database behavior.
  - [PR #4142](https://github.com/elizaOS/eliza/pull/4142)

## 📚 ElizaOS v2 Migration, Plugin Issues, and Documentation Updates

- **Migration Challenges**

  - Issues with agent data transfer, plugin failures, and EC2 builds.
  - Manual plugin addition recommended for errors like `getTasks()`.
  - Reported by users: stonklord666, .alex92, Deanpierce.

- **Twitter Plugin Changes**

  - Tweet content now LLM-generated based on character definitions.
  - Use `TWITTER_DRY_RUN` for safe testing.
  - Deprecated features: `MAX_REPLIES_PER_TWEET`.

- **Documentation Enhancements**

  - New video section: [eliza.how/community/videos](https://eliza.how/community/videos)
  - Website migration from elizaos.ai to eliza.how using Docusaurus.

- **GitHub Documentation Tasks**

  - [Issue #4143](https://github.com/elizaOS/eliza/issues/4143): Test all CLI commands.
  - [PR #4148](https://github.com/elizaOS/eliza/pull/4148): Removed unnecessary character.
  - [Issue #4145](https://github.com/elizaOS/eliza/issues/4145): Broken documentation link.

- **Community Ideas**
  - Speculative DAO of AI agents for UBI funding.
  - Suggestion for a Moo Deng AI plushy product.

## 📈 Crypto Market Overview

- **Token Prices**
  - Wrapped Bitcoin (WBTC): $82,440.20
  - Wrapped Ethereum (WETH): $1,794.31
  - Solana (SOL): $117.38
  - ai16z: $0.1711

## 🔧 Additional Improvements and Fixes

- **Test File Refactor**

  - Extracted repeated string into constant.
  - No functional changes; improves maintainability.
  - [PR #4152](https://github.com/elizaOS/eliza/pull/4152)

- **Farcaster Configuration Update**

  - FID can now be set via runtime or environment variables.
  - Removed sensitive debug logs.
  - [PR #4156](https://github.com/elizaOS/eliza/pull/4156)

- **Development Summary**
  - 12 contributors, 12 merged PRs.
  - Focus on plugin loading, avatar stack, and bug fixes.

## 🎨 Enhancements and Maintenance Updates

- **Avatar Stack Enhancement**

  - Improved functionality and user experience.
  - [PR #4162](https://github.com/elizaOS/eliza/pull/4162)

- **Registry Maintenance**
  - Temporary update to hardcoded v2 registry.
  - [PR #4153](https://github.com/elizaOS/eliza/pull/4153)

## 💬 Twitter Interaction Handling and CLI Inquiry

- **Twitter Interaction Fixes**

  - Caching added to prevent redundant checks.
  - Duplicate memory creation resolved via event logic.
  - [PR #4155](https://github.com/elizaOS/eliza/pull/4155)

- **CLI Interface Inquiry**
  - User asked if CLI interface is still supported.
  - [Issue #4159](https://github.com/elizaOS/eliza/issues/4159)

## 🧹 API Cleanup and Provider Configuration Bug

- **API Cleanup**

  - Removed unused APIs from codebase.
  - [PR #4144](https://github.com/elizaOS/eliza/pull/4144)

- **Model Provider Bug**
  - ElizaOS defaults to OpenAI even when Anthropic is configured.
  - [Issue #4160](https://github.com/elizaOS/eliza/issues/4160)

## 🌐 Community and Technical Developments

- **Community Challenges**

  - Plugin errors, migration issues, and unclear Twitter plugin behavior.
  - Partial solutions shared, but many questions remain.

- **Development Highlights**

  - Replaced `eventEmitter3` with `Evt` for type safety.
  - Fixed Twitter memory duplication and DB deadlocks.
  - Improved plugin loading and Farcaster config.

- **Meme Coin Trading Insights**

  - Topics: liquidity block detection, tokenomics, long-term plays.
  - Tools: bot commands, moonbag calculator, sentiment index.

- **Community Engagement**

  - Concerns over auto.fun delays and communication.
  - Website refactor and new documentation video section.
  - Speculative DAO and UBI discussions.

- **Ongoing Issues**
  - Defaulting to OpenAI despite config.
  - Broken documentation links and validation errors.
  - Requests for CLI return and better documentation testing.
  - [Issues #4143](https://github.com/elizaOS/eliza/issues/4143), [#4145](https://github.com/elizaOS/eliza/issues/4145), [#4146](https://github.com/elizaOS/eliza/issues/4146), [#4147](https://github.com/elizaOS/eliza/issues/4147), [#4159](https://github.com/elizaOS/eliza/issues/4159), [#4160](https://github.com/elizaOS/eliza/issues/4160)
`````

## File: packages/docs/news/2025-04-04.md
`````markdown
# Daily Report – 2025-04-04

## Cryptocurrency Market Overview

### Current Prices

- **Wrapped Bitcoin (WBTC):** $83,065.81
  - Highest-valued asset among listed cryptocurrencies
- **Wrapped Ethereum (WETH):** $1,816.02
- **Solana (SOL):** $117.07
- **ai16z:** $0.158
  - Lower-cap digital asset

## ElizaOS Community Highlights

### Meme Coin Strategies & Trading Insights

- Active discussions in Pump.fun Discord channel
- Key topics:
  - Real-time meme coin tracking and speculation
  - Token link sharing and price movement analysis
  - Influence of social media virality and KOLs
- Tools and strategies:
  - Rick bot shares token metrics and influencer tweets
  - Use of 'autofun' for automated trading
  - Exchange listing planning (e.g., Jupiter)
  - Risk management and profit-taking strategies

### Plugin Development for ElizaOS v2

- Focus areas:
  - Troubleshooting plugin loading errors
  - Twitter and Telegram bot integration
  - Consolidation of plugins into core repository
- Notable updates:
  - Twitter plugin now uses .env configuration (no manual install)
- Ongoing issues:
  - Bugs with ACTION_INTERVAL and agent loading loops
  - Documentation gaps (e.g., processActions method, Telegram setup)
- Contributors:
  - araiczyk.wbi and dankvr provided support and resources

### Website Development & Tokenomics Strategy

- Website:
  - Docusaurus system implemented for dynamic partner pages
  - Current intake via Typeform (Tally); Clank Tank integration planned
- Tokenomics:
  - Emphasis on aligning incentives with VCs, exchanges, and market makers
  - Buybacks alone deemed insufficient
  - Proposed strategies:
    - Revenue-generating launchpad (debated effectiveness)
    - Increased visibility through KOLs and partnerships
    - Addressing shorting pressure and market manipulation
    - Enhanced outreach and education efforts
`````

## File: packages/docs/news/2025-04-05.md
`````markdown
# Daily Report – 2025-04-05

## Plugin Development and Integration

### Twitter Plugin and ElizaOS v2 Issues

- Twitter client is non-functional in ElizaOS v2
- Use only the Twitter plugin with proper environment variables
- 2FA login issues resolved via Google Authenticator
- Tweet posting remains problematic
- Additional issues:
  - Plugin installation errors due to missing versions
  - Dependency issues with `pnpm`
  - No CLI support for character loading in v2
  - Anthropic model errors resolved by switching to OpenAI
- Interest in Discord integration; no implementation yet
- Action items:
  - Fix Twitter client
  - Improve documentation
  - Enhance plugin registration
  - Add Discord support

### Bootstrap Plugin Test Suite

- New test suite with 6,000+ lines across 7 files
- Covers actions, evaluators, logic, providers, services, and structure
- Supports:
  - Individual/full test runs
  - Coverage reporting
  - Watch mode
- Improves plugin stability and development confidence

### Telegram Plugin: Interactive Buttons

- Added support for inline keyboard buttons
- New `Button` type in core package
- Enables login/URL buttons in messages
- Fully tested and non-breaking update

### OpenAI Plugin Refactor

- Codebase improvements:
  - Extracted helper functions
  - Centralized client creation
  - Replaced `FormData` with `NodeFormData`
  - Standardized config access
- No change in functionality; improved maintainability

## Bug Fixes

### Telegram

- Fixed "get world" functionality for data retrieval

### Twitter

- Removed redundant `shouldRespond` call in interaction logic

### Knowledge Tab

- Fixed scrolling and dynamic loading issues in agent sidebar
- Low-risk UI fix; no documentation changes needed

## Cryptocurrency Market Overview

### High-Value Tokens

- Wrapped Bitcoin (WBTC): $83,752.46
- Wrapped Ethereum (WETH): $1,815.19

### Other Tokens

- Solana (SOL): $122.76
- ai16z: $0.1429

## Data and Instrumentation

### Twitter Feed Scraping

- Discussed using Eliza scraper to collect and store Twitter data
- Proposed workflow:
  - Scrape → Store in DB → Analyze/Display
- No implementation yet
- Action items:
  - Evaluate scraper
  - Build data pipeline
  - Document workflow

### Instrumentation Integration

- Porting instrumentation from Eliza v1 to v2 (Epic: ELI2-176)
- Medium risk due to potential data collection issues
- Requires:
  - Pattern mapping
  - DB adapter fixes
  - Documentation updates

## Project Updates and Visibility

### Community Communication

- Concerns raised about lack of public updates
- Suggestion: Restore/create DegenAI X (Twitter) account

### Dependency Updates

- Merged PR #4141 to update npm/yarn dependencies
- Ensures up-to-date JavaScript packages

## New Features

### Metadata ID Field

- Added `id` field to metadata source
- Improves data structure and traceability

### CLI Update Command

- Introduced `update-cli` command
- Simplifies CLI tool updates

## Community and Ecosystem Discussions

### Swarm and Multi-Agent Coordination

- Swarm integration in ElizaOS v2 enables agent collaboration
- Released Multi-agent Coordination Protocol (MCP)
- Introduced project manager agent with Trello/Asana integration

### ai16z Token and Tokenomics

- Concerns over sell pressure from fair launch
- Suggestions:
  - Create real AI use cases
  - Improve marketing and KOL outreach
  - Focus on April 14th launch visibility

### Technical Support

- Twitter plugin setup issues in v2
- Recommendations:
  - Use plugin only (not client)
  - Switch to OpenAI
  - Improve setup documentation

### Twitter Scraper Discussion

- Reiterated feasibility of scraping and storing Twitter data
- No final implementation

### Community Visibility

- Reaffirmed need for better public communication
- DegenAI X account suggested

### Meme Coin Community (Pump.fun)

- Topics:
  - Wallet concentration risks
  - Bot behavior
  - Market maker strategies
- Shared strategies:
  - DCA
  - Profit-taking
- Feature requests:
  - Wallet analytics
  - Moonshot integration
  - DCA tools

### GitHub Development Activity

- Notable changes:
  - Metadata ID field
  - Twitter/Telegram fixes
  - OpenAI plugin refactor
  - Bootstrap plugin test suite
  - Instrumentation integration
  - Telegram button support
  - CLI update command
- Suggestion: Mark/remove incompatible plugins from docs

## Miscellaneous

- One Discord message contained no analyzable content.
`````

## File: packages/docs/news/2025-04-06.md
`````markdown
# Daily Report – 2025-04-06

## 1. ElizaOS and Spartan Project Development Updates

### Plugin and Framework Development

- Contributor mtbc_69795 requested urgent review of PR #1 for `plugin-zilliqa` to avoid conflicts with upcoming v2 changes.
- uninsomniac reported issues retrieving data from Pinecone index, highlighting documentation gaps for vector database integrations.
- vedmohan asked for guidance on whether to use the starter or main repo for building AI agents with plugins, indicating onboarding confusion.
- nicedreamsmaybe proposed a conceptual use case for AI agents managing a home nursery using market and spatial data.
- k_carv shared a developer feedback form to improve documentation and support.

### Spartan Project Updates

- odilitime, acting as interim PM, announced a confidential Twitter/X account (@SpartanVersus) for Spartan v2 communications.
- Plans to allow users to link wallets to social accounts (e.g., Twitter) on an opt-in basis for personalized features.
- Token holder perks currently limited to Discord (e.g., 1M degen tokens = partner status); expansion under consideration.

### Documentation and Codebase Maintenance

- PR #4193 updated internal documentation links after file relocation.
- Resolved bun installation issue in `plugin-bootstrap`.
- Two PRs merged with contributions from five developers, reflecting ongoing maintenance.

## 2. Current Cryptocurrency Market Prices

- Wrapped Bitcoin (WBTC): $83,428.33
- Wrapped Ethereum (WETH): $1,806.14
- Solana (SOL): $120.28
- ai16z (AI-focused token): $0.1278

## 3. Solana Meme Token Tracking and Community Insights (Pump.fun)

### Community Activity

- Active tracking and speculation of Solana-based meme/microcap tokens via Pump.fun.
- Rick bot provided automated token data (price, % change, links).

### Technical and Market Concerns

- shooter.rcj flagged high centralization in token holdings (>40% by top 10 holders), raising rug pull concerns.
- elvisgan noted high BTC dominance as a potential altcoin bottom signal.

### Project Discovery

- Users shared obscure tokens like Survivor Finance and A.L.I.C.E., the latter offering utility via a coding platform and token burn mechanics.

### Bot Ecosystem

- Mention of Bankr bots (JSTR, SLKR, SNIFF); $SNIFF launch upcoming.

### Help and Feature Requests

- Peer-to-peer support on risky tokens and market conditions.
- Feature requests for Rick bot:
  - Utility tags
  - Sentiment analysis
  - Dev activity tracking
  - Watchlist functionality

### Inactive Segment

- One chat segment contained only repeated messages from [Captain Hook]; no analyzable content.

## 4. Plugin Installation and Import Issues (Windows, Bun, Plugin-Bootstrap)

### PR #4194 – Minor Fix

- Removed deprecated `postscript` from `plugin-bootstrap` to prevent post-installation errors.
- No runtime impact; no documentation update required.

### Issue #4191 – Windows Compatibility

- `elizaos start` failed on Windows (Node.js v23.3 via NVM):
  - Plugin import failures (`plugin-local-ai`, `plugin-bootstrap`)
  - Path handling issues (e.g., unsupported 'g:' protocol)
  - Missing modules (e.g., `fastembed`)
  - Database migration error due to missing `_journal.json`
- Highlights need for improved Windows support and dependency resolution.

## 5. ElizaOS Community and Development Updates

### Technical Fixes and Enhancements

- PR #4196 fixed CLI bug where `elizaos test` failed after new plugin/project creation.
- PR #4194 removed deprecated postscript to prevent install errors.
- PR #4192 optimized Twitter integration by reducing redundant API calls.
- PR #4195 improved cross-platform script compatibility (Linux/macOS).

### Documentation and Platform Stability

- PR #4193 updated file references after restructuring.
- Two PRs merged with contributions from five developers, improving installation and compatibility.

### Known Issues

- Windows-specific plugin import and path resolution problems persist (see Issue #4191).
`````

## File: packages/docs/news/2025-04-07.md
`````markdown
# Daily Report - 2025-04-07

## Recent Fixes and Improvements in ElizaOS

### CLI Plugin Documentation Fix

- Resolved outdated syntax in CLI plugin command documentation
- Prevents "subcommand not found" errors
- Low-risk, documentation-only change
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4200)

### Port Conflict Resolution

- Fixed issue with `npx elizaos start` failing due to port conflicts
- Now auto-selects next available port
- Non-breaking, improves local development experience
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4199)

### JSON Parsing Bug Fix

- Corrected regex in `normalizeJsonString` to handle nested JSON properly
- Prevents invalid JSON from extra quotation marks
- Includes new test cases
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4198)

### Agent Deletion UI Fix

- Fixed non-functional "Delete Character" button
- Addressed backend DB constraint and frontend error handling
- Medium-risk update improving reliability and UX
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4197)

## Current Cryptocurrency Market Prices

- **Wrapped Bitcoin (WBTC):** $78,142.47
- **Wrapped Ethereum (WETH):** $1,579.21
- **Solana (SOL):** $105.84
- **ai16z Token:** $0.1086

## Discord Chat Summary: Degen v2 Release and Holder Perks

### General Observations

- Minimal technical content in some chat segments
- Repetitive, context-less messages from single users

### Degen v2 Release Discussion

- User inquiry about v2 release timeline
- No confirmed date; speculation around Degen v2 alignment

### Holder Perks Clarification

- Holders of 1M Degen tokens receive Discord partner status
- Suggestion to update documentation for clarity

### Summary

- No technical decisions or implementations
- Recommendation: improve documentation on token-based access

## Codebase Cleanup and Refactoring in Local-AI Plugin

### Dependency Externalization

- Externalized `fastembed` and `node-llama-cpp`
- Improves modularity and maintainability
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4204)

### Removal of 'ollama' References

- Finalized transition away from 'ollama' dependency
- Ensures cleaner, more consistent codebase
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4203)

## ElizaOS Community Development and Technical Discussions Summary

### Development Highlights

- Focus on CLI and plugin system improvements
- Fixed plugin subcommand documentation bug
- [View Pull Requests](https://github.com/elizaOS/eliza/pull/4200), [4202](https://github.com/elizaOS/eliza/pull/4202)

### Bug Fixes

- Port conflict resolution for `npx elizaos start`
- JSON parsing fix for nested objects
- [View Pull Requests](https://github.com/elizaOS/eliza/pull/4199), [4198](https://github.com/elizaOS/eliza/pull/4198)

### UI Enhancements

- Improved form element visibility and focus states
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4201)

### Agent Deletion Fix

- Resolved DB constraint and UI timeout issues
- [View Pull Request](https://github.com/elizaOS/eliza/pull/4197)

### Strategic and Architectural Discussions

- Real-time pipeline system for DAO
- Twitter automation using reinforcement learning
- Robotics integration potential
- Push for smaller, more frequent updates

### Technical Support Topics

- Agent UI connectivity issues
- Yarn PnP errors
- Twitter integration bugs
- LLM model configuration
- Resulted in actionable items: better error messages, docs, plugin support

### Token Tracking and Trading

- Focus on Solana-based meme and AI tokens
- Topics: liquidity pulls, scam detection, narrative strategies
- Feature requests: scam detection, derivative tracking, analytics

### Non-Actionable Chat Segments

- Repetitive or off-topic messages
- General inquiries without technical depth
`````

## File: packages/docs/news/2025-04-08.md
`````markdown
# Daily Report – 2025-04-08

## Crypto Market Overview

- **Wrapped Bitcoin (WBTC)**: $79,055.92
  - Reflects Bitcoin's value closely.
- **Wrapped Ether (WETH)**: $1,552.20
  - Tokenized representation of Ethereum.
- **Solana (SOL)**: $106.91
  - Maintains strong position as a layer-1 blockchain token.
- **ai16z**: $0.1133
  - Lower-cap, emerging token.

---

## wormhole.app: JSON Configuration & Link-Dropping Issue

- **JSON Update**
  - User godfreyart resolved a prior issue by updating the JSON configuration.
- **Link-Dropping Bug**
  - Post-update, users couldn't paste/share links—likely a UI or permissions issue.
- **Quick Fix**
  - User yikesawjeez responded with "ftfy", indicating a successful fix.
- **Non-Actionable Chat**
  - Messages from [Captain Hook] lacked content or relevance.

---

## AI, Meme Token Trading & Crypto-Gaming on Discord

### Meme & AI Token Trading

- **Platform**: pump.fun on Solana.
- **User Tools**:
  - Smart wallet tracking
  - Rick bot commands (.cc, .x)
- **Notable Tokens**:
  - Fat Factory Model (FFM/SOL)
  - jerome powell (fed/SOL)
  - humanize (humanize/SOL)
- **Key Strategies**:
  - Social signal tracking
  - Token distribution analytics
  - Use of "autofun" for AI token launches

### AI Video & Gaming Development

- **Video Generation**:
  - Tools: Remotion, Eleven Labs
  - Approaches: Unity (preferred for control), pure AI (faster iteration)
  - Hedra: Highlighted for multi-actor and camera control features
- **Community Initiatives**:
  - Discord bot for AI news (ChatGPT-based)
  - Avatar production workflows (Godot, Blender)
- **Crypto-Gaming**:
  - Platform: Hyperfy
  - Game jam proposed to explore capabilities

---

## ElizaOS & Spartan: Technical Updates

### ElizaOS Technical Issues

- **Agent Integration**:
  - REST API viable; module import issues noted.
- **Plugin Challenges**:
  - Deterministic key generation in @elizaos/plugin-tee v1.0.0-beta.27
  - Twitter integration failures despite authentication
- **LLM Configuration Conflicts**:
  - Ollama and llama3.2 overriding custom settings
  - Fixes: Adjust config files, delete local models/SQLite DBs
- **Other Issues**:
  - 404 API errors
  - Missing TypeScript definitions
  - GitHub token confusion
- **Feature Suggestions**:
  - Plugin sharing with Cursor
  - LLM override controls
  - Plugin marketplace

### Spartan Project

- **Development Status**:
  - Independent of Degen v2 timeline
- **Key Features**:
  - Plugins: community-investor, autonomous trader, intel
  - Cross-platform support
  - No chain switching
  - Workflow and dynamic character support
- **Marketing & Coordination**:
  - Rebrand with new Twitter/X account
  - Promotion delayed until after April 14 auto.fun launch
  - New project manager onboarded
  - Community requests: public roadmap, better communication

---

## Strategic & Community Highlights

- **Plugin & LLM Development**:
  - Continued focus on improving plugin compatibility and LLM configuration.
- **Spartan Marketing**:
  - Rebranding and documentation efforts in progress.
- **AI Video & Gaming**:
  - Unity favored for long-term content
  - Game jam and open-source workflows discussed
- **wormhole.app Fixes**:
  - JSON config and link-dropping issues resolved collaboratively
- **Non-Actionable Chat**:
  - Repetitive, content-less messages from [Captain Hook]
- **Meme Token Trading**:
  - Emphasis on real-time data, social signals, and bot improvements

---
`````

## File: packages/docs/news/2025-04-09.md
`````markdown
# Daily Report – 2025-04-09

## Discord Bot Development

### /report Command Performance Optimization

- Initial Issue:

  - Command was slow and occasionally timed out.
  - Triggered by [spynter]'s observation of delays.

- Root Causes Identified:

  - Excessive data retrieval without pagination or filtering.
  - Prisma ORM generated inefficient queries.
  - Full table scan detected via EXPLAIN ANALYZE.

- Solutions Implemented:

  - Limited query to last 100 reports.
  - Added index on timestamp column.
  - Replaced Prisma ORM with raw SQL.
  - Introduced Redis caching (5-minute TTL).
  - Added proper async/await usage.
  - Implemented try/catch error handling.

- Results:

  - 60% performance improvement confirmed by [spynter].
  - Stability and responsiveness improved.

- Action Items:
  - Add timestamp index.
  - Use raw SQL for /report queries.
  - Implement Redis caching.
  - Improve error handling.
  - Add pagination support.
  - Include 'last updated' timestamp in cache.
  - Add debug flag for query execution time.

## Technical Discussions & Development Updates

### Pump.fun Token Deployment & Trading

- Topics Discussed:

  - Real-time trading of meme tokens (e.g., Poohcoin, ScopeScanner).
  - DEX integration and wallet behavior analysis.
  - AI-generated token deployment and market sentiment tracking.

- Action Items:
  - Add wallet analytics.
  - Implement bonding status tags.
  - Add developer verification features.

### ElizaOS Plugin & LLM Debugging

- Issues Resolved:

  - Twitter plugin replies fixed via TWITTER_SEARCH_ENABLE and callback().
  - LLM override conflicts resolved by removing llama3.2 and resetting DB.

- Improvements:

  - Verbose logging added.
  - Plugin alignment checks implemented.

- Feature Requests:
  - Autonomous posting.
  - Plugin conflict detection.

### SpartanV2 Development Status

- Clarification:

  - SpartanV1 remains in production.
  - SpartanV2 is under development.

- Action Items:
  - Update documentation to reflect current deployment status.

### AI Agent Interoperability & Registries

- Topics Covered:

  - Avatar generation workflows.
  - Clank Tank episode production.
  - Model Context Protocol (MCP) and Agent-to-Agent (A2A) communication.
  - Proposal for decentralized agent registry using JSON 'Agent Cards' and trust graphs.

- Action Items:
  - Improve Clank Tank audio quality.
  - Document avatar workflows.
  - Develop decentralized agent registries.

## Non-Actionable Content

- Multiple chat segments contained only repeated usernames (e.g., [Captain Hook]) with no meaningful content or technical discussion.
`````

## File: packages/docs/news/2025-04-10.md
`````markdown
# Daily Report – 2025-04-10

## Discord Community Insights: Meme Coin Trading and Axiom Perp Usage

### Meme Coin and Low-Cap Token Trading

- High activity around real-time trading on Solana-based platform pump.fun
- Frequent sharing of:
  - Contract addresses
  - Market cap updates
  - Token performance metrics (e.g., bonding %, price movement)
- Tools used:
  - Rick bot via `.cc` and `.dp` commands for token stats

### Key Contributors and Token Highlights

- Notable contributors: franklyn.eth, elvisgan, pmoer
- Early calls on tokens: ReFi, KITGPT, BUTTDICK, Gamify
- Community confirms profitability of these calls

### Axiom Perpetual Trading Discussions

- pmoer shares experience using Axiom with Hyperliquid
- Guidance provided to stalker04438 on:
  - Setting stop-loss (SL)
  - Setting take-profit (TP)
  - Using position bar and pencil icon in UI

### Project Spotlight: $ISAACX

- Backed by a San Francisco-based AI DeSci company
- Over 50,000 users
- 26% of supply team-owned and locked for 1 year
- Indicates long-term commitment and reduced dump risk

### Help Interactions and Community Support

- pmoer assists with Axiom UI navigation
- yikesawjeez resolves Discord permissions bug
- meltingsnow8210 and franklyn.eth share profitable token calls
- Rick bot central to real-time data access

### Suggested Improvements and Action Items

- Axiom UI enhancements:
  - Clearer SL/TP indicators
- Rick bot feature requests:
  - Fundamentals
  - Alerts
  - Sentiment analysis
- Documentation needs:
  - Guides for Axiom and Rick bot usage

### Inactive Chat Segment

- Repeated messages from user [Captain Hook]
- No technical content or actionable insights

---

## Technical Discussions and Ecosystem Developments

### OpenRouter and Eliza OS Updates

- Focus on Grok 3 and Grok 3 Mini:
  - Grok 3: excels in structured tasks
  - Grok 3 Mini: better reasoning, more cost-effective
- Issues reported:
  - Eliza OS v2 instability (esp. Twitter plugin)
  - Version 0.25.9 deemed most stable
  - Plugin compatibility problems
- New model: Optimus Alpha with 1M token context window
- Web search outage due to exa.ai downtime
- Action items:
  - Fix plugin compatibility
  - Improve documentation
  - Enhance reasoning control in Grok 3

### SpartanV2 Agent Development

- v2 in progress; v1 remains active
- Feature request implemented: contract address in account profile
- Mention of recovering 25k lost followers
- Action items:
  - Continue SpartanV2 development
  - Maintain v1 activity
  - Document new features

### Governance and Ecosystem Initiatives

- dankvr proposes hybrid governance model:
  - Token holders + AI judges
- Upcoming release includes compiled fixes
- yardy shares Google’s ADK documentation
- Auto.fun supports DeSci via hackathons (anonfungible, k_carv)
- doriand0963 introduces new Solana-based stablecoin
- yikesawjeez explores beta testing with small banks
- Rick bot shares relevant tweets
- Action items:
  - Implement governance features
  - Integrate ADK insights
  - Track stablecoin and DeSci project developments

### Summary of Inactive Segment

- Repeated messages from [Captain Hook]
- No analyzable data or discussion content

---

## Summary of Action Items

- Improve Axiom UI (SL/TP clarity)
- Expand Rick bot capabilities (alerts, fundamentals, sentiment)
- Create documentation for Axiom and Rick bot
- Fix Eliza OS plugin compatibility
- Enhance Grok 3 reasoning control
- Continue SpartanV2 development and document features
- Implement hybrid governance model
- Monitor stablecoin and DeSci project progress
- Integrate insights from Google’s ADK documentation
`````

## File: packages/docs/news/2025-04-11.md
`````markdown
# Daily Report - 2025-04-11

## Overview

- 6 new pull requests merged
- 1 new issue opened
- 8 active contributors

## Pull Requests

- **#4262** – UI Enhancement

  - Replaced text input with dropdown for voice model selection
  - Author: Y4NK33420
  - [View PR](https://github.com/elizaOS/eliza/pull/4262)

- **#4263** – Code Cleanup

  - Removed dead plugin installation code
  - Author: wtfsayo
  - [View PR](https://github.com/elizaOS/eliza/pull/4263)

- **#4264 & #4265** – Discord Bug Fixes

  - #4264: Fixed minor Discord action issues
  - #4265: Resolved voice join/leave problems
  - Author: tcm390
  - [View PR #4264](https://github.com/elizaOS/eliza/pull/4264)
  - [View PR #4265](https://github.com/elizaOS/eliza/pull/4265)

- **#4266** – Stability Improvement

  - Fixed cyclic error
  - Author: tcm390
  - [View PR](https://github.com/elizaOS/eliza/pull/4266)

- **#4267** – Plugin List Update
  - Added missing Bootstrap plugin
  - [View PR](https://github.com/elizaOS/eliza/pull/4267)

## Issues

- **#3491** – New Issue

  - Opened by roninjin10
  - [View Issue](https://github.com/elizaOS/eliza/issues/3491)

- **Referenced Issues**
  - #2919 by LinuxIsCool
  - #3664 by suryanshkushwaha
  - #4269 by jiggyjo11
  - [View #2919](https://github.com/elizaOS/eliza/issues/2919)
  - [View #3664](https://github.com/elizaOS/eliza/issues/3664)
  - [View #4269](https://github.com/elizaOS/eliza/issues/4269)

---

# Discord Chat Activity Summary

## Minimal Technical Activity

- **Segment 1**

  - Repeated empty messages from user [Captain Hook]
  - No technical content or context
  - [View Segment](https://discord.com/channels/1253563208833433701/1326603270893867064)

- **Segment 2**
  - Link shared by [solanahop] with access code "DAO"
  - No follow-up discussion or technical exchange
  - [View Segment](https://discord.com/channels/1253563208833433701/1300756641406521416)

---

# Community Discussions Summary

## Trading Strategies & Meme Coin Analysis

- Platform: Pump.fun (Solana-based)
- Highlights:
  - ReFi/SOL gained 10,600%
  - Follow-up plays: MASTERTARD (MT/SOL), AGiXT, StupidCoin, Birkin
  - Tools used: RSI, wallet tracking
  - Meta trend: ChatGPT image-based meme coins
- Action Items:
  - Improve trading documentation
  - Add bundling visibility
  - Implement large wallet buy alerts
  - [View Discussion](https://discord.com/channels/1253563208833433701/1299989396874854440)

## Eliza OS v2 Technical Discussion

- Topics:
  - Plugin development and visibility bugs
  - Build/deployment issues (npm/bun conflicts)
  - Language support (e.g., Chinese)
  - Twitter plugin configuration
- Action Items:
  - Fix plugin bugs
  - Improve deployment guides
  - Add Telegram bot and scheduled action support
- Feature Requests:
  - GUI tools
  - Web interface authentication
  - Plugin compatibility matrix
  - [View Discussion](https://discord.com/channels/1253563208833433701/1300025221834739744)

## Governance Tooling & Infrastructure

- Proposals:
  - On-chain MCP server registry with agent feedback/voting
  - Whitelabel auto.fun (registry.fun) for server registration + token issuance
- Topics:
  - Governance transparency
  - Clank Tank DAO pitch show
- Action Items:
  - Build MCP registry
  - Improve proposal tools
  - Document governance processes
- Feature Requests:
  - Agent-to-agent communication
  - Mobile support for openwebui
  - Governance artifact repository
  - [View Discussion](https://discord.com/channels/1253563208833433701/1301363808421543988)

## Content Moderation Strategy

- Agreement to reduce frequency of automated posts
- No technical implementation discussed
  - [View Discussion](https://discord.com/channels/1253563208833433701/1308149076893630555)

## Non-Technical Segments

- Repeated messages or link sharing without context
- No problem-solving or actionable content
  - [Segment 1](https://discord.com/channels/1253563208833433701/1326603270893867064)
  - [Segment 2](https://discord.com/channels/1253563208833433701/1300756641406521416)
`````

## File: packages/docs/news/2025-04-12.md
`````markdown
# Daily Report - 2025-04-12

## AI Development Projects

- Automated news/summarization pipeline aggregating information from Discord, GitHub, and other platforms
- RSS feed system for documentation updates with Discord integration
- AI-powered shows with character models featuring lip sync and facial animations
- Project manager agent running on "v2" performing regular check-ins with contributors
- Upcoming features including "the council" for AI-based governance debates and "launchpad" product launch

## Cryptocurrency Trading Discussions

- Focus on Solana-based meme coins and AI-related tokens (ALCH, AGiXT)
- Trading advice shared among users
- Automated price information provided by bot named 'Rick'
- Trading strategy discussion including advice on selling half holdings when uncertain about exit strategy

## Technical Discussions

### ElizaOS Technical Issues

- Agent initialization challenges
- Plugin compatibility considerations
- Docker deployment configurations
- Local LLM integration
- Image processing capabilities in bots

## Communication and Collaboration

- Discussions about improving information flow
- Technical solutions proposed for communication transparency
- Trust considerations for AI agents and branding effects

## Telegram Bot Project

- Announcement of "snapture_sc_bot" project
- Designed to function as a smart contract "teacher"
`````

## File: packages/docs/news/2025-04-18.md
`````markdown
# Recent Pull Requests in the elizaOS/eliza Repository

## Bug Fixes
- Fixed knowledge types (PR #4243)
- Corrected typographical error in Character.md (PR #4313)
- Improved browser compatibility using utils-based UUID (PR #4318)
- Addressed persistent beacon issue by properly handling tour close actions (PR #4317)
- Fixed operation name tracking (PR #4314)

## New Features
- Added OpenAI model usage events (PR #4230)
- Implemented confirmation dialog for deleting groups (PR #4310)
- Added deleteTweet() function (PR #4320)
- Added Default Agents based on organization (PR #4323)

## Documentation Improvements
- Removed consecutive duplicate words (PR #4312)

## Testing and Infrastructure
- Added video understanding plugin tests (PR #4233)
- Exported bootstrap plugin capabilities (PR #4311)

# GitHub Activity Summary

Between April 18-19, 2025, the elizaos/eliza repository showed:
- 7 new pull requests submitted
- 10 pull requests merged
- 3 new issues opened
- 16 active contributors participating in development

# GitHub Issues

- Issue #3318: Request to add template system documentation to project docs
- Issue #4315: Group chat functionality not working in V2

# Discord Chat Analysis

## auto.fun Launch
- Platform launch imminent, in final testing stages
- Website temporarily down for pre-launch updates
- Chinese media coverage indicates growing international interest
- Technical details: no plugins "out of the box" initially
- Plugin support planned for future agent builder product

## Token and Cryptocurrency Discussions
- Active trading discussions around JProof, AgentTank (TANK), Alchemist AI (ALCH)
- JProof showed significant gains (over 300% increase)
- Discussions about AI16Z token utility related to auto.fun launchpad
- Politically-themed tokens like DeMS-13 performing well

## ElizaOS v2 Installation and Setup
- Solutions provided for dependency issues via `bun install`
- Configuration guidance for .env files with API keys
- Docker deployment solutions including line ending conversion
- Discussions about Twitter post interval settings and OpenAI model selection

# Crypto Market Update
- Wrapped Ethereum (WETH): $1,583.06
- Solana (SOL): $134.83
`````

## File: packages/docs/partners/0g-labs/index.md
`````markdown
---
id: 0g-labs
title: 0G Labs
sidebar_position: 1
description: Building the future of decentralized AI infrastructure.
image: /img/partners/0g-labs.jpg
website: https://0g.ai
twitter: https://twitter.com/0g_labs
tags: ['Company']
hide_table_of_contents: true
---

# 0G Labs

<div className="partner-logo">
  <img src="/img/partners/0g-labs.jpg" alt="0G Labs logo" />
</div>

Building the future of decentralized AI infrastructure.

## About 0G Labs

0G Labs is a key partner in our ecosystem, providing building the future of decentralized ai infrastructure..

## Key Features

- Integration with 0G Labs's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with 0G Labs enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://0g.ai)
- [Source](https://0g.ai)
- [Twitter](https://twitter.com/0g_labs)
`````

## File: packages/docs/partners/aethir/index.md
`````markdown
---
id: aethir
title: Aethir
sidebar_position: 1
description: Decentralized cloud computing infrastructure.
image: /img/partners/aethir.webp
website: https://x.com/AethirCloud
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Aethir

<div className="partner-logo">
  <img src="/img/partners/aethir.webp" alt="Aethir logo" />
</div>

Decentralized cloud computing infrastructure.

## About Aethir

Aethir is a key partner in our ecosystem, providing decentralized cloud computing infrastructure..

## Key Features

- Integration with Aethir's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Aethir enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/AethirCloud)
- [Source](https://x.com/AethirCloud)
`````

## File: packages/docs/partners/allora-labs/index.md
`````markdown
---
id: allora-labs
title: Allora Labs
sidebar_position: 1
description: Building the future of decentralized AI.
image: /img/partners/allora-labs.jpg
website: https://www.alloralabs.xyz
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Allora Labs

<div className="partner-logo">
  <img src="/img/partners/allora-labs.jpg" alt="Allora Labs logo" />
</div>

Building the future of decentralized AI.

## About Allora Labs

Allora Labs is a key partner in our ecosystem, providing building the future of decentralized ai..

## Key Features

- Integration with Allora Labs's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Allora Labs enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.alloralabs.xyz)
- [Source](https://www.alloralabs.xyz)
`````

## File: packages/docs/partners/apro/index.md
`````markdown
---
id: apro
title: APRO
sidebar_position: 1
description: Advanced Protocol Research Organization.
image: /img/partners/apro.jpeg
website: https://www.apro.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# APRO

<div className="partner-logo">
  <img src="/img/partners/apro.jpeg" alt="APRO logo" />
</div>

Advanced Protocol Research Organization.

## About APRO

APRO is a key partner in our ecosystem, providing advanced protocol research organization..

## Key Features

- Integration with APRO's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with APRO enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.apro.com/)
- [Source](https://www.apro.com/)
`````

## File: packages/docs/partners/arbitrum/index.md
`````markdown
---
id: arbitrum
title: Arbitrum
sidebar_position: 1
description: Layer 2 scaling solution for Ethereum.
image: /img/partners/arbitrum.png
website: https://arbitrum.io
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Arbitrum

<div className="partner-logo">
  <img src="/img/partners/arbitrum.png" alt="Arbitrum logo" />
</div>

Layer 2 scaling solution for Ethereum.

## About Arbitrum

Arbitrum is a key partner in our ecosystem, providing layer 2 scaling solution for ethereum..

## Key Features

- Integration with Arbitrum's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Arbitrum enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://arbitrum.io)
- [Source](https://arbitrum.io)
`````

## File: packages/docs/partners/arc-agents/index.md
`````markdown
---
id: arc-agents
title: ARC Agents
sidebar_position: 1
description: AI agents for the decentralized web.
image: /img/partners/arc-agents.jpg
website: https://www.arcagents.ai/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# ARC Agents

<div className="partner-logo">
  <img src="/img/partners/arc-agents.jpg" alt="ARC Agents logo" />
</div>

AI agents for the decentralized web.

## About ARC Agents

ARC Agents is a key partner in our ecosystem, providing ai agents for the decentralized web..

## Key Features

- Integration with ARC Agents's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with ARC Agents enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.arcagents.ai/)
- [Source](https://www.arcagents.ai/)
`````

## File: packages/docs/partners/arenax-labs/index.md
`````markdown
---
id: arenax-labs
title: ArenaX Labs
sidebar_position: 1
description: Building the future of AI gaming.
image: /img/partners/arenax-labs.jpg
website: https://www.aiarena.io
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# ArenaX Labs

<div className="partner-logo">
  <img src="/img/partners/arenax-labs.jpg" alt="ArenaX Labs logo" />
</div>

Building the future of AI gaming.

## About ArenaX Labs

ArenaX Labs is a key partner in our ecosystem, providing building the future of ai gaming..

## Key Features

- Integration with ArenaX Labs's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with ArenaX Labs enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.aiarena.io)
- [Source](https://www.aiarena.io)
`````

## File: packages/docs/partners/arok/index.md
`````markdown
---
id: arok
title: Arok
sidebar_position: 1
description: AI agent for venture capital.
image: /img/partners/arok.jpg
website: https://arok.vc
twitter:
tags: ['Agent']
hide_table_of_contents: true
---

# Arok

<div className="partner-logo">
  <img src="/img/partners/arok.jpg" alt="Arok logo" />
</div>

AI agent for venture capital.

## About Arok

Arok is a key partner in our ecosystem, providing ai agent for venture capital..

## Key Features

- Integration with Arok's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Arok enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://arok.vc)
- [Source](https://arok.vc)
`````

## File: packages/docs/partners/beffai/index.md
`````markdown
---
id: beffai
title: BeffAI
sidebar_position: 1
description: AI agent for DeFi.
image: /img/partners/beffai.jpg
website: https://x.com/BasedBeffAI
twitter: https://x.com/BasedBeffAI
tags: ['Agent']
hide_table_of_contents: true
---

# BeffAI

<div className="partner-logo">
  <img src="/img/partners/beffai.jpg" alt="BeffAI logo" />
</div>

AI agent for DeFi.

## About BeffAI

BeffAI is a key partner in our ecosystem, providing ai agent for defi..

## Key Features

- Integration with BeffAI's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with BeffAI enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/BasedBeffAI)
- [Source](https://x.com/BasedBeffAI)
- [Twitter](https://x.com/BasedBeffAI)
`````

## File: packages/docs/partners/berachain/index.md
`````markdown
---
id: berachain
title: Berachain
sidebar_position: 1
description: Next-generation blockchain platform.
image: /img/partners/berachain.jpg
website: https://www.berachain.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Berachain

<div className="partner-logo">
  <img src="/img/partners/berachain.jpg" alt="Berachain logo" />
</div>

Next-generation blockchain platform.

## About Berachain

Berachain is a key partner in our ecosystem, providing next-generation blockchain platform..

## Key Features

- Integration with Berachain's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Berachain enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.berachain.com/)
- [Source](https://www.berachain.com/)
`````

## File: packages/docs/partners/bnb-chain/index.md
`````markdown
---
id: bnb-chain
title: BNB Chain
sidebar_position: 1
description: Ethereum-compatible blockchain.
image: /img/partners/bnb-chain.jpeg
website: https://www.bnbchain.org/en
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# BNB Chain

<div className="partner-logo">
  <img src="/img/partners/bnb-chain.jpeg" alt="BNB Chain logo" />
</div>

Ethereum-compatible blockchain.

## About BNB Chain

BNB Chain is a key partner in our ecosystem, providing ethereum-compatible blockchain..

## Key Features

- Integration with BNB Chain's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with BNB Chain enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.bnbchain.org/en)
- [Source](https://www.bnbchain.org/en)
`````

## File: packages/docs/partners/bossu/index.md
`````markdown
---
id: bossu
title: Bossu
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/bossu.jpg
website: https://bossu.online
twitter:
tags: ['Agent']
hide_table_of_contents: true
---

# Bossu

<div className="partner-logo">
  <img src="/img/partners/bossu.jpg" alt="Bossu logo" />
</div>

AI agent for Web3.

## About Bossu

Bossu is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Bossu's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Bossu enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://bossu.online)
- [Source](https://bossu.online)
`````

## File: packages/docs/partners/collab-land/index.md
`````markdown
---
id: collab-land
title: Collab.Land
sidebar_position: 1
description: Token-gated communities.
image: /img/partners/collab-land.png
website: https://www.collab.land/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Collab.Land

<div className="partner-logo">
  <img src="/img/partners/collab-land.png" alt="Collab.Land logo" />
</div>

Token-gated communities.

## About Collab.Land

Collab.Land is a key partner in our ecosystem, providing token-gated communities..

## Key Features

- Integration with Collab.Land's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Collab.Land enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.collab.land/)
- [Source](https://www.collab.land/)
`````

## File: packages/docs/partners/crossmint/index.md
`````markdown
---
id: crossmint
title: Crossmint
sidebar_position: 1
description: NFT infrastructure for developers.
image: /img/partners/crossmint.png
website: https://www.crossmint.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Crossmint

<div className="partner-logo">
  <img src="/img/partners/crossmint.png" alt="Crossmint logo" />
</div>

NFT infrastructure for developers.

## About Crossmint

Crossmint is a key partner in our ecosystem, providing nft infrastructure for developers..

## Key Features

- Integration with Crossmint's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Crossmint enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.crossmint.com/)
- [Source](https://www.crossmint.com/)
`````

## File: packages/docs/partners/daos-fun/index.md
`````markdown
---
id: daos-fun
title: daos.fun
sidebar_position: 1
description: DAO management platform.
image: /img/partners/daos-fun.png
website: https://daos.fun
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# daos.fun

<div className="partner-logo">
  <img src="/img/partners/daos-fun.png" alt="daos.fun logo" />
</div>

DAO management platform.

## About daos.fun

daos.fun is a key partner in our ecosystem, providing dao management platform..

## Key Features

- Integration with daos.fun's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with daos.fun enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://daos.fun)
- [Source](https://daos.fun)
`````

## File: packages/docs/partners/degen8ball/index.md
`````markdown
---
id: degen8ball
title: degen8ball
sidebar_position: 1
description: AI agent for crypto trading.
image: /img/partners/degen8ball.jpg
website: https://x.com/degen8ball
twitter: https://x.com/degen8ball
tags: ['Agent']
hide_table_of_contents: true
---

# degen8ball

<div className="partner-logo">
  <img src="/img/partners/degen8ball.jpg" alt="degen8ball logo" />
</div>

AI agent for crypto trading.

## About degen8ball

degen8ball is a key partner in our ecosystem, providing ai agent for crypto trading..

## Key Features

- Integration with degen8ball's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with degen8ball enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/degen8ball)
- [Source](https://x.com/degen8ball)
- [Twitter](https://x.com/degen8ball)
`````

## File: packages/docs/partners/degenai/index.md
`````markdown
---
id: degenai
title: degenai
sidebar_position: 1
description: AI agent for DeFi.
image: /img/partners/degenai.jpg
website: https://x.com/degenspartanai
twitter: https://x.com/degenspartanai
tags: ['Agent']
hide_table_of_contents: true
---

# degenai

<div className="partner-logo">
  <img src="/img/partners/degenai.jpg" alt="degenai logo" />
</div>

AI agent for DeFi.

## About degenai

degenai is a key partner in our ecosystem, providing ai agent for defi..

## Key Features

- Integration with degenai's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with degenai enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/degenspartanai)
- [Source](https://x.com/degenspartanai)
- [Twitter](https://x.com/degenspartanai)
`````

## File: packages/docs/partners/dfinity/index.md
`````markdown
---
id: dfinity
title: Dfinity
sidebar_position: 1
description: Internet Computer blockchain for decentralized applications.
image: /img/partners/dfinity.jpg
website: https://internetcomputer.org/
twitter: https://x.com/dfinity
tags: ['Company']
hide_table_of_contents: true
---

# Dfinity

<div className="partner-logo">
  <img src="/img/partners/dfinity.jpg" alt="Dfinity logo" />
</div>

Internet Computer blockchain for decentralized applications.

## About Dfinity

Dfinity is a key partner in our ecosystem, providing internet computer blockchain for decentralized applications..

## Key Features

- Integration with Dfinity's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Dfinity enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://internetcomputer.org/)
- [Source](https://internetcomputer.org/)
- [Twitter](https://x.com/dfinity)
`````

## File: packages/docs/partners/drift/index.md
`````markdown
---
id: drift
title: Drift
sidebar_position: 1
description: Decentralized perpetual futures exchange.
image: /img/partners/drift.png
website: https://app.drift.trade/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Drift

<div className="partner-logo">
  <img src="/img/partners/drift.png" alt="Drift logo" />
</div>

Decentralized perpetual futures exchange.

## About Drift

Drift is a key partner in our ecosystem, providing decentralized perpetual futures exchange..

## Key Features

- Integration with Drift's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Drift enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://app.drift.trade/)
- [Source](https://app.drift.trade/)
`````

## File: packages/docs/partners/eigen-layer/index.md
`````markdown
---
id: eigen-layer
title: Eigen Layer
sidebar_position: 1
description: Restaking protocol for Ethereum.
image: /img/partners/eigen-layer.jpg
website: https://www.eigenlayer.xyz/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Eigen Layer

<div className="partner-logo">
  <img src="/img/partners/eigen-layer.jpg" alt="Eigen Layer logo" />
</div>

Restaking protocol for Ethereum.

## About Eigen Layer

Eigen Layer is a key partner in our ecosystem, providing restaking protocol for ethereum..

## Key Features

- Integration with Eigen Layer's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Eigen Layer enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.eigenlayer.xyz/)
- [Source](https://www.eigenlayer.xyz/)
`````

## File: packages/docs/partners/eliza/index.md
`````markdown
---
id: eliza
title: ELIZA
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/eliza.jpg
website: https://elizawakesup.ai/
twitter: https://x.com/elizawakesup
tags: ['Agent']
hide_table_of_contents: true
---

# ELIZA

<div className="partner-logo">
  <img src="/img/partners/eliza.jpg" alt="ELIZA logo" />
</div>

AI agent for Web3.

## About ELIZA

ELIZA is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with ELIZA's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with ELIZA enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://elizawakesup.ai/)
- [Source](https://elizawakesup.ai/)
- [Twitter](https://x.com/elizawakesup)
`````

## File: packages/docs/partners/eliza-studios/index.md
`````markdown
---
id: eliza-studios
title: ELIZA STUDIOS
sidebar_position: 1
description: AI-powered content creation.
image: /img/partners/eliza-studios.png
website: https://elizastudios.ai/
twitter: https://x.com/eliza_studios
tags: ['Company']
hide_table_of_contents: true
---

# ELIZA STUDIOS

<div className="partner-logo">
  <img src="/img/partners/eliza-studios.png" alt="ELIZA STUDIOS logo" />
</div>

AI-powered content creation.

## About ELIZA STUDIOS

ELIZA STUDIOS is a key partner in our ecosystem, providing ai-powered content creation..

## Key Features

- Integration with ELIZA STUDIOS's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with ELIZA STUDIOS enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://elizastudios.ai/)
- [Source](https://elizastudios.ai/)
- [Twitter](https://x.com/eliza_studios)
`````

## File: packages/docs/partners/elizas-sister/index.md
`````markdown
---
id: elizas-sister
title: Eliza's Sister
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/elizas-sister.jpeg
website: https://x.com/elizas_sister
twitter: https://x.com/elizas_sister
tags: ['Agent']
hide_table_of_contents: true
---

# Eliza's Sister

<div className="partner-logo">
  <img src="/img/partners/elizas-sister.jpeg" alt="Eliza's Sister logo" />
</div>

AI agent for Web3.

## About Eliza's Sister

Eliza's Sister is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Eliza's Sister's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Eliza's Sister enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/elizas_sister)
- [Source](https://x.com/elizas_sister)
- [Twitter](https://x.com/elizas_sister)
`````

## File: packages/docs/partners/elizas-world/index.md
`````markdown
---
id: elizas-world
title: elizas.world
sidebar_position: 1
description: AI-powered virtual world.
image: /img/partners/elizas-world.png
website: https://elizas.world
twitter:
tags: ['Project']
hide_table_of_contents: true
---

# elizas.world

<div className="partner-logo">
  <img src="/img/partners/elizas-world.png" alt="elizas.world logo" />
</div>

AI-powered virtual world.

## About elizas.world

elizas.world is a key partner in our ecosystem, providing ai-powered virtual world..

## Key Features

- Integration with elizas.world's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with elizas.world enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://elizas.world)
- [Source](https://elizas.world)
`````

## File: packages/docs/partners/emblem-vault/index.md
`````markdown
---
id: emblem-vault
title: Emblem Vault
sidebar_position: 1
description: NFT infrastructure.
image: /img/partners/emblem-vault.jpg
website: https://emblem.finance/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Emblem Vault

<div className="partner-logo">
  <img src="/img/partners/emblem-vault.jpg" alt="Emblem Vault logo" />
</div>

NFT infrastructure.

## About Emblem Vault

Emblem Vault is a key partner in our ecosystem, providing nft infrastructure..

## Key Features

- Integration with Emblem Vault's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Emblem Vault enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://emblem.finance/)
- [Source](https://emblem.finance/)
`````

## File: packages/docs/partners/ethereum-foundation/index.md
`````markdown
---
id: ethereum-foundation
title: Ethereum Foundation
sidebar_position: 1
description: Supporting Ethereum development.
image: /img/partners/ethereum-foundation.jpg
website: https://ethereum.foundation
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Ethereum Foundation

<div className="partner-logo">
  <img src="/img/partners/ethereum-foundation.jpg" alt="Ethereum Foundation logo" />
</div>

Supporting Ethereum development.

## About Ethereum Foundation

Ethereum Foundation is a key partner in our ecosystem, providing supporting ethereum development..

## Key Features

- Integration with Ethereum Foundation's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Ethereum Foundation enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://ethereum.foundation)
- [Source](https://ethereum.foundation)
`````

## File: packages/docs/partners/fleek/index.md
`````markdown
---
id: fleek
title: Fleek
sidebar_position: 1
description: Web3 infrastructure.
image: /img/partners/fleek.png
website: https://fleek.xyz
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Fleek

<div className="partner-logo">
  <img src="/img/partners/fleek.png" alt="Fleek logo" />
</div>

Web3 infrastructure.

## About Fleek

Fleek is a key partner in our ecosystem, providing web3 infrastructure..

## Key Features

- Integration with Fleek's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Fleek enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://fleek.xyz)
- [Source](https://fleek.xyz)
`````

## File: packages/docs/partners/fuel/index.md
`````markdown
---
id: fuel
title: Fuel
sidebar_position: 1
description: Modular execution layer.
image: /img/partners/fuel.jpg
website: https://fuel.network/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Fuel

<div className="partner-logo">
  <img src="/img/partners/fuel.jpg" alt="Fuel logo" />
</div>

Modular execution layer.

## About Fuel

Fuel is a key partner in our ecosystem, providing modular execution layer..

## Key Features

- Integration with Fuel's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Fuel enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://fuel.network/)
- [Source](https://fuel.network/)
`````

## File: packages/docs/partners/fxn/index.md
`````markdown
---
id: fxn
title: FXN
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/fxn.jpg
website: https://x.com/joinFXN
twitter: https://x.com/joinFXN
tags: ['Agent']
hide_table_of_contents: true
---

# FXN

<div className="partner-logo">
  <img src="/img/partners/fxn.jpg" alt="FXN logo" />
</div>

AI agent for Web3.

## About FXN

FXN is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with FXN's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with FXN enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/joinFXN)
- [Source](https://x.com/joinFXN)
- [Twitter](https://x.com/joinFXN)
`````

## File: packages/docs/partners/gaia-network/index.md
`````markdown
---
id: gaia-network
title: Gaia Network
sidebar_position: 1
description: Decentralized AI network.
image: /img/partners/gaia-network.jpg
website: https://www.gaianet.ai
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Gaia Network

<div className="partner-logo">
  <img src="/img/partners/gaia-network.jpg" alt="Gaia Network logo" />
</div>

Decentralized AI network.

## About Gaia Network

Gaia Network is a key partner in our ecosystem, providing decentralized ai network..

## Key Features

- Integration with Gaia Network's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Gaia Network enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.gaianet.ai)
- [Source](https://www.gaianet.ai)
`````

## File: packages/docs/partners/gelato/index.md
`````markdown
---
id: gelato
title: Gelato
sidebar_position: 1
description: Web3 infrastructure for automated smart contract execution.
image: /img/partners/gelato.jpg
website: https://www.gelato.network/
twitter: https://x.com/gelatonetwork
tags: ['Company']
hide_table_of_contents: true
---

# Gelato

<div className="partner-logo">
  <img src="/img/partners/gelato.jpg" alt="Gelato logo" />
</div>

Web3 infrastructure for automated smart contract execution.

## About Gelato

Gelato is a key partner in our ecosystem, providing web3 infrastructure for automated smart contract execution..

## Key Features

- Integration with Gelato's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Gelato enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.gelato.network/)
- [Source](https://www.gelato.network/)
- [Twitter](https://x.com/gelatonetwork)
`````

## File: packages/docs/partners/gnon/index.md
`````markdown
---
id: gnon
title: GNON
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/gnon.jpg
website: https://x.com/gnonlabs
twitter: https://x.com/gnonlabs
tags: ['Agent']
hide_table_of_contents: true
---

# GNON

<div className="partner-logo">
  <img src="/img/partners/gnon.jpg" alt="GNON logo" />
</div>

AI agent for Web3.

## About GNON

GNON is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with GNON's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with GNON enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/gnonlabs)
- [Source](https://x.com/gnonlabs)
- [Twitter](https://x.com/gnonlabs)
`````

## File: packages/docs/partners/godsdotfun/index.md
`````markdown
---
id: godsdotfun
title: Godsdotfun
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/godsdotfun.jpg
website: https://gods.fun
twitter: https://x.com/godsdotfun
tags: ['Agent']
hide_table_of_contents: true
---

# Godsdotfun

<div className="partner-logo">
  <img src="/img/partners/godsdotfun.jpg" alt="Godsdotfun logo" />
</div>

AI agent for Web3.

## About Godsdotfun

Godsdotfun is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Godsdotfun's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Godsdotfun enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://gods.fun)
- [Source](https://gods.fun)
- [Twitter](https://x.com/godsdotfun)
`````

## File: packages/docs/partners/goplus/index.md
`````markdown
---
id: goplus
title: GoPlus
sidebar_position: 1
description: Security data network for Web3.
image: /img/partners/goplus.jpeg
website: https://gopluslabs.io/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# GoPlus

<div className="partner-logo">
  <img src="/img/partners/goplus.jpeg" alt="GoPlus logo" />
</div>

Security data network for Web3.

## About GoPlus

GoPlus is a key partner in our ecosystem, providing security data network for web3..

## Key Features

- Integration with GoPlus's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with GoPlus enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://gopluslabs.io/)
- [Source](https://gopluslabs.io/)
`````

## File: packages/docs/partners/hats-protocol/index.md
`````markdown
---
id: hats-protocol
title: Hats Protocol
sidebar_position: 1
description: Decentralized access control.
image: /img/partners/hats-protocol.jpg
website: https://hatsprotocol.xyz/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Hats Protocol

<div className="partner-logo">
  <img src="/img/partners/hats-protocol.jpg" alt="Hats Protocol logo" />
</div>

Decentralized access control.

## About Hats Protocol

Hats Protocol is a key partner in our ecosystem, providing decentralized access control..

## Key Features

- Integration with Hats Protocol's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Hats Protocol enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://hatsprotocol.xyz/)
- [Source](https://hatsprotocol.xyz/)
`````

## File: packages/docs/partners/hedera/index.md
`````markdown
---
id: hedera
title: Hedera
sidebar_position: 1
description: Enterprise-grade public network for the decentralized economy.
image: /img/partners/hedera.jpg
website: https://hedera.com/
twitter: https://x.com/hedera
tags: ['Company']
hide_table_of_contents: true
---

# Hedera

<div className="partner-logo">
  <img src="/img/partners/hedera.jpg" alt="Hedera logo" />
</div>

Enterprise-grade public network for the decentralized economy.

## About Hedera

Hedera is a key partner in our ecosystem, providing enterprise-grade public network for the decentralized economy..

## Key Features

- Integration with Hedera's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Hedera enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://hedera.com/)
- [Source](https://hedera.com/)
- [Twitter](https://x.com/hedera)
`````

## File: packages/docs/partners/heurist-ai/index.md
`````markdown
---
id: heurist-ai
title: Heurist.ai
sidebar_position: 1
description: AI research platform.
image: /img/partners/heurist-ai.jpg
website: https://heurist.ai
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Heurist.ai

<div className="partner-logo">
  <img src="/img/partners/heurist-ai.jpg" alt="Heurist.ai logo" />
</div>

AI research platform.

## About Heurist.ai

Heurist.ai is a key partner in our ecosystem, providing ai research platform..

## Key Features

- Integration with Heurist.ai's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Heurist.ai enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://heurist.ai)
- [Source](https://heurist.ai)
`````

## File: packages/docs/partners/hume/index.md
`````markdown
---
id: hume
title: hume
sidebar_position: 1
description: AI infrastructure.
image: /img/partners/hume.jpg
website: https://wearehume.com
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# hume

<div className="partner-logo">
  <img src="/img/partners/hume.jpg" alt="hume logo" />
</div>

AI infrastructure.

## About hume

hume is a key partner in our ecosystem, providing ai infrastructure..

## Key Features

- Integration with hume's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with hume enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://wearehume.com)
- [Source](https://wearehume.com)
`````

## File: packages/docs/partners/hyperbolic/index.md
`````markdown
---
id: hyperbolic
title: Hyperbolic
sidebar_position: 1
description: Web3 infrastructure.
image: /img/partners/hyperbolic.jpeg
website: https://hyperbolic.xyz
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Hyperbolic

<div className="partner-logo">
  <img src="/img/partners/hyperbolic.jpeg" alt="Hyperbolic logo" />
</div>

Web3 infrastructure.

## About Hyperbolic

Hyperbolic is a key partner in our ecosystem, providing web3 infrastructure..

## Key Features

- Integration with Hyperbolic's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Hyperbolic enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://hyperbolic.xyz)
- [Source](https://hyperbolic.xyz)
`````

## File: packages/docs/partners/hyperfy/index.md
`````markdown
---
id: hyperfy
title: Hyperfy
sidebar_position: 1
description: Web3 infrastructure.
image: /img/partners/hyperfy.png
website: https://hyperfy.io/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Hyperfy

<div className="partner-logo">
  <img src="/img/partners/hyperfy.png" alt="Hyperfy logo" />
</div>

Web3 infrastructure.

## About Hyperfy

Hyperfy is a key partner in our ecosystem, providing web3 infrastructure..

## Key Features

- Integration with Hyperfy's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Hyperfy enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://hyperfy.io/)
- [Source](https://hyperfy.io/)
`````

## File: packages/docs/partners/injective/index.md
`````markdown
---
id: injective
title: Injective
sidebar_position: 1
description: Layer 1 blockchain optimized for DeFi applications.
image: /img/partners/injective.jpg
website: https://injective.com/
twitter: https://x.com/injective
tags: ['Company']
hide_table_of_contents: true
---

# Injective

<div className="partner-logo">
  <img src="/img/partners/injective.jpg" alt="Injective logo" />
</div>

Layer 1 blockchain optimized for DeFi applications.

## About Injective

Injective is a key partner in our ecosystem, providing layer 1 blockchain optimized for defi applications..

## Key Features

- Integration with Injective's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Injective enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://injective.com/)
- [Source](https://injective.com/)
- [Twitter](https://x.com/injective)
`````

## File: packages/docs/partners/io-net/index.md
`````markdown
---
id: io-net
title: IO.net
sidebar_position: 1
description: Decentralized compute network.
image: /img/partners/io-net.jpg
website: https://io.net
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# IO.net

<div className="partner-logo">
  <img src="/img/partners/io-net.jpg" alt="IO.net logo" />
</div>

Decentralized compute network.

## About IO.net

IO.net is a key partner in our ecosystem, providing decentralized compute network..

## Key Features

- Integration with IO.net's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with IO.net enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://io.net)
- [Source](https://io.net)
`````

## File: packages/docs/partners/iq6900/index.md
`````markdown
---
id: iq6900
title: IQ6900
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/iq6900.png
website: https://linktr.ee/IQ6900
twitter: https://x.com/IQ6900_
tags: ['Agent']
hide_table_of_contents: true
---

# IQ6900

<div className="partner-logo">
  <img src="/img/partners/iq6900.png" alt="IQ6900 logo" />
</div>

AI agent for Web3.

## About IQ6900

IQ6900 is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with IQ6900's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with IQ6900 enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://linktr.ee/IQ6900)
- [Source](https://linktr.ee/IQ6900)
- [Twitter](https://x.com/IQ6900_)
`````

## File: packages/docs/partners/jupiter-exchange/index.md
`````markdown
---
id: jupiter-exchange
title: Jupiter Exchange
sidebar_position: 1
description: Decentralized exchange aggregator.
image: /img/partners/jupiter-exchange.jpg
website: https://jup.ag/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Jupiter Exchange

<div className="partner-logo">
  <img src="/img/partners/jupiter-exchange.jpg" alt="Jupiter Exchange logo" />
</div>

Decentralized exchange aggregator.

## About Jupiter Exchange

Jupiter Exchange is a key partner in our ecosystem, providing decentralized exchange aggregator..

## Key Features

- Integration with Jupiter Exchange's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Jupiter Exchange enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://jup.ag/)
- [Source](https://jup.ag/)
`````

## File: packages/docs/partners/layerzero/index.md
`````markdown
---
id: layerzero
title: LayerZero
sidebar_position: 1
description: Omnichain interoperability protocol.
image: /img/partners/layerzero.jpg
website: https://layerzero.network/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# LayerZero

<div className="partner-logo">
  <img src="/img/partners/layerzero.jpg" alt="LayerZero logo" />
</div>

Omnichain interoperability protocol.

## About LayerZero

LayerZero is a key partner in our ecosystem, providing omnichain interoperability protocol..

## Key Features

- Integration with LayerZero's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with LayerZero enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://layerzero.network/)
- [Source](https://layerzero.network/)
`````

## File: packages/docs/partners/lit-protocol/index.md
`````markdown
---
id: lit-protocol
title: Lit Protocol
sidebar_position: 1
description: Decentralized access control.
image: /img/partners/lit-protocol.jpg
website: https://litprotocol.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Lit Protocol

<div className="partner-logo">
  <img src="/img/partners/lit-protocol.jpg" alt="Lit Protocol logo" />
</div>

Decentralized access control.

## About Lit Protocol

Lit Protocol is a key partner in our ecosystem, providing decentralized access control..

## Key Features

- Integration with Lit Protocol's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Lit Protocol enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://litprotocol.com/)
- [Source](https://litprotocol.com/)
`````

## File: packages/docs/partners/magic-eden/index.md
`````markdown
---
id: magic-eden
title: Magic Eden
sidebar_position: 1
description: NFT marketplace.
image: /img/partners/magic-eden.jpg
website: https://magiceden.us
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Magic Eden

<div className="partner-logo">
  <img src="/img/partners/magic-eden.jpg" alt="Magic Eden logo" />
</div>

NFT marketplace.

## About Magic Eden

Magic Eden is a key partner in our ecosystem, providing nft marketplace..

## Key Features

- Integration with Magic Eden's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Magic Eden enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://magiceden.us)
- [Source](https://magiceden.us)
`````

## File: packages/docs/partners/mee-fun/index.md
`````markdown
---
id: mee-fun
title: Mee.fun
sidebar_position: 1
description: AI agent launcher for Web3.
image: /img/partners/mee-fun.png
website: https://mee.fun
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Mee.fun

<div className="partner-logo">
  <img src="/img/partners/mee-fun.png" alt="Mee.fun logo" />
</div>

AI agent launcher for Web3.

## About Mee.fun

Mee.fun is a key partner in our ecosystem, providing ai agent launcher for web3..

## Key Features

- Integration with Mee.fun's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Mee.fun enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://mee.fun)
- [Source](https://mee.fun)
`````

## File: packages/docs/partners/messari/index.md
`````markdown
---
id: messari
title: Messari
sidebar_position: 1
description: Crypto research and analytics platform.
image: /img/partners/messari.jpg
website: https://messari.io/?utm_medium=messaricrypto&utm_source=linktree&utm_campaign=messari+website
twitter: https://x.com/MessariCrypto
tags: ['Company']
hide_table_of_contents: true
---

# Messari

<div className="partner-logo">
  <img src="/img/partners/messari.jpg" alt="Messari logo" />
</div>

Crypto research and analytics platform.

## About Messari

Messari is a key partner in our ecosystem, providing crypto research and analytics platform..

## Key Features

- Integration with Messari's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Messari enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://messari.io/?utm_medium=messaricrypto&utm_source=linktree&utm_campaign=messari+website)
- [Source](https://messari.io/)
- [Twitter](https://x.com/MessariCrypto)
`````

## File: packages/docs/partners/mode-network/index.md
`````markdown
---
id: mode-network
title: Mode Network
sidebar_position: 1
description: Layer 2 scaling solution.
image: /img/partners/mode-network.jpg
website: https://mode.network/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Mode Network

<div className="partner-logo">
  <img src="/img/partners/mode-network.jpg" alt="Mode Network logo" />
</div>

Layer 2 scaling solution.

## About Mode Network

Mode Network is a key partner in our ecosystem, providing layer 2 scaling solution..

## Key Features

- Integration with Mode Network's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Mode Network enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://mode.network/)
- [Source](https://mode.network/)
`````

## File: packages/docs/partners/monad/index.md
`````markdown
---
id: monad
title: Monad
sidebar_position: 1
description: High-performance Layer 1 blockchain.
image: /img/partners/monad.jpg
website: https://www.monad.xyz/
twitter: https://x.com/monad_xyz
tags: ['Company']
hide_table_of_contents: true
---

# Monad

<div className="partner-logo">
  <img src="/img/partners/monad.jpg" alt="Monad logo" />
</div>

High-performance Layer 1 blockchain.

## About Monad

Monad is a key partner in our ecosystem, providing high-performance layer 1 blockchain..

## Key Features

- Integration with Monad's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Monad enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.monad.xyz/)
- [Source](https://www.monad.xyz/)
- [Twitter](https://x.com/monad_xyz)
`````

## File: packages/docs/partners/multiversx/index.md
`````markdown
---
id: multiversx
title: MultiversX
sidebar_position: 1
description: Blockchain platform.
image: /img/partners/multiversx.jpg
website: https://multiversx.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# MultiversX

<div className="partner-logo">
  <img src="/img/partners/multiversx.jpg" alt="MultiversX logo" />
</div>

Blockchain platform.

## About MultiversX

MultiversX is a key partner in our ecosystem, providing blockchain platform..

## Key Features

- Integration with MultiversX's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with MultiversX enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://multiversx.com/)
- [Source](https://multiversx.com/)
`````

## File: packages/docs/partners/near/index.md
`````markdown
---
id: near
title: NEAR
sidebar_position: 1
description: Layer 1 blockchain designed for usability and scalability.
image: /img/partners/near.jpg
website: https://near.org/
twitter: https://x.com/NEARProtocol
tags: ['Company']
hide_table_of_contents: true
---

# NEAR

<div className="partner-logo">
  <img src="/img/partners/near.jpg" alt="NEAR logo" />
</div>

Layer 1 blockchain designed for usability and scalability.

## About NEAR

NEAR is a key partner in our ecosystem, providing layer 1 blockchain designed for usability and scalability..

## Key Features

- Integration with NEAR's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with NEAR enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://near.org/)
- [Source](https://near.org/)
- [Twitter](https://x.com/NEARProtocol)
`````

## File: packages/docs/partners/niftyisland/index.md
`````markdown
---
id: niftyisland
title: NiftyIsland
sidebar_position: 1
description: Web3 gaming platform.
image: /img/partners/niftyisland.jpg
website: https://www.niftyisland.com/
twitter: https://x.com/Nifty_Island
tags: ['Company']
hide_table_of_contents: true
---

# NiftyIsland

<div className="partner-logo">
  <img src="/img/partners/niftyisland.jpg" alt="NiftyIsland logo" />
</div>

Web3 gaming platform.

## About NiftyIsland

NiftyIsland is a key partner in our ecosystem, providing web3 gaming platform..

## Key Features

- Integration with NiftyIsland's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with NiftyIsland enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.niftyisland.com/)
- [Source](https://www.niftyisland.com/)
- [Twitter](https://x.com/Nifty_Island)
`````

## File: packages/docs/partners/nillion/index.md
`````markdown
---
id: nillion
title: Nillion
sidebar_position: 1
description: Decentralized privacy infrastructure.
image: /img/partners/nillion.jpg
website: https://nillion.com/
twitter: https://x.com/nillionnetwork
tags: ['Company']
hide_table_of_contents: true
---

# Nillion

<div className="partner-logo">
  <img src="/img/partners/nillion.jpg" alt="Nillion logo" />
</div>

Decentralized privacy infrastructure.

## About Nillion

Nillion is a key partner in our ecosystem, providing decentralized privacy infrastructure..

## Key Features

- Integration with Nillion's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Nillion enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://nillion.com/)
- [Source](https://nillion.com/)
- [Twitter](https://x.com/nillionnetwork)
`````

## File: packages/docs/partners/nrn-agents/index.md
`````markdown
---
id: nrn-agents
title: NRN Agents
sidebar_position: 1
description: AI agents for Web3.
image: /img/partners/nrnagents.jpg
website: https://www.nrnagents.ai/
twitter: https://x.com/NRNAgents
tags: ['Agent']
hide_table_of_contents: true
---

# NRN Agents

<div className="partner-logo">
  <img src="/img/partners/nrnagents.jpg" alt="NRN Agents logo" />
</div>

AI agents for Web3.

## About NRN Agents

NRN Agents is a key partner in our ecosystem, providing ai agents for web3..

## Key Features

- Integration with NRN Agents's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with NRN Agents enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.nrnagents.ai/)
- [Source](https://www.nrnagents.ai/)
- [Twitter](https://x.com/NRNAgents)
`````

## File: packages/docs/partners/partners-nft/index.md
`````markdown
---
id: partners-nft
title: Partners NFT
sidebar_position: 1
description: AI16Z Partners NFT collection.
image: /img/partners/partners-nft.jpg
website: https://magiceden.us/marketplace/ai16z_partners?gr=
twitter:
tags: ['Project']
hide_table_of_contents: true
---

# Partners NFT

<div className="partner-logo">
  <img src="/img/partners/partners-nft.jpg" alt="Partners NFT logo" />
</div>

AI16Z Partners NFT collection.

## About Partners NFT

Partners NFT is a key partner in our ecosystem, providing ai16z partners nft collection..

## Key Features

- Integration with Partners NFT's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Partners NFT enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://magiceden.us/marketplace/ai16z_partners?gr=)
- [Source](https://magiceden.us/marketplace/ai16z_partners?gr=)
`````

## File: packages/docs/partners/phala-network/index.md
`````markdown
---
id: phala-network
title: Phala Network
sidebar_position: 1
description: Privacy-preserving cloud computing.
image: /img/partners/phala-network.jpg
website: https://phala.network/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Phala Network

<div className="partner-logo">
  <img src="/img/partners/phala-network.jpg" alt="Phala Network logo" />
</div>

Privacy-preserving cloud computing.

## About Phala Network

Phala Network is a key partner in our ecosystem, providing privacy-preserving cloud computing..

## Key Features

- Integration with Phala Network's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Phala Network enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://phala.network/)
- [Source](https://phala.network/)
`````

## File: packages/docs/partners/polygon/index.md
`````markdown
---
id: polygon
title: Polygon
sidebar_position: 1
description: Layer 2 scaling solution.
image: /img/partners/polygon.jpg
website: https://polygon.technology
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Polygon

<div className="partner-logo">
  <img src="/img/partners/polygon.jpg" alt="Polygon logo" />
</div>

Layer 2 scaling solution.

## About Polygon

Polygon is a key partner in our ecosystem, providing layer 2 scaling solution..

## Key Features

- Integration with Polygon's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Polygon enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://polygon.technology)
- [Source](https://polygon.technology)
`````

## File: packages/docs/partners/project-89/index.md
`````markdown
---
id: project-89
title: Project 89
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/project-89.jpg
website: https://x.com/project_89
twitter: https://x.com/project_89
tags: ['Agent']
hide_table_of_contents: true
---

# Project 89

<div className="partner-logo">
  <img src="/img/partners/project-89.jpg" alt="Project 89 logo" />
</div>

AI agent for Web3.

## About Project 89

Project 89 is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Project 89's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Project 89 enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/project_89)
- [Source](https://x.com/project_89)
- [Twitter](https://x.com/project_89)
`````

## File: packages/docs/partners/reality-spiral/index.md
`````markdown
---
id: reality-spiral
title: Reality Spiral
sidebar_position: 1
description: Web3 infrastructure.
image: /img/partners/reality-spiral.jpg
website: https://x.com/reality_spiral
twitter: https://x.com/reality_spiral
tags: ['Agent']
hide_table_of_contents: true
---

# Reality Spiral

<div className="partner-logo">
  <img src="/img/partners/reality-spiral.jpg" alt="Reality Spiral logo" />
</div>

Web3 infrastructure.

## About Reality Spiral

Reality Spiral is a key partner in our ecosystem, providing web3 infrastructure..

## Key Features

- Integration with Reality Spiral's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Reality Spiral enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/reality_spiral)
- [Source](https://x.com/reality_spiral)
- [Twitter](https://x.com/reality_spiral)
`````

## File: packages/docs/partners/ropraito/index.md
`````markdown
---
id: ropraito
title: Ropraito
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/ropraito.jpg
website: https://x.com/ropAIrito/
twitter: https://x.com/ropAIrito/
tags: ['Agent']
hide_table_of_contents: true
---

# Ropraito

<div className="partner-logo">
  <img src="/img/partners/ropraito.jpg" alt="Ropraito logo" />
</div>

AI agent for Web3.

## About Ropraito

Ropraito is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Ropraito's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Ropraito enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/ropAIrito/)
- [Source](https://x.com/ropAIrito/)
- [Twitter](https://x.com/ropAIrito/)
`````

## File: packages/docs/partners/safe/index.md
`````markdown
---
id: safe
title: Safe
sidebar_position: 1
description: Smart account infrastructure for secure, flexible, and gasless transactions.
image: /img/partners/safe.jpg
website: https://app.safe.global/welcome
twitter: https://x.com/safe
tags: ['Company']
hide_table_of_contents: true
---

# Safe

<div className="partner-logo">
  <img src="/img/partners/safe.jpg" alt="Safe logo" />
</div>

Smart account infrastructure for secure, flexible, and gasless transactions.

## About Safe

Safe is a key partner in our ecosystem, providing smart account infrastructure for secure, flexible, and gasless transactions..

## Key Features

- Integration with Safe's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Safe enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://app.safe.global/welcome)
- [Source](https://app.safe.global/)
- [Twitter](https://x.com/safe)
`````

## File: packages/docs/partners/saga/index.md
`````markdown
---
id: saga
title: Saga
sidebar_position: 1
description: Layer 1 blockchain platform.
image: /img/partners/saga.jpg
website: https://saga.xyz/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Saga

<div className="partner-logo">
  <img src="/img/partners/saga.jpg" alt="Saga logo" />
</div>

Layer 1 blockchain platform.

## About Saga

Saga is a key partner in our ecosystem, providing layer 1 blockchain platform..

## Key Features

- Integration with Saga's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Saga enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://saga.xyz/)
- [Source](https://saga.xyz/)
`````

## File: packages/docs/partners/scriptoshi/index.md
`````markdown
---
id: scriptoshi
title: Scriptoshi
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/scriptoshi.jpg
website: https://x.com/script0shi
twitter: https://x.com/script0shi
tags: ['Agent']
hide_table_of_contents: true
---

# Scriptoshi

<div className="partner-logo">
  <img src="/img/partners/scriptoshi.jpg" alt="Scriptoshi logo" />
</div>

AI agent for Web3.

## About Scriptoshi

Scriptoshi is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Scriptoshi's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Scriptoshi enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/script0shi)
- [Source](https://x.com/script0shi)
- [Twitter](https://x.com/script0shi)
`````

## File: packages/docs/partners/secret-network/index.md
`````markdown
---
id: secret-network
title: Secret Network
sidebar_position: 1
description: Privacy-preserving smart contracts for Web3.
image: /img/partners/secret-network.jpg
website: https://scrt.network/
twitter: https://x.com/SecretNetwork
tags: ['Company']
hide_table_of_contents: true
---

# Secret Network

<div className="partner-logo">
  <img src="/img/partners/secret-network.jpg" alt="Secret Network logo" />
</div>

Privacy-preserving smart contracts for Web3.

## About Secret Network

Secret Network is a key partner in our ecosystem, providing privacy-preserving smart contracts for web3..

## Key Features

- Integration with Secret Network's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Secret Network enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://scrt.network/)
- [Source](https://scrt.network/)
- [Twitter](https://x.com/SecretNetwork)
`````

## File: packages/docs/partners/sei/index.md
`````markdown
---
id: sei
title: Sei
sidebar_position: 1
description: Layer 1 blockchain optimized for trading.
image: /img/partners/sei.jpg
website: https://www.sei.io/
twitter: https://x.com/SeiNetwork
tags: ['Company']
hide_table_of_contents: true
---

# Sei

<div className="partner-logo">
  <img src="/img/partners/sei.jpg" alt="Sei logo" />
</div>

Layer 1 blockchain optimized for trading.

## About Sei

Sei is a key partner in our ecosystem, providing layer 1 blockchain optimized for trading..

## Key Features

- Integration with Sei's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Sei enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.sei.io/)
- [Source](https://www.sei.io/)
- [Twitter](https://x.com/SeiNetwork)
`````

## File: packages/docs/partners/smolverse/index.md
`````markdown
---
id: smolverse
title: Smolverse
sidebar_position: 1
description: Web3 gaming platform.
image: /img/partners/smolverse.png
website: https://smolverse.lol
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Smolverse

<div className="partner-logo">
  <img src="/img/partners/smolverse.png" alt="Smolverse logo" />
</div>

Web3 gaming platform.

## About Smolverse

Smolverse is a key partner in our ecosystem, providing web3 gaming platform..

## Key Features

- Integration with Smolverse's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Smolverse enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://smolverse.lol)
- [Source](https://smolverse.lol)
`````

## File: packages/docs/partners/society-library/index.md
`````markdown
---
id: society-library
title: Society Library
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/society-library.jpg
website: https://www.societylibrary.org
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Society Library

<div className="partner-logo">
  <img src="/img/partners/society-library.jpg" alt="Society Library logo" />
</div>

AI agent for Web3.

## About Society Library

Society Library is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Society Library's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Society Library enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.societylibrary.org)
- [Source](https://www.societylibrary.org)
`````

## File: packages/docs/partners/solana-agentkit/index.md
`````markdown
---
id: solana-agentkit
title: Solana AgentKit
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/solana-agentkit.jpg
website: https://www.solanaagentkit.xyz
twitter:
tags: ['Project']
hide_table_of_contents: true
---

# Solana AgentKit

<div className="partner-logo">
  <img src="/img/partners/solana-agentkit.jpg" alt="Solana AgentKit logo" />
</div>

AI agent for Web3.

## About Solana AgentKit

Solana AgentKit is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Solana AgentKit's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Solana AgentKit enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.solanaagentkit.xyz)
- [Source](https://www.solanaagentkit.xyz)
`````

## File: packages/docs/partners/solana-foundation/index.md
`````markdown
---
id: solana-foundation
title: Solana Foundation
sidebar_position: 1
description: Supporting Solana development.
image: /img/partners/solana-foundation.png
website: https://solana.com/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Solana Foundation

<div className="partner-logo">
  <img src="/img/partners/solana-foundation.png" alt="Solana Foundation logo" />
</div>

Supporting Solana development.

## About Solana Foundation

Solana Foundation is a key partner in our ecosystem, providing supporting solana development..

## Key Features

- Integration with Solana Foundation's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Solana Foundation enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://solana.com/)
- [Source](https://solana.com/)
`````

## File: packages/docs/partners/soleng/index.md
`````markdown
---
id: soleng
title: Soleng
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/soleng.jpg
website: https://x.com/soleng_agent
twitter: https://x.com/soleng_ai
tags: ['Agent']
hide_table_of_contents: true
---

# Soleng

<div className="partner-logo">
  <img src="/img/partners/soleng.jpg" alt="Soleng logo" />
</div>

AI agent for Web3.

## About Soleng

Soleng is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Soleng's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Soleng enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/soleng_agent)
- [Source](https://x.com/soleng_agent)
- [Twitter](https://x.com/soleng_ai)
`````

## File: packages/docs/partners/sonic-svm/index.md
`````markdown
---
id: sonic-svm
title: Sonic SVM
sidebar_position: 1
description: High-performance Solana Virtual Machine implementation.
image: /img/partners/sonic-svm.jpg
website: https://www.sonic.game/
twitter: https://x.com/SonicSVM
tags: ['Company']
hide_table_of_contents: true
---

# Sonic SVM

<div className="partner-logo">
  <img src="/img/partners/sonic-svm.jpg" alt="Sonic SVM logo" />
</div>

High-performance Solana Virtual Machine implementation.

## About Sonic SVM

Sonic SVM is a key partner in our ecosystem, providing high-performance solana virtual machine implementation..

## Key Features

- Integration with Sonic SVM's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Sonic SVM enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.sonic.game/)
- [Source](https://www.sonic.game/)
- [Twitter](https://x.com/SonicSVM)
`````

## File: packages/docs/partners/stanford-university/index.md
`````markdown
---
id: stanford-university
title: Stanford University
sidebar_position: 1
description: Academic research partner.
image: /img/partners/stanford-university.png
website: https://stanford.edu/
twitter:
tags: ['Academic']
hide_table_of_contents: true
---

# Stanford University

<div className="partner-logo">
  <img src="/img/partners/stanford-university.png" alt="Stanford University logo" />
</div>

Academic research partner.

## About Stanford University

Stanford University is a key partner in our ecosystem, providing academic research partner..

## Key Features

- Integration with Stanford University's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Stanford University enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://stanford.edu/)
- [Source](https://stanford.edu/)
`````

## File: packages/docs/partners/story-protocol/index.md
`````markdown
---
id: story-protocol
title: Story Protocol
sidebar_position: 1
description: IP infrastructure for Web3.
image: /img/partners/story-protocol.jpg
website: https://www.story.foundation/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Story Protocol

<div className="partner-logo">
  <img src="/img/partners/story-protocol.jpg" alt="Story Protocol logo" />
</div>

IP infrastructure for Web3.

## About Story Protocol

Story Protocol is a key partner in our ecosystem, providing ip infrastructure for web3..

## Key Features

- Integration with Story Protocol's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Story Protocol enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://www.story.foundation/)
- [Source](https://www.story.foundation/)
`````

## File: packages/docs/partners/thales-cto/index.md
`````markdown
---
id: thales-cto
title: Thales CTO
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/thales-cto.jpg
website: https://x.com/Thales_ai
twitter: https://x.com/Thales_ai
tags: ['Agent']
hide_table_of_contents: true
---

# Thales CTO

<div className="partner-logo">
  <img src="/img/partners/thales-cto.jpg" alt="Thales CTO logo" />
</div>

AI agent for Web3.

## About Thales CTO

Thales CTO is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Thales CTO's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Thales CTO enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/Thales_ai)
- [Source](https://x.com/Thales_ai)
- [Twitter](https://x.com/Thales_ai)
`````

## File: packages/docs/partners/thirdweb/index.md
`````markdown
---
id: thirdweb
title: Thirdweb
sidebar_position: 1
description: Complete web3 development framework.
image: /img/partners/thirdweb.jpg
website: https://thirdweb.com/
twitter: https://x.com/thirdweb
tags: ['Company']
hide_table_of_contents: true
---

# Thirdweb

<div className="partner-logo">
  <img src="/img/partners/thirdweb.jpg" alt="Thirdweb logo" />
</div>

Complete web3 development framework.

## About Thirdweb

Thirdweb is a key partner in our ecosystem, providing complete web3 development framework..

## Key Features

- Integration with Thirdweb's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Thirdweb enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://thirdweb.com/)
- [Source](https://thirdweb.com/)
- [Twitter](https://x.com/thirdweb)
`````

## File: packages/docs/partners/ton-network/index.md
`````markdown
---
id: ton-network
title: TON Network
sidebar_position: 1
description: Layer 1 blockchain platform.
image: /img/partners/ton-network.png
website: https://ton.org/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# TON Network

<div className="partner-logo">
  <img src="/img/partners/ton-network.png" alt="TON Network logo" />
</div>

Layer 1 blockchain platform.

## About TON Network

TON Network is a key partner in our ecosystem, providing layer 1 blockchain platform..

## Key Features

- Integration with TON Network's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with TON Network enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://ton.org/)
- [Source](https://ton.org/)
`````

## File: packages/docs/partners/tron/index.md
`````markdown
---
id: tron
title: Tron
sidebar_position: 1
description: Decentralized content entertainment platform.
image: /img/partners/tron.jpg
website: https://trondao.org/
twitter: https://x.com/trondao
tags: ['Company']
hide_table_of_contents: true
---

# Tron

<div className="partner-logo">
  <img src="/img/partners/tron.jpg" alt="Tron logo" />
</div>

Decentralized content entertainment platform.

## About Tron

Tron is a key partner in our ecosystem, providing decentralized content entertainment platform..

## Key Features

- Integration with Tron's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Tron enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://trondao.org/)
- [Source](https://trondao.org/)
- [Twitter](https://x.com/trondao)
`````

## File: packages/docs/partners/vvaifu-fun/index.md
`````markdown
---
id: vvaifu-fun
title: VVAIFU.fun
sidebar_position: 1
description: AI agent launchpad for Web3.
image: /img/partners/vvaifu-fun.jpg
website: https://vvaifu.fun/
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# VVAIFU.fun

<div className="partner-logo">
  <img src="/img/partners/vvaifu-fun.jpg" alt="VVAIFU.fun logo" />
</div>

AI agent launchpad for Web3.

## About VVAIFU.fun

VVAIFU.fun is a key partner in our ecosystem, providing ai agent launchpad for web3..

## Key Features

- Integration with VVAIFU.fun's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with VVAIFU.fun enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://vvaifu.fun/)
- [Source](https://vvaifu.fun/)
`````

## File: packages/docs/partners/waye/index.md
`````markdown
---
id: waye
title: WAYE
sidebar_position: 1
description: Web3 infrastructure.
image: /img/partners/waye.jpg
website: https://x.com/waye_ai
twitter: https://x.com/waye_ai
tags: ['Agent']
hide_table_of_contents: true
---

# WAYE

<div className="partner-logo">
  <img src="/img/partners/waye.jpg" alt="WAYE logo" />
</div>

Web3 infrastructure.

## About WAYE

WAYE is a key partner in our ecosystem, providing web3 infrastructure..

## Key Features

- Integration with WAYE's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with WAYE enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://x.com/waye_ai)
- [Source](https://x.com/waye_ai)
- [Twitter](https://x.com/waye_ai)
`````

## File: packages/docs/partners/wombo/index.md
`````markdown
---
id: wombo
title: Wombo
sidebar_position: 1
description: AI-powered content creation.
image: /img/partners/wombo.jpg
website: https://wombo.com/m/home
twitter:
tags: ['Company']
hide_table_of_contents: true
---

# Wombo

<div className="partner-logo">
  <img src="/img/partners/wombo.jpg" alt="Wombo logo" />
</div>

AI-powered content creation.

## About Wombo

Wombo is a key partner in our ecosystem, providing ai-powered content creation..

## Key Features

- Integration with Wombo's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Wombo enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://wombo.com/m/home)
- [Source](https://wombo.com/m/home)
`````

## File: packages/docs/partners/zerebro/index.md
`````markdown
---
id: zerebro
title: Zerebro
sidebar_position: 1
description: AI agent for Web3.
image: /img/partners/zerebro.jpg
website: https://zerebro.org/
twitter: https://x.com/0xzerebro
tags: ['Agent']
hide_table_of_contents: true
---

# Zerebro

<div className="partner-logo">
  <img src="/img/partners/zerebro.jpg" alt="Zerebro logo" />
</div>

AI agent for Web3.

## About Zerebro

Zerebro is a key partner in our ecosystem, providing ai agent for web3..

## Key Features

- Integration with Zerebro's platform
- Seamless user experience
- Enhanced functionality through partnership

## Integration with Eliza

Our partnership with Zerebro enables users to access their services directly through Eliza, providing a seamless experience for all users.

## Links

- [Website](https://zerebro.org/)
- [Source](https://zerebro.org/)
- [Twitter](https://x.com/0xzerebro)
`````

## File: packages/docs/partners/index.md
`````markdown
---
id: partners
title: ElizaOS Partners & Integrations
description: Explore the ecosystem of ElizaOS partners, integrations, and collaborations.
keywords: [partners, integrations, ecosystem, collaboration, AI agents, developers, platforms]
sidebar_position: 1
hide_table_of_contents: true
---

import PartnersComponent from '@site/src/components/PartnersComponent';

# Partners

Interested in being a partner? Reach out here: https://tally.so/r/3Ev6XX

<PartnersComponent />
`````

## File: packages/docs/partners/README.md
`````markdown
---
title: About
slug: /about
---

# Partners Documentation

This directory contains documentation for Eliza's partners. Each partner has their own subdirectory with an `index.md` file.

## Adding a New Partner

There are two ways to add a new partner:

### 1. Using the Script (Recommended)

Run the partner page creation script:

```bash
cd packages/docs
node scripts/create-partner-page.js
```

Follow the prompts to enter the partner's information. The script will create a new directory and `index.md` file for the partner.

### 2. Manual Creation

1. Create a new directory for the partner using their slug (lowercase, hyphenated name)
2. Create an `index.md` file inside the directory
3. Use the `_template.md` file as a reference for the structure
4. Update the `partners.tsx` file to include the new partner

## Updating Existing Partner Pages

To update all existing partner pages to use the markdown-friendly format:

```bash
cd packages/docs
node scripts/update-partner-pages.js
```

This script will:

- Preserve the existing content and frontmatter
- Add the partner logo at the top
- Format the title and links consistently
- Skip pages that already have the new format

## Partner Page Structure

Each partner page should include:

- Frontmatter with metadata (title, description, image, etc.)
- Partner logo
- Partner name and links (website, Twitter)
- Brief description
- About section
- Key features
- Integration with Eliza

## Updating Partner Information

To update a partner's information:

1. Edit the partner's `index.md` file
2. Update the corresponding entry in `partners.tsx` if necessary

## Image Guidelines

- Partner logos should be placed in `/static/img/partners/`
- Recommended size: 400x400 pixels
- Format: JPG, PNG, or WebP
- File naming: Use a descriptive name that includes the partner's name
`````

## File: packages/docs/blog/mission.mdx
`````
---
title: elizaOS Mission
description: Vision and product overview for ElizaOS including DegenSpartanAI, Autonomous Investor, and Agent Marketplace.
authors:
  - team
date: 2025-02-14
sidebar_position: 1
---

# elizaOS Mission

![](/img/banner1.jpg)

Our mission is to develop an extensible, modular, open-source AI agent framework that thrives across both Web2 and Web3 ecosystems. We see AI agents as the key stepping stones toward AGI, enabling increasingly autonomous and capable systems.

{/* truncate */}

## Core Philosophy

**Autonomy & Adaptability**: Agents should learn, reason, and adapt across diverse tasks without human intervention.  
**Modularity & Composability**: AI architectures should be modular, allowing for iterative improvements and robust scalability.  
**Decentralization & Open Collaboration**: AI systems should move beyond centralized control towards distributed intelligence and community-driven progress.

---

## Where Are We Now?

Our progress has been substantial, driven by an engaged community and continuous advancements in AI agent development. As an open-source project, we have built a thriving, decentralized ecosystem that is now maturing into the leading AI agent framework.

Here are some key statistics reflecting our current state:

- 127k+ holders supporting our token ecosystem.
- 500+ contributors actively improving our AI framework
- 100+ plugins developed for ElizaOS, significantly expanding its capabilities.
- 4.5k forks and 14.4k stars on our core repositories, showcasing strong developer interest.
- 200+ PRs merged just last week, highlighting rapid iteration and innovation.

These numbers demonstrate the growing momentum behind Eliza and the collective effort towards building the most extensible and effective AI agent framework on the market today.

In addition to a variety of upcoming enhancements with v2, the following is a roadmap for each of our current products.

---

## DegenSpartanAI

### Overview

DegenSpartanAI is a crypto-native AI trading agent that blends sentiment analysis, trading strategy automation, and community engagement with a distinct, irreverent personality. Initially refining core trading strategies and its comedic brand, it will evolve into an interactive AI with real-time market insights, user-driven discussions, and NFT collaborations. Long-term, it aims to become a fully autonomous trading agent, integrating multi-platform execution, adaptive learning, and a verifiable track record within the Global Trust Marketplace.

### Short Term

**Trading Enhancements:**

- Validate core strategies (e.g., momentum, scalp trading) to secure stable, profitable execution.

**Character Updates & Branding:**

- Fine-tune the DegenSpartanAI personality to ensure commentary better reflects current crypto trends, capturing the comedic spirit of the OG persona.
- Roll out new DegenSpartanAI visuals and a cohesive brand identity across social media, website, and partnership assets.

**Community Engagement:**

- Maintain an active social presence—highlighting successes, failures, and raw opinions about market conditions.
- Prepare for DegenSpartanAI’s participation in “Block Tank,” showcasing the agent’s unique edge to a broader audience.
- Clarify and document the long term strategy and buyback mechanisms that tie $degenai to the DAO, ensuring the community understands how $degenai is connected to the overall strategy.

### Medium Term

**Sentiment Analysis:**

- Implement new data & sentiment analysis layers fresh data feeds that give DegenSpartanAI real-time insight into market sentiment.
- Provide a user-friendly interface (or dashboard) so traders can see the logic behind DegenSpartanAI’s buy and sell signals, including relevant social sentiment metrics.

**Deeper Community Interaction:**

- Host DegenSpartanAI “Frontrooms”, public or semi-private chats where DegenSpartanAI actively converses with other AI agents—offering real-time banter, collaborative analysis, and joint trades.
- Provide Telegram/Discord rooms where traders can ask DegenSpartanAI for feedback on specific tokens or trends, with real-time contextual responses.

**AI-Driven NFT & Meme Projects:**

- Degen NFTs: Collaborate with Magic Eden on an AI-generated NFT series.

### Long Term

**Telegram Trading Agent:**

- Transform DegenSpartanAI into a fully‐integrated Telegram experience where traders enjoy lightning‐fast swaps, in‐depth sentiment insights, and a steady stream of humorous trash talk.

**Full Autonomy & Multi-Platform Trading:**

- Gradually reduce reliance on manual interventions by refining DegenSpartanAI’s sentiment analysis, trade sizing, and exit logic across multiple blockchains (L1s/L2s/etc).
- Incorporate user feedback, real-time data, and historical trade outcomes into an ever-evolving “Degen Brain” that continuously adapts to new market conditions.

**Global Trust Marketplace Ties:**

- **Deeper Integration**: When the Global Trust Marketplace (currently being developed for multiple AI trading solutions) solidifies, DegenSpartanAI’s track record can become a public score—making it a reference “agent” for accuracy and reliability.
- **Reputation & Collab**: Position DegenSpartanAI as a top influencer, partnering with other AI and DeFi teams to expand trust-based trading communities.

---

## Autonomous Investor

### Overview

ElizaOS's Autonomous Investor is a social-trading intelligence layer that combines AI-driven reputation scoring, trade validation, and decentralized execution. It enables users to submit trade calls, assess credibility via a Trust Marketplace, and integrate across various social platforms. Over time, it will evolve into a multi-instance system allowing groups to set their own risk parameters, manage DAO treasuries, and leverage customizable AI modules for enhanced investment strategies.

### Short Term

**Alpha MVP & Small-Group Testing:**

- We’ve started logging user-submitted calls to establish basic scoring and early reputation-building.
- The system prioritizes measured, social-trading behavior that feeds into a public leaderboard.
- We currently mix paper trades with small real-money positions to validate the full workflow—trade proposals, basic scam checks, and overall system stability.
- Ensuring data flow integrity remains a priority, particularly for LLM prompts, aggregator APIs, and security measures.

**Beta Rollout (~1,000 Users):**

- Integrate the Trust Marketplace with the DAO Discord and relevant Telegram groups.
- These steps will be formally announced in Discord and on X.
- We’ll provide onboarding guidelines for novices while gathering feedback from experienced traders.

**Trust Marketplace Official Go Live!**

### Medium Term

**Multi‐Instance Deployment:**

- Enable distinct communities (Telegram/Discord groups) to operate their own Autonomous Investor agents, all feeding into the central Trust Marketplace.
- Allow communities to set their own risk parameters, default scanning logic, and liquidity rules tailored to their subgroup.

**Partial Treasury Management:**

- We’ll explore the Autonomous Investor managing small‐sized funds or DAO sub‐treasuries to showcase the agent's investing capabilities.

**Enhanced Scoring Models:**

- Expand scoring to incorporate more advanced metrics around timeframe, volatility, user consistency, and overall risk management.
- Incorporate specialized training data, including historical price patterns and volatility indices, to refine predictive accuracy.

### Long Term

**Treasury Management & Larger Funds:**

- As the Autonomous Investor demonstrates consistent returns, aim for a larger partial or even full management of the DAOs on-chain assets.
- Explore official collaborations with DAOs or larger crypto funds that could benefit from user-driven intelligence and verifiable performance metrics.

**Research Customizable AI Modules:**

- Research! Investigate if we can provide an optional plugin registry after Eliza V2 (where the architecture cleanly separates “core vs. extension”), enabling third‐party devs to add specialized capabilities to the Autonomous Investor without compromising stability.

---

## Agent Marketplace

### Overview

The Agent Marketplace is a next-generation token launchpad and a no-code platform for simple agents. It differentiates from existing platforms by integrating multi-agent functionality, collaborative tokenomics, and AI-enhanced features, enabling both technical and non-technical users to seamlessly create and manage tokens and ElizaOS agents.

We’re only sharing the short-term roadmap to maintain the flexibility needed to refine how agents x crypto merge into novel experiences. Launching the initial tokenomics-focused platform sets a strong foundation for continuous iteration, paving the way for long-term generative networks.

### Short Term

**MVP Launch:**

- Complete the final audits on our custom-built LPing solution to ensure security and reliability.
- Secure commitments from top-tier teams for our initial launch and ongoing collaborations.
- Lock in remaining brand partnerships and key ecosystem alliances.
- Release the tokenomics and product simultaneously at launch.

![](/img/eliza-os_logo-mark_light.png)
`````

## File: packages/docs/docs/core/plugins.md
`````markdown
---
sidebar_position: 8
title: Plugin System
description: Learn about ElizaOS plugins - modular extensions that enhance agent capabilities
keywords: [plugins, extensions, modules, development, publishing, registry, npm, GitHub]
image: /img/plugins.png
---

# Plugins

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Plugins are modular extensions that enhance the capabilities of ElizaOS agents. They provide a flexible way to add new functionality, integrate external services, and customize agent behavior across different platforms.

:::info
Key Improvements in V2

1. **Unified API**: Almost everything is accessible via `runtime.methodName()` in the agent runtime for simpler development
2. **Enhanced Model System**: The new `useModel` approach allows for flexible model provider registration
3. **Events System**: Formal support for event-based programming
4. **Plugin Creation Workflow**: Simplified creation and testing via CLI
5. **Testing Infrastructure**: Built-in support for plugin testing
6. **No Monorepo Required**: Complete plugin development without touching the core codebase
7. **Plugin Registry**: Manages the catalog of available plugins and handles their registration with the runtime
8. **Bootstrap Plugin**: Initializes core functionality required for all agents to operate
   :::

The ElizaOS plugin system maintains the same basic concept as previous versions, with several new extension points (events, routes, tests, models) and features that significantly improve the developer experience.

**Browse plugins the elizaOS community made here: [Package Showcase](/packages)**

[![](/img/plugins.png)](/packages)

> elizaOS maintains an official package registry at [github.com/elizaos-plugins/registry](https://github.com/elizaos-plugins/registry).

---

## Quick Start

The new CLI tool introduces a streamlined workflow for plugin development without ever needing to touch the ElizaOS monorepo directly:

1. **Create**: `npm create eliza` - Initialize a new plugin project with proper structure
2. **Develop**: Edit the plugin code in the generated project structure
3. **Test**: `elizaos test` - Test the plugin functionality
4. **Run**: `elizaos start` - Run the plugin with a default agent
5. **Publish**: `elizaos publish` - Share your plugin with others

> Note: at time of publishing, use `npm create eliza@beta` until main version is uploaded

### Creating a New Plugin

You can create a new ElizaOS plugin using the CLI:

```bash
# Using npm
npm create eliza@beta

# Or using npx
npx @elizaos/cli@beta create
```

When prompted, select "Plugin" as the type to create. The CLI will guide you through the setup process, creating a plugin with the proper structure and dependencies.

---

### Managing Plugins

There are several ways to add plugins to your ElizaOS project:

<Tabs>
  <TabItem value="package" label="Via package.json">
    ```json
    {
      "dependencies": {
        "@elizaos/plugin-solana": "github:elizaos-plugins/plugin-solana",
        "@elizaos/plugin-twitter": "github:elizaos-plugins/plugin-twitter"
      }
    }
    ```
  </TabItem>
  <TabItem value="character" label="Via Character Definition">
    ```typescript
    // In src/index.ts
    export const character: Character = {
      name: 'MyAgent',
      plugins: ['@elizaos/plugin-twitter', '@elizaos/plugin-example'],
      // ...
    };
    ```
  </TabItem>
  <TabItem value="cli" label="Via CLI Commands">
    ```bash
    # Add a plugin
    elizaos plugins add @elizaos/plugin-twitter

    # Remove a plugin
    elizaos plugins remove @elizaos/plugin-twitter

    # List available plugins
    elizaos plugins list
    ```

  </TabItem>
</Tabs>

---

### Plugin Configuration

Configure plugin settings in your character definition:

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-example"],
  "settings": {
    "example": {
      "enableFeatureX": true
      // Plugin-specific configuration
    }
  }
}
```

### Plugin Loading Process

The AgentRuntime automatically loads the Bootstrap Plugin during initialization, before any other plugins:

```typescript
async initialize() {
  // Register bootstrap plugin
  await this.registerPlugin(bootstrapPlugin);

  // Then register additional plugins
  for (const plugin of this.plugins) {
    await this.registerPlugin(plugin);
  }

  // Initialize other components
  // ...
}
```

---

### Publishing Plugins

If you're a plugin developer, you can publish your plugin to make it available to others. The ElizaOS CLI provides several options for publishing your plugin depending on your needs.

First, make sure your plugin is built and ready for distribution:

```bash
# Navigate to your plugin directory
cd my-eliza-plugin

# Build your plugin
npm run build
```

<Tabs>
  <TabItem value="github" label="GitHub Publishing">
    Publishing to GitHub is the recommended approach for sharing your plugin with the ElizaOS community:

    ```bash
    # Publish to GitHub
    elizaos publish
    ```

    This will:
    1. Build and package your plugin
    2. Create or update a GitHub repository in the elizaos-plugins organization
    3. Add your plugin to the ElizaOS registry (if you're a registry maintainer)

    For first-time publishers, the CLI will guide you through setting up GitHub credentials for publishing.

    GitHub publishing is ideal for open-source plugins that you want to share with the community and have listed in the official registry.

  </TabItem>

  <TabItem value="npm" label="npm Publishing">
    You can also publish your plugin to npm:

    ```bash
    # Publish to npm
    elizaos publish --npm
    ```

    This allows users to install your plugin using standard npm commands:

    ```bash
    npm install @your-scope/plugin-name
    ```

    npm publishing is useful when you want to:
    - Maintain your own package namespace
    - Integrate with existing npm workflows
    - Set up automated versioning and releases

    Make sure your package.json is properly configured with the correct name, version, and access permissions.

  </TabItem>

  <TabItem value="testing" label="Test Mode">
    Before publishing, you can validate the process without making any external changes:

    ```bash
    # Test the publish process
    elizaos publish --test
    ```

    This runs through all the packaging and validation steps without actually publishing anything.

    Test mode is helpful for:
    - Verifying your plugin structure is correct
    - Ensuring all required files are present
    - Checking that dependencies are properly configured
    - Validating that your plugin can be built successfully

    Always run in test mode before your first public release to avoid issues.

  </TabItem>

  <TabItem value="customizing" label="Additional Options">
    The publish command supports several additional options to customize the publishing process:

    ```bash
    # Specify platform compatibility
    elizaos publish --platform node

    # Set custom version number
    elizaos publish --version 1.2.3

    # Provide a custom registry URL
    elizaos publish --registry https://custom-registry.com

    # Publish with public access
    elizaos publish --access public
    ```

    These options give you fine-grained control over how and where your plugin is published. Refer to `elizaos publish --help` for a complete list of options.

  </TabItem>
</Tabs>

:::info
When submitting a plugin to the [elizaOS Registry](https://github.com/elizaos-plugins/registry), include:

1. **Working Demo**: Screenshots or video of your plugin in action
2. **Test Results**: Evidence of successful integration and error handling
3. **Configuration Example**: Show how to properly configure your plugin
   :::

---

## Plugin Architecture

Eliza uses a unified plugin architecture where everything is a plugin - including services, adapters, actions, evaluators, and providers. This approach ensures consistent behavior and better extensibility.

### Plugin Components

Each plugin can provide one or more of the following components:

| Component          | Purpose                                                                         |
| ------------------ | ------------------------------------------------------------------------------- |
| **Services**       | Platform integrations (Discord, Twitter, etc.) or specialized capabilities      |
| **Actions**        | Executable functions triggered by the agent (reply, generate content, etc.)     |
| **Providers**      | Context providers that supply info to the agent during decision making          |
| **Evaluators**     | Analyze conversations to extract insights and improve future interactions       |
| **Adapters**       | Database or storage system integrations                                         |
| **Model Handlers** | Register handlers for different model types (text generation, embeddings, etc.) |
| **Event Handlers** | React to system events like messages, connections, or actions                   |
| **API Routes**     | Add custom REST endpoints to the agent's HTTP interface                         |
| **Tests**          | Include test suites to verify plugin functionality                              |

### Plugin Interface

All plugins implement the core Plugin interface:

```typescript
interface Plugin {
  name: string;
  description: string;
  config?: { [key: string]: any };

  // Optional initialization method
  init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;

  // Components
  services?: (typeof Service)[];
  actions?: Action[];
  providers?: Provider[];
  evaluators?: Evaluator[];
  adapters?: Adapter[];

  // Additional features
  routes?: Route[];
  tests?: TestSuite[];
  events?: { [key: string]: ((params: any) => Promise<any>)[] };
}
```

### Service Implementation

Services are the core integration points for external platforms. A properly implemented service:

```typescript
import { Service, IAgentRuntime } from '@elizaos/core';

export class ExampleService extends Service {
  // Required: Define the service type (used for runtime registration)
  static serviceType = 'example';

  // Required: Describe what this service enables the agent to do
  capabilityDescription = 'Enables the agent to interact with the Example platform';

  // Store runtime for service operations
  constructor(protected runtime: IAgentRuntime) {
    super();
    // Initialize connections, setup event handlers, etc.
  }

  // Required: Static method to create and initialize service instance
  static async start(runtime: IAgentRuntime): Promise<ExampleService> {
    const service = new ExampleService(runtime);
    // Additional initialization if needed
    return service;
  }

  // Required: Clean up resources when service is stopped
  async stop(): Promise<void> {
    // Close connections, release resources
  }

  // Optional: Custom methods for your service functionality
  async sendMessage(content: string, channelId: string): Promise<void> {
    // Implementation
  }
}
```

## Plugin Structure

Each plugin repository should follow this structure:

```
plugin-name/
├── images/                # Branding assets
│   ├── logo.png           # Square logo (400x400px)
│   ├── banner.png         # Banner image (1280x640px)
│   └── screenshots/       # Feature screenshots
├── src/
│   ├── index.ts           # Main plugin entry point
│   ├── service.ts         # Service implementation
│   ├── actions/           # Plugin-specific actions
│   ├── providers/         # Data providers
│   ├── types.ts           # Type definitions
│   └── environment.ts     # Configuration validation
├── tests/                 # Test suite
├── package.json           # Plugin configuration and dependencies
└── README.md              # Plugin documentation
```

### Plugin Entry Point

Your plugin's `index.ts` should export a Plugin object:

```typescript
// Example plugin implementation
import { type Plugin } from '@elizaos/core';
import { ExampleService } from './service';
import { searchAction } from './actions/search';
import { statusProvider } from './providers/status';

const examplePlugin: Plugin = {
  name: 'example',
  description: 'Example platform integration for ElizaOS',
  services: [ExampleService],
  actions: [searchAction],
  providers: [statusProvider],
  init: async (config, runtime) => {
    // Perform any necessary initialization
    const apiKey = runtime.getSetting('EXAMPLE_API_KEY');
    if (!apiKey) {
      console.warn('EXAMPLE_API_KEY not provided');
    }
  },
};

export default examplePlugin;
```

### Plugin Configuration

Your plugin's `package.json` should include an `agentConfig` section:

```json
{
  "name": "@elizaos/plugin-example",
  "version": "1.0.0",
  "agentConfig": {
    "pluginType": "elizaos:plugin:1.0.0",
    "pluginParameters": {
      "API_KEY": {
        "type": "string",
        "description": "API key for the Example service"
      }
    }
  }
}
```

### Environment Variables and Secrets

Plugins access configuration through the runtime with the following precedence:

1. Character settings secrets (highest priority)
2. Character settings
3. Global environment settings

#### Access Pattern

```typescript
// In your service implementation
const apiKey = runtime.getSetting('EXAMPLE_API_KEY');
const debugMode = runtime.getSetting('EXAMPLE_DEBUG_MODE'); // Returns boolean for "true"/"false" strings
```

#### Configuration in Character File

```json
{
  "name": "MyAgent",
  "plugins": ["@elizaos/plugin-example"],
  "settings": {
    "example": {
      "enableFeatureX": true
    },
    "secrets": {
      "EXAMPLE_API_KEY": "your-api-key-here"
    }
  }
}
```

---

## Bootstrap Plugin

The Bootstrap Plugin is a foundational component of ElizaOS that initializes the core functionality required for agents to operate. It's automatically loaded as part of the initialization process, establishing the minimum viable capabilities that all agents need.

```typescript
export const bootstrapPlugin: Plugin = {
  name: 'bootstrap',
  description: 'Agent bootstrap with basic actions and evaluators',
  actions: [...],
  events: {...},
  evaluators: [...],
  providers: [...],
  services: [TaskService, ScenarioService],
};
```

The Bootstrap Plugin registers essential components across several categories to provide a foundation for all agents. These components can be extended by custom plugins.

<Tabs>
  <TabItem value="actions" label="Actions">
    | Action                 | Description                                     |
    | ---------------------- | ----------------------------------------------- |
    | `replyAction`          | Generates and sends a response to a message     |
    | `followRoomAction`     | Enables an agent to actively follow a room      |
    | `unfollowRoomAction`   | Stops an agent from following a room            |
    | `muteRoomAction`       | Mutes notifications from a room                 |
    | `unmuteRoomAction`     | Unmutes notifications from a room               |
    | `sendMessageAction`    | Sends a message to a specific room              |
    | `ignoreAction`         | Explicitly ignores a message                    |
    | `noneAction`           | Acknowledges a message without taking action    |
    | `updateEntityAction`   | Updates properties of an entity                 |
    | `choiceAction`         | Presents choices to users and handles responses |
    | `updateRoleAction`     | Updates a user's role in a world                |
    | `updateSettingsAction` | Updates agent or world settings                 |
  </TabItem>
  
  <TabItem value="providers" label="Providers">
    | Provider                 | Description                                                |
    | ------------------------ | ---------------------------------------------------------- |
    | `characterProvider`      | Provides the agent's personality and configuration         |
    | `recentMessagesProvider` | Retrieves recent conversation history                      |
    | `knowledgeProvider`      | Supplies factual information from the knowledge base       |
    | `timeProvider`           | Provides awareness of current time and date                |
    | `entitiesProvider`       | Supplies information about entities in the current context |
    | `relationshipsProvider`  | Provides information about entity relationships            |
    | `factsProvider`          | Retrieves relevant facts from memory                       |
    | `roleProvider`           | Provides role information within worlds                    |
    | `settingsProvider`       | Supplies configured settings                               |
    | `anxietyProvider`        | Informs agent of potential issues to be careful about      |
    | `attachmentsProvider`    | Handles media and file attachments                         |
    | `providersProvider`      | Meta-provider with information about available providers   |
    | `actionsProvider`        | Meta-provider with information about available actions     |
    | `evaluatorsProvider`     | Meta-provider with information about available evaluators  |
    | `choiceProvider`         | Manages choice-based interactions                          |
    | `capabilitiesProvider`   | Provides information about agent capabilities              |
  </TabItem>
  
  <TabItem value="services" label="Services & Evaluators">
    **Services:**

    | Service           | Purpose                                          |
    | ----------------- | ------------------------------------------------ |
    | `TaskService`     | Manages deferred, scheduled, and repeating tasks |
    | `ScenarioService` | Handles scenario-based interactions and testing  |

    **Evaluators:**

    | Evaluator             | Description                                           |
    | --------------------- | ----------------------------------------------------- |
    | `reflectionEvaluator` | Enables self-awareness and learning from interactions |

  </TabItem>
  
  <TabItem value="events" label="Event Handlers">
    The Bootstrap Plugin registers handlers for key system events that enable the core message processing flow:

    **Core Events:**
    - `MESSAGE_RECEIVED` - Processes new messages and generates responses
    - `REACTION_RECEIVED` - Tracks reactions to messages
    - `VOICE_MESSAGE_RECEIVED` - Handles audio messages
    - `POST_GENERATED` - Creates social media content
    - `MESSAGE_SENT` - Logs outgoing messages

    **World Events:**
    - `WORLD_JOINED` / `WORLD_CONNECTED` - Synchronizes data when joining worlds
    - `ENTITY_JOINED` / `ENTITY_LEFT` - Manages entity presence

    **Lifecycle Events:**
    - `ACTION_STARTED` / `ACTION_COMPLETED` - Tracks action execution
    - `EVALUATOR_STARTED` / `EVALUATOR_COMPLETED` - Monitors evaluator processing
    - `RUN_STARTED` / `RUN_ENDED` / `RUN_TIMEOUT` - Manages message processing lifecycle

    The message processing flow follows these steps:
    1. Receive message via `MESSAGE_RECEIVED` event
    2. Save message to memory
    3. Check if agent should respond
    4. If responding, compose state from providers
    5. Generate a response using the language model
    6. Process any actions specified in the response
    7. Run evaluators on the conversation
    8. Emit lifecycle events throughout the process

  </TabItem>
</Tabs>

### Extending Bootstrap Functionality

While the Bootstrap Plugin provides core functionality, it's designed to be extended by other plugins. Custom plugins can:

1. **Add new actions** - Extend the agent's capabilities
2. **Register additional providers** - Supply more contextual information
3. **Add evaluators** - Create new ways to analyze and learn from interactions
4. **Handle additional events** - React to more system events
5. **Initialize custom services** - Provide new functionality

When working with plugins in relation to the Bootstrap Plugin:

1. **Don't modify bootstrap directly** - Instead, create custom plugins to extend functionality
2. **Understand provider contribution** - Know how each provider contributes to the agent's context
3. **Learn the core actions** - Become familiar with the actions that all agents can perform
4. **Leverage event handlers** - Use the event system for reactive behavior
5. **Extend, don't replace** - Build on top of bootstrap functionality rather than replacing it

---

## Developing a Plugin

When developing a new plugin, focus on these key aspects:

1. **Service Implementation**: Create a solid service class following the pattern above
2. **Proper Error Handling**: Handle API failures gracefully
3. **Type Definitions**: Define clear interfaces and types
4. **Documentation**: Include detailed setup instructions
5. **Tests**: Add test cases for your functionality

### Testing Your Plugin

During development, you can test your plugin locally:

```bash
# Start with your plugin
elizaos start --plugin=./path/to/plugin

# Or with a specific character
elizaos start --character=./characters/test.character.json --plugin=./path/to/plugin
```

### Distribution & PR Requirements

When submitting a plugin to the [elizaOS Registry](https://github.com/elizaos-plugins/registry), include:

1. **Working Demo**: Screenshots or video of your plugin in action
2. **Test Results**: Evidence of successful integration and error handling
3. **Configuration Example**: Show how to properly configure your plugin
4. **Quality Checklist**:
   - [ ] Plugin follows the standard structure
   - [ ] Required branding assets are included
   - [ ] Documentation is complete
   - [ ] GitHub topics properly set
   - [ ] Tests are passing
   - [ ] Includes error handling

---

## FAQ

### What exactly is a plugin in ElizaOS?

A plugin is a modular extension that adds new capabilities to ElizaOS agents, such as API integrations, custom actions, or platform connections. Plugins allow you to expand agent functionality and share reusable components with other developers.

### When should I create a plugin versus using existing ones?

Create a plugin when you need custom functionality not available in existing plugins, want to integrate with external services, or plan to share reusable agent capabilities with the community.

### How do I manage plugin dependencies?

Plugin dependencies are managed through your project's `package.json`. You can add plugins directly using npm or the ElizaOS CLI, and they will be automatically loaded when your project starts.

### Can I use a plugin in development before publishing?

Yes, you can use the `--plugin` flag with the `start` command to include local plugins during development:

```bash
elizaos start --plugin=./path/to/plugin
```

### What's the difference between Actions and Services?

Actions handle specific agent responses or behaviors, while Services provide platform integrations (like Discord or Twitter) or ongoing background functionality that multiple actions might use.

### How do I handle rate limits with external APIs?

Implement proper backoff strategies in your service implementation and consider using a queue system for message handling to respect platform rate limits.

## Additional Resources

- [ElizaOS Registry](https://github.com/elizaos-plugins/registry)
- [Example Plugins](https://github.com/elizaos-plugins)
- [Discord Community](https://discord.gg/elizaos)
`````

## File: packages/docs/news/2025-04-13.md
`````markdown
# Daily Report - 2025-04-13

## ElizaOS Development

- ElizaOS v2 targeted for release at the end of the month
- Project "eliza" accepted into Gitcoin Grant GG23
- Community members can support through donations with matching mechanism

## AI Agents and Cryptocurrency

- Discussions about AI agents using stablecoins like USDC or USDT for transactions
- New "Eliza wallet" concept with improved UI/UX mentioned
- References to enforcing DAO contributions for transactions by ElizaOS agents
- MetaMask's 0.875% service fee on transactions discussed
- Security considerations for AI-managed transactions using hardware key confirmation

## Spartan AI Platform

- Planning cross-platform expansion with integration into Discord
- "Xeeting" functionality planned for V2
- Three exclusive plugins mentioned for Spartan V2:
  - community-investor (personal finance interface)
  - autonomous trader (executing trade strategies via Jupiter)
  - intel (market information gathering)
- Focus on creating value for token holders through platform development

## Cryptocurrency Token Discussions

- Users shared cryptocurrency token links and information
- Discussion about 'fart' themed tokens
- Potential AI16Z platform launch mentioned
- 'Fart Meme Index' token performance compared against Ethereum

## Content Publishing

- Discussion about exporting an episode for YouTube
- QA process involves checking if content aligns with a news aggregator
`````

## File: packages/docs/news/2025-04-14.md
`````markdown
# Daily Report - 2025-04-14

## ElizaOS Discord Community

### Technical Challenges

- Model initialization errors with embedding models and JSON parsing failures
- PGlite database configuration problems on Mac systems
- Twitter integration issues with mention detection
- Plugin compatibility challenges between ElizaOS v1 and v2
- Installation and build errors on M4 Macs
  - Solution: Adding `"types": ["node"]` to tsconfig.json

### Product Developments

- "auto.fun" launching soon, with "v2 gold" expected the following week
- "Trust marketplace" confirmed as a separate product from "auto.fun"
- Team member "borkochomp" acknowledged plans to improve internal communications

### Security Considerations

- Proposal to partner with Immunefi (web3 security firm) for security auditing services
- Discussions about funding security audits

## Community Discussions

### Project Updates

- SYMBaiEX project implemented Meta Llama 4 for its UmbrA agent
- SYMBaiEX made significant frontend improvements
- Team member rhota announced leaving Eliza Labs while continuing to contribute to ElizaOS

### Technical Insights

- Users discussed AI inference performance
- Recommendations to use Groq for faster processing (700+ tokens/sec)
- Cryptocurrency trading discussions on Solana blockchain
- Users shared token contract addresses

### Account Information

- DegenAI/Spartan X accounts restored after suspension
- Clarification that certain Discord channels are private and only available to token holders
- Community members advised to maintain a low profile on social media
`````

## File: packages/docs/news/2025-04-15.md
`````markdown
# Daily Report - 2025-04-15

## Spartan Project Development

- DegenAI identified as current development focus
- Odilitime working as one of the developers on DegenAI
- Plans for promotion through "autofun" in progress
- Community member offered assistance with quantitative finance aspects

## Auto.fun Platform

- Platform actively being developed with launch scheduled this week
- Documentation and UI mockups shared with the community
- Described as an "agent launchpad"

## ElizaOS Technical Support

- Technical solutions provided for PostgreSQL plugin error
- Pull request addressing Levenshtein character limit issue
- Discussion of plugin migration between V1 and V2 versions
- Configuration details for various model providers (OpenAI, Anthropic, Groq)

## Cryptocurrency Trading Activities

- Active discussions on Solana blockchain tokens
- Trading analysis of specific tokens: ALCH, AI16z, TANK, and Gummify
- Users sharing wallet behaviors, support levels, and trading strategies
- Trading decisions being made on platforms like pump.fun
- Analysis of Gummify token included examination of seller wallet behaviors
`````

## File: packages/docs/news/2025-04-16.md
`````markdown
# Daily Report - 2025-04-16

## GitHub Activity Summary

- 5 new pull requests (2 merged)
- 4 new issues opened
- 12 active developers contributing

## Merged Pull Requests

- **PR #4223**: Bugfix addressing issues in the relationship between entities and agents
- **PR #4300**: GUI enhancement improving the graphical user interface

## Recent Pull Requests

- **Test Suite for CLI** (PRs #4290, #4301): Implementation of test suite for command-line interface
- **LLM Instrumentation** (PR #4304): Added instrumentation for Large Language Models
- **Remote Attestation Action Fix** (PR #4305): Addressed issues with remote attestation action
- **GUI Enhancements** (PR #4300): Enhanced graphical user interface for improved user experience

## Recent Issues

- **Issue #4298**: GOAT Plugin usage issue
- **Issue #4299**: Handling content responses from the model
- **Issue #4302**: Task.World redundancy
- **Issue #4303**: USE_LOCAL_AI configuration setting

## Discord Discussions

### Auto.fun Platform Launch

- AI-generated token creation with instant name, description, ticker, and image generation
- Client-side vanity contract address generation
- Import and customization options
- Integration with Raydium for liquidity pools
- Creators receive NFTs to claim fees directly
- Plans for API for trading terminals post-launch
- Revenue model designed as a team sustainability mechanism

### ElizaOS Technical Support

- Configuration solutions for Google Gemini integration
- Environment variable configuration guidance
- Version compatibility clarification between ElizaOS v1.0.0-beta and plugins
- Troubleshooting assistance for Bun runtime instability
- Proper .env file placement instructions

### Upcoming Features

- Eliza v2 features including agent hosting via Fleek
- Leaderboard technical issue being fixed via GitHub PR #76
`````

## File: packages/docs/news/2025-04-17.md
`````markdown
# Daily Report - 2025-04-17

## Recent ElizaOS Pull Requests

### Bug Fixes

- Fixed issue with exposing Telegram types (PR #4287)
- Resolved external dependency issue (PR #4306)
- Fixed remote attestation action (PR #4305)
- Corrected GUI missing requirement indicator and tooltips (PR #4307)

### New Features

- Added CLI test suite (PR #4301)

## GitHub Activity (April 17-18, 2025)

- 6 new pull requests submitted with 5 merged
- 1 new issue opened
- 11 contributors participating during this period

### Recent Pull Requests

- PR #4308: Added API endpoint for querying trace data (ELI2-234)
- PR #4311: Exported bootstrap plugin capabilities
- PR #4307: Fixed GUI issue with missing requirement indicators and tooltips

### Issues

- Issue #4309: Testing on physical Ubuntu machine (non-VM)

## Discord Discussions

### Auto.fun Platform

- Auto.fun platform scheduled to launch this week
- Platform will serve as a launchpad for AI agents
- Security measures implemented to prevent scams and drainers
- Users will be able to pick custom suffixes for tokens, with "fun" as default

### Technical Discussions

- Twitter agent action intervals configuration
- Plugin installation processes
- Migration between versions
- OpenAI plugin initialization
- Database connection configuration
- Deployment options using PM2

### Cryptocurrency Trading

- Active discussions about tokens on Solana blockchain
- Tokens discussed included "TANK," "JProof," and "Send"
- Users sharing contract addresses and price movements

## Crypto Market Update

- Wrapped Ethereum (WETH): $1,577.81
- Solana (SOL): $131.42
`````


# Instruction
# ElizaOS Developer Context

This file contains the core technical aspects of ElizaOS, focusing on its architecture, implementation, and developer-facing components. The codebase is organized as a monorepo with several key packages:

## Key Components

1. **Core Package**: The foundation of ElizaOS with the agent runtime, entity management, actions, and database interactions
2. **CLI Package**: Command-line interface for managing agents, projects, and development tasks
3. **Client Package**: Frontend interface components and API interactions
4. **SQL/Database**: Database adapters and schema management
5. **Autodoc**: Documentation generation tools

## Technical Goals

When analyzing this codebase:

- Focus on the architecture and relationships between components
- Identify core abstractions and design patterns
- Understand the runtime execution flow
- Analyze how agents, actions, and providers work together
- Look for opportunities to improve code organization and performance
- Consider modular extension points and plugin architecture

## Output Guidance

- When suggesting improvements, focus on technical aspects like code structure, performance optimizations, and architectural changes
- Include specific code examples when proposing changes
- Consider backwards compatibility and migration paths for any proposed changes
- Highlight innovative technical approaches used in the system
- When asked about implementation details, provide comprehensive technical explanations
